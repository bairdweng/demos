// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://192.168.1.95:4477"
var Secret = ""

func (client *Client) CommonlyUsedPersonnel(params CommonlyUsedPersonnelWhereUniqueInput) *CommonlyUsedPersonnelExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CommonlyUsedPersonnelWhereUniqueInput!", "CommonlyUsedPersonnel"},
		"commonlyUsedPersonnel",
		[]string{"id", "companyId", "appId", "userId", "name", "avatar", "cardNo", "mobile", "bankNo", "education", "address", "remark", "signingTime", "createdAt", "updatedAt", "deletedAt"})

	return &CommonlyUsedPersonnelExec{ret}
}

type CommonlyUsedPersonnelsParams struct {
	Where   *CommonlyUsedPersonnelWhereInput   `json:"where,omitempty"`
	OrderBy *CommonlyUsedPersonnelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                             `json:"skip,omitempty"`
	After   *string                            `json:"after,omitempty"`
	Before  *string                            `json:"before,omitempty"`
	First   *int32                             `json:"first,omitempty"`
	Last    *int32                             `json:"last,omitempty"`
}

func (client *Client) CommonlyUsedPersonnels(params *CommonlyUsedPersonnelsParams) *CommonlyUsedPersonnelExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CommonlyUsedPersonnelWhereInput", "CommonlyUsedPersonnelOrderByInput", "CommonlyUsedPersonnel"},
		"commonlyUsedPersonnels",
		[]string{"id", "companyId", "appId", "userId", "name", "avatar", "cardNo", "mobile", "bankNo", "education", "address", "remark", "signingTime", "createdAt", "updatedAt", "deletedAt"})

	return &CommonlyUsedPersonnelExecArray{ret}
}

type CommonlyUsedPersonnelsConnectionParams struct {
	Where   *CommonlyUsedPersonnelWhereInput   `json:"where,omitempty"`
	OrderBy *CommonlyUsedPersonnelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                             `json:"skip,omitempty"`
	After   *string                            `json:"after,omitempty"`
	Before  *string                            `json:"before,omitempty"`
	First   *int32                             `json:"first,omitempty"`
	Last    *int32                             `json:"last,omitempty"`
}

func (client *Client) CommonlyUsedPersonnelsConnection(params *CommonlyUsedPersonnelsConnectionParams) *CommonlyUsedPersonnelConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CommonlyUsedPersonnelWhereInput", "CommonlyUsedPersonnelOrderByInput", "CommonlyUsedPersonnel"},
		"commonlyUsedPersonnelsConnection",
		[]string{"edges", "pageInfo"})

	return &CommonlyUsedPersonnelConnectionExec{ret}
}

func (client *Client) CompanyUserBlacklist(params CompanyUserBlacklistWhereUniqueInput) *CompanyUserBlacklistExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CompanyUserBlacklistWhereUniqueInput!", "CompanyUserBlacklist"},
		"companyUserBlacklist",
		[]string{"id", "companyId", "participantId", "publisherId", "workId", "type", "createdAt", "updatedAt", "deletedAt"})

	return &CompanyUserBlacklistExec{ret}
}

type CompanyUserBlacklistsParams struct {
	Where   *CompanyUserBlacklistWhereInput   `json:"where,omitempty"`
	OrderBy *CompanyUserBlacklistOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                            `json:"skip,omitempty"`
	After   *string                           `json:"after,omitempty"`
	Before  *string                           `json:"before,omitempty"`
	First   *int32                            `json:"first,omitempty"`
	Last    *int32                            `json:"last,omitempty"`
}

func (client *Client) CompanyUserBlacklists(params *CompanyUserBlacklistsParams) *CompanyUserBlacklistExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CompanyUserBlacklistWhereInput", "CompanyUserBlacklistOrderByInput", "CompanyUserBlacklist"},
		"companyUserBlacklists",
		[]string{"id", "companyId", "participantId", "publisherId", "workId", "type", "createdAt", "updatedAt", "deletedAt"})

	return &CompanyUserBlacklistExecArray{ret}
}

type CompanyUserBlacklistsConnectionParams struct {
	Where   *CompanyUserBlacklistWhereInput   `json:"where,omitempty"`
	OrderBy *CompanyUserBlacklistOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                            `json:"skip,omitempty"`
	After   *string                           `json:"after,omitempty"`
	Before  *string                           `json:"before,omitempty"`
	First   *int32                            `json:"first,omitempty"`
	Last    *int32                            `json:"last,omitempty"`
}

func (client *Client) CompanyUserBlacklistsConnection(params *CompanyUserBlacklistsConnectionParams) *CompanyUserBlacklistConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CompanyUserBlacklistWhereInput", "CompanyUserBlacklistOrderByInput", "CompanyUserBlacklist"},
		"companyUserBlacklistsConnection",
		[]string{"edges", "pageInfo"})

	return &CompanyUserBlacklistConnectionExec{ret}
}

func (client *Client) CompanyUserKpi(params CompanyUserKpiWhereUniqueInput) *CompanyUserKpiExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CompanyUserKpiWhereUniqueInput!", "CompanyUserKpi"},
		"companyUserKpi",
		[]string{"id", "workId", "amount", "companyId", "participantId", "payAt", "publisherId", "isPaid", "kpiCoefficient", "extend", "createdAt", "updatedAt"})

	return &CompanyUserKpiExec{ret}
}

type CompanyUserKpisParams struct {
	Where   *CompanyUserKpiWhereInput   `json:"where,omitempty"`
	OrderBy *CompanyUserKpiOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) CompanyUserKpis(params *CompanyUserKpisParams) *CompanyUserKpiExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CompanyUserKpiWhereInput", "CompanyUserKpiOrderByInput", "CompanyUserKpi"},
		"companyUserKpis",
		[]string{"id", "workId", "amount", "companyId", "participantId", "payAt", "publisherId", "isPaid", "kpiCoefficient", "extend", "createdAt", "updatedAt"})

	return &CompanyUserKpiExecArray{ret}
}

type CompanyUserKpisConnectionParams struct {
	Where   *CompanyUserKpiWhereInput   `json:"where,omitempty"`
	OrderBy *CompanyUserKpiOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) CompanyUserKpisConnection(params *CompanyUserKpisConnectionParams) *CompanyUserKpiConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CompanyUserKpiWhereInput", "CompanyUserKpiOrderByInput", "CompanyUserKpi"},
		"companyUserKpisConnection",
		[]string{"edges", "pageInfo"})

	return &CompanyUserKpiConnectionExec{ret}
}

func (client *Client) ImportLogs(params ImportLogsWhereUniqueInput) *ImportLogsExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ImportLogsWhereUniqueInput!", "ImportLogs"},
		"importLogs",
		[]string{"id", "fileHash", "name", "mobile", "cardNo", "status", "logContent", "createdAt", "updatedAt"})

	return &ImportLogsExec{ret}
}

type ImportLogsesParams struct {
	Where   *ImportLogsWhereInput   `json:"where,omitempty"`
	OrderBy *ImportLogsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) ImportLogses(params *ImportLogsesParams) *ImportLogsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ImportLogsWhereInput", "ImportLogsOrderByInput", "ImportLogs"},
		"importLogses",
		[]string{"id", "fileHash", "name", "mobile", "cardNo", "status", "logContent", "createdAt", "updatedAt"})

	return &ImportLogsExecArray{ret}
}

type ImportLogsesConnectionParams struct {
	Where   *ImportLogsWhereInput   `json:"where,omitempty"`
	OrderBy *ImportLogsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) ImportLogsesConnection(params *ImportLogsesConnectionParams) *ImportLogsConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ImportLogseWhereInput", "ImportLogseOrderByInput", "ImportLogse"},
		"importLogsesConnection",
		[]string{"edges", "pageInfo"})

	return &ImportLogsConnectionExec{ret}
}

func (client *Client) Job(params JobWhereUniqueInput) *JobExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"JobWhereUniqueInput!", "Job"},
		"job",
		[]string{"id", "workId", "category", "settlementRule", "payStatus", "progress", "quota", "singleRewardMax", "singleRewardMin", "isCanComment", "isNeedProof", "proofDescription", "proofType", "remark", "templateId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobExec{ret}
}

type JobsParams struct {
	Where   *JobWhereInput   `json:"where,omitempty"`
	OrderBy *JobOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) Jobs(params *JobsParams) *JobExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobWhereInput", "JobOrderByInput", "Job"},
		"jobs",
		[]string{"id", "workId", "category", "settlementRule", "payStatus", "progress", "quota", "singleRewardMax", "singleRewardMin", "isCanComment", "isNeedProof", "proofDescription", "proofType", "remark", "templateId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobExecArray{ret}
}

type JobsConnectionParams struct {
	Where   *JobWhereInput   `json:"where,omitempty"`
	OrderBy *JobOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) JobsConnection(params *JobsConnectionParams) *JobConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobWhereInput", "JobOrderByInput", "Job"},
		"jobsConnection",
		[]string{"edges", "pageInfo"})

	return &JobConnectionExec{ret}
}

func (client *Client) JobAchievement(params JobAchievementWhereUniqueInput) *JobAchievementExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"JobAchievementWhereUniqueInput!", "JobAchievement"},
		"jobAchievement",
		[]string{"id", "jobId", "userId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobAchievementExec{ret}
}

type JobAchievementsParams struct {
	Where   *JobAchievementWhereInput   `json:"where,omitempty"`
	OrderBy *JobAchievementOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) JobAchievements(params *JobAchievementsParams) *JobAchievementExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobAchievementWhereInput", "JobAchievementOrderByInput", "JobAchievement"},
		"jobAchievements",
		[]string{"id", "jobId", "userId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobAchievementExecArray{ret}
}

type JobAchievementsConnectionParams struct {
	Where   *JobAchievementWhereInput   `json:"where,omitempty"`
	OrderBy *JobAchievementOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) JobAchievementsConnection(params *JobAchievementsConnectionParams) *JobAchievementConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobAchievementWhereInput", "JobAchievementOrderByInput", "JobAchievement"},
		"jobAchievementsConnection",
		[]string{"edges", "pageInfo"})

	return &JobAchievementConnectionExec{ret}
}

func (client *Client) JobContractJournal(params JobContractJournalWhereUniqueInput) *JobContractJournalExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"JobContractJournalWhereUniqueInput!", "JobContractJournal"},
		"jobContractJournal",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "activeTimestamp", "isHandled", "extend", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobContractJournalExec{ret}
}

type JobContractJournalsParams struct {
	Where   *JobContractJournalWhereInput   `json:"where,omitempty"`
	OrderBy *JobContractJournalOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                          `json:"skip,omitempty"`
	After   *string                         `json:"after,omitempty"`
	Before  *string                         `json:"before,omitempty"`
	First   *int32                          `json:"first,omitempty"`
	Last    *int32                          `json:"last,omitempty"`
}

func (client *Client) JobContractJournals(params *JobContractJournalsParams) *JobContractJournalExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobContractJournalWhereInput", "JobContractJournalOrderByInput", "JobContractJournal"},
		"jobContractJournals",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "activeTimestamp", "isHandled", "extend", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobContractJournalExecArray{ret}
}

type JobContractJournalsConnectionParams struct {
	Where   *JobContractJournalWhereInput   `json:"where,omitempty"`
	OrderBy *JobContractJournalOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                          `json:"skip,omitempty"`
	After   *string                         `json:"after,omitempty"`
	Before  *string                         `json:"before,omitempty"`
	First   *int32                          `json:"first,omitempty"`
	Last    *int32                          `json:"last,omitempty"`
}

func (client *Client) JobContractJournalsConnection(params *JobContractJournalsConnectionParams) *JobContractJournalConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobContractJournalWhereInput", "JobContractJournalOrderByInput", "JobContractJournal"},
		"jobContractJournalsConnection",
		[]string{"edges", "pageInfo"})

	return &JobContractJournalConnectionExec{ret}
}

func (client *Client) JobMember(params JobMemberWhereUniqueInput) *JobMemberExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"JobMemberWhereUniqueInput!", "JobMember"},
		"jobMember",
		[]string{"id", "workId", "companyId", "publisherId", "participantId", "source", "progress", "proofFileUrl", "reward", "participateAt", "finishAt", "remark", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobMemberExec{ret}
}

type JobMembersParams struct {
	Where   *JobMemberWhereInput   `json:"where,omitempty"`
	OrderBy *JobMemberOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) JobMembers(params *JobMembersParams) *JobMemberExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobMemberWhereInput", "JobMemberOrderByInput", "JobMember"},
		"jobMembers",
		[]string{"id", "workId", "companyId", "publisherId", "participantId", "source", "progress", "proofFileUrl", "reward", "participateAt", "finishAt", "remark", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobMemberExecArray{ret}
}

type JobMembersConnectionParams struct {
	Where   *JobMemberWhereInput   `json:"where,omitempty"`
	OrderBy *JobMemberOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) JobMembersConnection(params *JobMembersConnectionParams) *JobMemberConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobMemberWhereInput", "JobMemberOrderByInput", "JobMember"},
		"jobMembersConnection",
		[]string{"edges", "pageInfo"})

	return &JobMemberConnectionExec{ret}
}

func (client *Client) JobTemplate(params JobTemplateWhereUniqueInput) *JobTemplateExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"JobTemplateWhereUniqueInput!", "JobTemplate"},
		"jobTemplate",
		[]string{"id", "appId", "platformAppid", "companyId", "companyName", "serviceCompanyId", "serviceCompanyName", "userId", "workType", "signTemplateId", "serviceTypeId", "serviceTypeName", "name", "requirement", "settlementRule", "kpiTemplateUrl", "downloadCode", "displayName", "isEnable", "source", "extend", "bizContent", "remark", "contractNo", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateExec{ret}
}

type JobTemplatesParams struct {
	Where   *JobTemplateWhereInput   `json:"where,omitempty"`
	OrderBy *JobTemplateOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) JobTemplates(params *JobTemplatesParams) *JobTemplateExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobTemplateWhereInput", "JobTemplateOrderByInput", "JobTemplate"},
		"jobTemplates",
		[]string{"id", "appId", "platformAppid", "companyId", "companyName", "serviceCompanyId", "serviceCompanyName", "userId", "workType", "signTemplateId", "serviceTypeId", "serviceTypeName", "name", "requirement", "settlementRule", "kpiTemplateUrl", "downloadCode", "displayName", "isEnable", "source", "extend", "bizContent", "remark", "contractNo", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateExecArray{ret}
}

type JobTemplatesConnectionParams struct {
	Where   *JobTemplateWhereInput   `json:"where,omitempty"`
	OrderBy *JobTemplateOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) JobTemplatesConnection(params *JobTemplatesConnectionParams) *JobTemplateConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobTemplateWhereInput", "JobTemplateOrderByInput", "JobTemplate"},
		"jobTemplatesConnection",
		[]string{"edges", "pageInfo"})

	return &JobTemplateConnectionExec{ret}
}

func (client *Client) JobTemplateDelay(params JobTemplateDelayWhereUniqueInput) *JobTemplateDelayExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"JobTemplateDelayWhereUniqueInput!", "JobTemplateDelay"},
		"jobTemplateDelay",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "isNeedProcessBegin", "isNeedProcessEnd", "extend", "bizContent", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateDelayExec{ret}
}

type JobTemplateDelaysParams struct {
	Where   *JobTemplateDelayWhereInput   `json:"where,omitempty"`
	OrderBy *JobTemplateDelayOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                        `json:"skip,omitempty"`
	After   *string                       `json:"after,omitempty"`
	Before  *string                       `json:"before,omitempty"`
	First   *int32                        `json:"first,omitempty"`
	Last    *int32                        `json:"last,omitempty"`
}

func (client *Client) JobTemplateDelays(params *JobTemplateDelaysParams) *JobTemplateDelayExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobTemplateDelayWhereInput", "JobTemplateDelayOrderByInput", "JobTemplateDelay"},
		"jobTemplateDelays",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "isNeedProcessBegin", "isNeedProcessEnd", "extend", "bizContent", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateDelayExecArray{ret}
}

type JobTemplateDelaysConnectionParams struct {
	Where   *JobTemplateDelayWhereInput   `json:"where,omitempty"`
	OrderBy *JobTemplateDelayOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                        `json:"skip,omitempty"`
	After   *string                       `json:"after,omitempty"`
	Before  *string                       `json:"before,omitempty"`
	First   *int32                        `json:"first,omitempty"`
	Last    *int32                        `json:"last,omitempty"`
}

func (client *Client) JobTemplateDelaysConnection(params *JobTemplateDelaysConnectionParams) *JobTemplateDelayConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"JobTemplateDelayWhereInput", "JobTemplateDelayOrderByInput", "JobTemplateDelay"},
		"jobTemplateDelaysConnection",
		[]string{"edges", "pageInfo"})

	return &JobTemplateDelayConnectionExec{ret}
}

func (client *Client) KpiUploadLog(params KpiUploadLogWhereUniqueInput) *KpiUploadLogExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"KpiUploadLogWhereUniqueInput!", "KpiUploadLog"},
		"kpiUploadLog",
		[]string{"id", "companyId", "fileName", "fileUrl", "hash", "createdAt", "updatedAt"})

	return &KpiUploadLogExec{ret}
}

type KpiUploadLogsParams struct {
	Where   *KpiUploadLogWhereInput   `json:"where,omitempty"`
	OrderBy *KpiUploadLogOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) KpiUploadLogs(params *KpiUploadLogsParams) *KpiUploadLogExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"KpiUploadLogWhereInput", "KpiUploadLogOrderByInput", "KpiUploadLog"},
		"kpiUploadLogs",
		[]string{"id", "companyId", "fileName", "fileUrl", "hash", "createdAt", "updatedAt"})

	return &KpiUploadLogExecArray{ret}
}

type KpiUploadLogsConnectionParams struct {
	Where   *KpiUploadLogWhereInput   `json:"where,omitempty"`
	OrderBy *KpiUploadLogOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) KpiUploadLogsConnection(params *KpiUploadLogsConnectionParams) *KpiUploadLogConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"KpiUploadLogWhereInput", "KpiUploadLogOrderByInput", "KpiUploadLog"},
		"kpiUploadLogsConnection",
		[]string{"edges", "pageInfo"})

	return &KpiUploadLogConnectionExec{ret}
}

func (client *Client) UserWeChatAuthorize(params UserWeChatAuthorizeWhereUniqueInput) *UserWeChatAuthorizeExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWeChatAuthorizeWhereUniqueInput!", "UserWeChatAuthorize"},
		"userWeChatAuthorize",
		[]string{"id", "userId", "mobile", "createdAt", "updatedAt", "deletedAt"})

	return &UserWeChatAuthorizeExec{ret}
}

type UserWeChatAuthorizesParams struct {
	Where   *UserWeChatAuthorizeWhereInput   `json:"where,omitempty"`
	OrderBy *UserWeChatAuthorizeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                           `json:"skip,omitempty"`
	After   *string                          `json:"after,omitempty"`
	Before  *string                          `json:"before,omitempty"`
	First   *int32                           `json:"first,omitempty"`
	Last    *int32                           `json:"last,omitempty"`
}

func (client *Client) UserWeChatAuthorizes(params *UserWeChatAuthorizesParams) *UserWeChatAuthorizeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWeChatAuthorizeWhereInput", "UserWeChatAuthorizeOrderByInput", "UserWeChatAuthorize"},
		"userWeChatAuthorizes",
		[]string{"id", "userId", "mobile", "createdAt", "updatedAt", "deletedAt"})

	return &UserWeChatAuthorizeExecArray{ret}
}

type UserWeChatAuthorizesConnectionParams struct {
	Where   *UserWeChatAuthorizeWhereInput   `json:"where,omitempty"`
	OrderBy *UserWeChatAuthorizeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                           `json:"skip,omitempty"`
	After   *string                          `json:"after,omitempty"`
	Before  *string                          `json:"before,omitempty"`
	First   *int32                           `json:"first,omitempty"`
	Last    *int32                           `json:"last,omitempty"`
}

func (client *Client) UserWeChatAuthorizesConnection(params *UserWeChatAuthorizesConnectionParams) *UserWeChatAuthorizeConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWeChatAuthorizeWhereInput", "UserWeChatAuthorizeOrderByInput", "UserWeChatAuthorize"},
		"userWeChatAuthorizesConnection",
		[]string{"edges", "pageInfo"})

	return &UserWeChatAuthorizeConnectionExec{ret}
}

func (client *Client) Work(params WorkWhereUniqueInput) *WorkExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"WorkWhereUniqueInput!", "Work"},
		"work",
		[]string{"id", "appId", "companyId", "userId", "serviceTypeId", "workType", "name", "requirement", "payType", "duration", "endAt", "source", "status", "type", "isPublic", "mediaCoverUrl", "mediaUrls", "resume", "extend", "updatedAt", "createdAt", "deletedAt"})

	return &WorkExec{ret}
}

type WorksParams struct {
	Where   *WorkWhereInput   `json:"where,omitempty"`
	OrderBy *WorkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Works(params *WorksParams) *WorkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WorkWhereInput", "WorkOrderByInput", "Work"},
		"works",
		[]string{"id", "appId", "companyId", "userId", "serviceTypeId", "workType", "name", "requirement", "payType", "duration", "endAt", "source", "status", "type", "isPublic", "mediaCoverUrl", "mediaUrls", "resume", "extend", "updatedAt", "createdAt", "deletedAt"})

	return &WorkExecArray{ret}
}

type WorksConnectionParams struct {
	Where   *WorkWhereInput   `json:"where,omitempty"`
	OrderBy *WorkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) WorksConnection(params *WorksConnectionParams) *WorkConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WorkWhereInput", "WorkOrderByInput", "Work"},
		"worksConnection",
		[]string{"edges", "pageInfo"})

	return &WorkConnectionExec{ret}
}

func (client *Client) WorkExtend(params WorkExtendWhereUniqueInput) *WorkExtendExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"WorkExtendWhereUniqueInput!", "WorkExtend"},
		"workExtend",
		[]string{"id", "workId", "appId", "focusCount", "likeCount", "shareCount", "commentCount", "extend", "deletedAt", "createdAt", "updatedAt"})

	return &WorkExtendExec{ret}
}

type WorkExtendsParams struct {
	Where   *WorkExtendWhereInput   `json:"where,omitempty"`
	OrderBy *WorkExtendOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) WorkExtends(params *WorkExtendsParams) *WorkExtendExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WorkExtendWhereInput", "WorkExtendOrderByInput", "WorkExtend"},
		"workExtends",
		[]string{"id", "workId", "appId", "focusCount", "likeCount", "shareCount", "commentCount", "extend", "deletedAt", "createdAt", "updatedAt"})

	return &WorkExtendExecArray{ret}
}

type WorkExtendsConnectionParams struct {
	Where   *WorkExtendWhereInput   `json:"where,omitempty"`
	OrderBy *WorkExtendOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) WorkExtendsConnection(params *WorkExtendsConnectionParams) *WorkExtendConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WorkExtendWhereInput", "WorkExtendOrderByInput", "WorkExtend"},
		"workExtendsConnection",
		[]string{"edges", "pageInfo"})

	return &WorkExtendConnectionExec{ret}
}

func (client *Client) WorkProgress(params WorkProgressWhereUniqueInput) *WorkProgressExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"WorkProgressWhereUniqueInput!", "WorkProgress"},
		"workProgress",
		[]string{"id", "appId", "participantId", "publisherId", "workId", "type", "extend", "createdAt", "updatedAt"})

	return &WorkProgressExec{ret}
}

type WorkProgressesParams struct {
	Where   *WorkProgressWhereInput   `json:"where,omitempty"`
	OrderBy *WorkProgressOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) WorkProgresses(params *WorkProgressesParams) *WorkProgressExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WorkProgressWhereInput", "WorkProgressOrderByInput", "WorkProgress"},
		"workProgresses",
		[]string{"id", "appId", "participantId", "publisherId", "workId", "type", "extend", "createdAt", "updatedAt"})

	return &WorkProgressExecArray{ret}
}

type WorkProgressesConnectionParams struct {
	Where   *WorkProgressWhereInput   `json:"where,omitempty"`
	OrderBy *WorkProgressOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) WorkProgressesConnection(params *WorkProgressesConnectionParams) *WorkProgressConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WorkProgresseWhereInput", "WorkProgresseOrderByInput", "WorkProgresse"},
		"workProgressesConnection",
		[]string{"edges", "pageInfo"})

	return &WorkProgressConnectionExec{ret}
}

func (client *Client) WorkTemplate(params WorkTemplateWhereUniqueInput) *WorkTemplateExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"WorkTemplateWhereUniqueInput!", "WorkTemplate"},
		"workTemplate",
		[]string{"id", "companyId", "userId", "workType", "data", "createdAt", "updatedAt", "deletedAt"})

	return &WorkTemplateExec{ret}
}

type WorkTemplatesParams struct {
	Where   *WorkTemplateWhereInput   `json:"where,omitempty"`
	OrderBy *WorkTemplateOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) WorkTemplates(params *WorkTemplatesParams) *WorkTemplateExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WorkTemplateWhereInput", "WorkTemplateOrderByInput", "WorkTemplate"},
		"workTemplates",
		[]string{"id", "companyId", "userId", "workType", "data", "createdAt", "updatedAt", "deletedAt"})

	return &WorkTemplateExecArray{ret}
}

type WorkTemplatesConnectionParams struct {
	Where   *WorkTemplateWhereInput   `json:"where,omitempty"`
	OrderBy *WorkTemplateOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) WorkTemplatesConnection(params *WorkTemplatesConnectionParams) *WorkTemplateConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WorkTemplateWhereInput", "WorkTemplateOrderByInput", "WorkTemplate"},
		"workTemplatesConnection",
		[]string{"edges", "pageInfo"})

	return &WorkTemplateConnectionExec{ret}
}

func (client *Client) CreateCommonlyUsedPersonnel(params CommonlyUsedPersonnelCreateInput) *CommonlyUsedPersonnelExec {
	ret := client.Client.Create(
		params,
		[2]string{"CommonlyUsedPersonnelCreateInput!", "CommonlyUsedPersonnel"},
		"createCommonlyUsedPersonnel",
		[]string{"id", "companyId", "appId", "userId", "name", "avatar", "cardNo", "mobile", "bankNo", "education", "address", "remark", "signingTime", "createdAt", "updatedAt", "deletedAt"})

	return &CommonlyUsedPersonnelExec{ret}
}

type CommonlyUsedPersonnelUpdateParams struct {
	Data  CommonlyUsedPersonnelUpdateInput      `json:"data"`
	Where CommonlyUsedPersonnelWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCommonlyUsedPersonnel(params CommonlyUsedPersonnelUpdateParams) *CommonlyUsedPersonnelExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CommonlyUsedPersonnelUpdateInput!", "CommonlyUsedPersonnelWhereUniqueInput!", "CommonlyUsedPersonnel"},
		"updateCommonlyUsedPersonnel",
		[]string{"id", "companyId", "appId", "userId", "name", "avatar", "cardNo", "mobile", "bankNo", "education", "address", "remark", "signingTime", "createdAt", "updatedAt", "deletedAt"})

	return &CommonlyUsedPersonnelExec{ret}
}

type CommonlyUsedPersonnelUpdateManyParams struct {
	Data  CommonlyUsedPersonnelUpdateManyMutationInput `json:"data"`
	Where *CommonlyUsedPersonnelWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCommonlyUsedPersonnels(params CommonlyUsedPersonnelUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CommonlyUsedPersonnelUpdateManyMutationInput!", "CommonlyUsedPersonnelWhereInput"},
		"updateManyCommonlyUsedPersonnels")
	return &BatchPayloadExec{exec}
}

type CommonlyUsedPersonnelUpsertParams struct {
	Where  CommonlyUsedPersonnelWhereUniqueInput `json:"where"`
	Create CommonlyUsedPersonnelCreateInput      `json:"create"`
	Update CommonlyUsedPersonnelUpdateInput      `json:"update"`
}

func (client *Client) UpsertCommonlyUsedPersonnel(params CommonlyUsedPersonnelUpsertParams) *CommonlyUsedPersonnelExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CommonlyUsedPersonnelWhereUniqueInput!", "CommonlyUsedPersonnelCreateInput!", "CommonlyUsedPersonnelUpdateInput!", "CommonlyUsedPersonnel"},
		"upsertCommonlyUsedPersonnel",
		[]string{"id", "companyId", "appId", "userId", "name", "avatar", "cardNo", "mobile", "bankNo", "education", "address", "remark", "signingTime", "createdAt", "updatedAt", "deletedAt"})

	return &CommonlyUsedPersonnelExec{ret}
}

func (client *Client) DeleteCommonlyUsedPersonnel(params CommonlyUsedPersonnelWhereUniqueInput) *CommonlyUsedPersonnelExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CommonlyUsedPersonnelWhereUniqueInput!", "CommonlyUsedPersonnel"},
		"deleteCommonlyUsedPersonnel",
		[]string{"id", "companyId", "appId", "userId", "name", "avatar", "cardNo", "mobile", "bankNo", "education", "address", "remark", "signingTime", "createdAt", "updatedAt", "deletedAt"})

	return &CommonlyUsedPersonnelExec{ret}
}

func (client *Client) DeleteManyCommonlyUsedPersonnels(params *CommonlyUsedPersonnelWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CommonlyUsedPersonnelWhereInput", "deleteManyCommonlyUsedPersonnels")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCompanyUserBlacklist(params CompanyUserBlacklistCreateInput) *CompanyUserBlacklistExec {
	ret := client.Client.Create(
		params,
		[2]string{"CompanyUserBlacklistCreateInput!", "CompanyUserBlacklist"},
		"createCompanyUserBlacklist",
		[]string{"id", "companyId", "participantId", "publisherId", "workId", "type", "createdAt", "updatedAt", "deletedAt"})

	return &CompanyUserBlacklistExec{ret}
}

type CompanyUserBlacklistUpdateParams struct {
	Data  CompanyUserBlacklistUpdateInput      `json:"data"`
	Where CompanyUserBlacklistWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCompanyUserBlacklist(params CompanyUserBlacklistUpdateParams) *CompanyUserBlacklistExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CompanyUserBlacklistUpdateInput!", "CompanyUserBlacklistWhereUniqueInput!", "CompanyUserBlacklist"},
		"updateCompanyUserBlacklist",
		[]string{"id", "companyId", "participantId", "publisherId", "workId", "type", "createdAt", "updatedAt", "deletedAt"})

	return &CompanyUserBlacklistExec{ret}
}

type CompanyUserBlacklistUpdateManyParams struct {
	Data  CompanyUserBlacklistUpdateManyMutationInput `json:"data"`
	Where *CompanyUserBlacklistWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCompanyUserBlacklists(params CompanyUserBlacklistUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CompanyUserBlacklistUpdateManyMutationInput!", "CompanyUserBlacklistWhereInput"},
		"updateManyCompanyUserBlacklists")
	return &BatchPayloadExec{exec}
}

type CompanyUserBlacklistUpsertParams struct {
	Where  CompanyUserBlacklistWhereUniqueInput `json:"where"`
	Create CompanyUserBlacklistCreateInput      `json:"create"`
	Update CompanyUserBlacklistUpdateInput      `json:"update"`
}

func (client *Client) UpsertCompanyUserBlacklist(params CompanyUserBlacklistUpsertParams) *CompanyUserBlacklistExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CompanyUserBlacklistWhereUniqueInput!", "CompanyUserBlacklistCreateInput!", "CompanyUserBlacklistUpdateInput!", "CompanyUserBlacklist"},
		"upsertCompanyUserBlacklist",
		[]string{"id", "companyId", "participantId", "publisherId", "workId", "type", "createdAt", "updatedAt", "deletedAt"})

	return &CompanyUserBlacklistExec{ret}
}

func (client *Client) DeleteCompanyUserBlacklist(params CompanyUserBlacklistWhereUniqueInput) *CompanyUserBlacklistExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CompanyUserBlacklistWhereUniqueInput!", "CompanyUserBlacklist"},
		"deleteCompanyUserBlacklist",
		[]string{"id", "companyId", "participantId", "publisherId", "workId", "type", "createdAt", "updatedAt", "deletedAt"})

	return &CompanyUserBlacklistExec{ret}
}

func (client *Client) DeleteManyCompanyUserBlacklists(params *CompanyUserBlacklistWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CompanyUserBlacklistWhereInput", "deleteManyCompanyUserBlacklists")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCompanyUserKpi(params CompanyUserKpiCreateInput) *CompanyUserKpiExec {
	ret := client.Client.Create(
		params,
		[2]string{"CompanyUserKpiCreateInput!", "CompanyUserKpi"},
		"createCompanyUserKpi",
		[]string{"id", "workId", "amount", "companyId", "participantId", "payAt", "publisherId", "isPaid", "kpiCoefficient", "extend", "createdAt", "updatedAt"})

	return &CompanyUserKpiExec{ret}
}

type CompanyUserKpiUpdateParams struct {
	Data  CompanyUserKpiUpdateInput      `json:"data"`
	Where CompanyUserKpiWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCompanyUserKpi(params CompanyUserKpiUpdateParams) *CompanyUserKpiExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CompanyUserKpiUpdateInput!", "CompanyUserKpiWhereUniqueInput!", "CompanyUserKpi"},
		"updateCompanyUserKpi",
		[]string{"id", "workId", "amount", "companyId", "participantId", "payAt", "publisherId", "isPaid", "kpiCoefficient", "extend", "createdAt", "updatedAt"})

	return &CompanyUserKpiExec{ret}
}

type CompanyUserKpiUpdateManyParams struct {
	Data  CompanyUserKpiUpdateManyMutationInput `json:"data"`
	Where *CompanyUserKpiWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCompanyUserKpis(params CompanyUserKpiUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CompanyUserKpiUpdateManyMutationInput!", "CompanyUserKpiWhereInput"},
		"updateManyCompanyUserKpis")
	return &BatchPayloadExec{exec}
}

type CompanyUserKpiUpsertParams struct {
	Where  CompanyUserKpiWhereUniqueInput `json:"where"`
	Create CompanyUserKpiCreateInput      `json:"create"`
	Update CompanyUserKpiUpdateInput      `json:"update"`
}

func (client *Client) UpsertCompanyUserKpi(params CompanyUserKpiUpsertParams) *CompanyUserKpiExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CompanyUserKpiWhereUniqueInput!", "CompanyUserKpiCreateInput!", "CompanyUserKpiUpdateInput!", "CompanyUserKpi"},
		"upsertCompanyUserKpi",
		[]string{"id", "workId", "amount", "companyId", "participantId", "payAt", "publisherId", "isPaid", "kpiCoefficient", "extend", "createdAt", "updatedAt"})

	return &CompanyUserKpiExec{ret}
}

func (client *Client) DeleteCompanyUserKpi(params CompanyUserKpiWhereUniqueInput) *CompanyUserKpiExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CompanyUserKpiWhereUniqueInput!", "CompanyUserKpi"},
		"deleteCompanyUserKpi",
		[]string{"id", "workId", "amount", "companyId", "participantId", "payAt", "publisherId", "isPaid", "kpiCoefficient", "extend", "createdAt", "updatedAt"})

	return &CompanyUserKpiExec{ret}
}

func (client *Client) DeleteManyCompanyUserKpis(params *CompanyUserKpiWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CompanyUserKpiWhereInput", "deleteManyCompanyUserKpis")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateImportLogs(params ImportLogsCreateInput) *ImportLogsExec {
	ret := client.Client.Create(
		params,
		[2]string{"ImportLogsCreateInput!", "ImportLogs"},
		"createImportLogs",
		[]string{"id", "fileHash", "name", "mobile", "cardNo", "status", "logContent", "createdAt", "updatedAt"})

	return &ImportLogsExec{ret}
}

type ImportLogsUpdateParams struct {
	Data  ImportLogsUpdateInput      `json:"data"`
	Where ImportLogsWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateImportLogs(params ImportLogsUpdateParams) *ImportLogsExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ImportLogsUpdateInput!", "ImportLogsWhereUniqueInput!", "ImportLogs"},
		"updateImportLogs",
		[]string{"id", "fileHash", "name", "mobile", "cardNo", "status", "logContent", "createdAt", "updatedAt"})

	return &ImportLogsExec{ret}
}

type ImportLogsUpdateManyParams struct {
	Data  ImportLogsUpdateManyMutationInput `json:"data"`
	Where *ImportLogsWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyImportLogses(params ImportLogsUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ImportLogsUpdateManyMutationInput!", "ImportLogsWhereInput"},
		"updateManyImportLogses")
	return &BatchPayloadExec{exec}
}

type ImportLogsUpsertParams struct {
	Where  ImportLogsWhereUniqueInput `json:"where"`
	Create ImportLogsCreateInput      `json:"create"`
	Update ImportLogsUpdateInput      `json:"update"`
}

func (client *Client) UpsertImportLogs(params ImportLogsUpsertParams) *ImportLogsExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ImportLogsWhereUniqueInput!", "ImportLogsCreateInput!", "ImportLogsUpdateInput!", "ImportLogs"},
		"upsertImportLogs",
		[]string{"id", "fileHash", "name", "mobile", "cardNo", "status", "logContent", "createdAt", "updatedAt"})

	return &ImportLogsExec{ret}
}

func (client *Client) DeleteImportLogs(params ImportLogsWhereUniqueInput) *ImportLogsExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ImportLogsWhereUniqueInput!", "ImportLogs"},
		"deleteImportLogs",
		[]string{"id", "fileHash", "name", "mobile", "cardNo", "status", "logContent", "createdAt", "updatedAt"})

	return &ImportLogsExec{ret}
}

func (client *Client) DeleteManyImportLogses(params *ImportLogsWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ImportLogsWhereInput", "deleteManyImportLogses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateJob(params JobCreateInput) *JobExec {
	ret := client.Client.Create(
		params,
		[2]string{"JobCreateInput!", "Job"},
		"createJob",
		[]string{"id", "workId", "category", "settlementRule", "payStatus", "progress", "quota", "singleRewardMax", "singleRewardMin", "isCanComment", "isNeedProof", "proofDescription", "proofType", "remark", "templateId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobExec{ret}
}

type JobUpdateParams struct {
	Data  JobUpdateInput      `json:"data"`
	Where JobWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateJob(params JobUpdateParams) *JobExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"JobUpdateInput!", "JobWhereUniqueInput!", "Job"},
		"updateJob",
		[]string{"id", "workId", "category", "settlementRule", "payStatus", "progress", "quota", "singleRewardMax", "singleRewardMin", "isCanComment", "isNeedProof", "proofDescription", "proofType", "remark", "templateId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobExec{ret}
}

type JobUpdateManyParams struct {
	Data  JobUpdateManyMutationInput `json:"data"`
	Where *JobWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyJobs(params JobUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"JobUpdateManyMutationInput!", "JobWhereInput"},
		"updateManyJobs")
	return &BatchPayloadExec{exec}
}

type JobUpsertParams struct {
	Where  JobWhereUniqueInput `json:"where"`
	Create JobCreateInput      `json:"create"`
	Update JobUpdateInput      `json:"update"`
}

func (client *Client) UpsertJob(params JobUpsertParams) *JobExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"JobWhereUniqueInput!", "JobCreateInput!", "JobUpdateInput!", "Job"},
		"upsertJob",
		[]string{"id", "workId", "category", "settlementRule", "payStatus", "progress", "quota", "singleRewardMax", "singleRewardMin", "isCanComment", "isNeedProof", "proofDescription", "proofType", "remark", "templateId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobExec{ret}
}

func (client *Client) DeleteJob(params JobWhereUniqueInput) *JobExec {
	ret := client.Client.Delete(
		params,
		[2]string{"JobWhereUniqueInput!", "Job"},
		"deleteJob",
		[]string{"id", "workId", "category", "settlementRule", "payStatus", "progress", "quota", "singleRewardMax", "singleRewardMin", "isCanComment", "isNeedProof", "proofDescription", "proofType", "remark", "templateId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobExec{ret}
}

func (client *Client) DeleteManyJobs(params *JobWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "JobWhereInput", "deleteManyJobs")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateJobAchievement(params JobAchievementCreateInput) *JobAchievementExec {
	ret := client.Client.Create(
		params,
		[2]string{"JobAchievementCreateInput!", "JobAchievement"},
		"createJobAchievement",
		[]string{"id", "jobId", "userId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobAchievementExec{ret}
}

type JobAchievementUpdateParams struct {
	Data  JobAchievementUpdateInput      `json:"data"`
	Where JobAchievementWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateJobAchievement(params JobAchievementUpdateParams) *JobAchievementExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"JobAchievementUpdateInput!", "JobAchievementWhereUniqueInput!", "JobAchievement"},
		"updateJobAchievement",
		[]string{"id", "jobId", "userId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobAchievementExec{ret}
}

type JobAchievementUpdateManyParams struct {
	Data  JobAchievementUpdateManyMutationInput `json:"data"`
	Where *JobAchievementWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyJobAchievements(params JobAchievementUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"JobAchievementUpdateManyMutationInput!", "JobAchievementWhereInput"},
		"updateManyJobAchievements")
	return &BatchPayloadExec{exec}
}

type JobAchievementUpsertParams struct {
	Where  JobAchievementWhereUniqueInput `json:"where"`
	Create JobAchievementCreateInput      `json:"create"`
	Update JobAchievementUpdateInput      `json:"update"`
}

func (client *Client) UpsertJobAchievement(params JobAchievementUpsertParams) *JobAchievementExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"JobAchievementWhereUniqueInput!", "JobAchievementCreateInput!", "JobAchievementUpdateInput!", "JobAchievement"},
		"upsertJobAchievement",
		[]string{"id", "jobId", "userId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobAchievementExec{ret}
}

func (client *Client) DeleteJobAchievement(params JobAchievementWhereUniqueInput) *JobAchievementExec {
	ret := client.Client.Delete(
		params,
		[2]string{"JobAchievementWhereUniqueInput!", "JobAchievement"},
		"deleteJobAchievement",
		[]string{"id", "jobId", "userId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobAchievementExec{ret}
}

func (client *Client) DeleteManyJobAchievements(params *JobAchievementWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "JobAchievementWhereInput", "deleteManyJobAchievements")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateJobContractJournal(params JobContractJournalCreateInput) *JobContractJournalExec {
	ret := client.Client.Create(
		params,
		[2]string{"JobContractJournalCreateInput!", "JobContractJournal"},
		"createJobContractJournal",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "activeTimestamp", "isHandled", "extend", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobContractJournalExec{ret}
}

type JobContractJournalUpdateParams struct {
	Data  JobContractJournalUpdateInput      `json:"data"`
	Where JobContractJournalWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateJobContractJournal(params JobContractJournalUpdateParams) *JobContractJournalExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"JobContractJournalUpdateInput!", "JobContractJournalWhereUniqueInput!", "JobContractJournal"},
		"updateJobContractJournal",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "activeTimestamp", "isHandled", "extend", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobContractJournalExec{ret}
}

type JobContractJournalUpdateManyParams struct {
	Data  JobContractJournalUpdateManyMutationInput `json:"data"`
	Where *JobContractJournalWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyJobContractJournals(params JobContractJournalUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"JobContractJournalUpdateManyMutationInput!", "JobContractJournalWhereInput"},
		"updateManyJobContractJournals")
	return &BatchPayloadExec{exec}
}

type JobContractJournalUpsertParams struct {
	Where  JobContractJournalWhereUniqueInput `json:"where"`
	Create JobContractJournalCreateInput      `json:"create"`
	Update JobContractJournalUpdateInput      `json:"update"`
}

func (client *Client) UpsertJobContractJournal(params JobContractJournalUpsertParams) *JobContractJournalExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"JobContractJournalWhereUniqueInput!", "JobContractJournalCreateInput!", "JobContractJournalUpdateInput!", "JobContractJournal"},
		"upsertJobContractJournal",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "activeTimestamp", "isHandled", "extend", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobContractJournalExec{ret}
}

func (client *Client) DeleteJobContractJournal(params JobContractJournalWhereUniqueInput) *JobContractJournalExec {
	ret := client.Client.Delete(
		params,
		[2]string{"JobContractJournalWhereUniqueInput!", "JobContractJournal"},
		"deleteJobContractJournal",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "activeTimestamp", "isHandled", "extend", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobContractJournalExec{ret}
}

func (client *Client) DeleteManyJobContractJournals(params *JobContractJournalWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "JobContractJournalWhereInput", "deleteManyJobContractJournals")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateJobMember(params JobMemberCreateInput) *JobMemberExec {
	ret := client.Client.Create(
		params,
		[2]string{"JobMemberCreateInput!", "JobMember"},
		"createJobMember",
		[]string{"id", "workId", "companyId", "publisherId", "participantId", "source", "progress", "proofFileUrl", "reward", "participateAt", "finishAt", "remark", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobMemberExec{ret}
}

type JobMemberUpdateParams struct {
	Data  JobMemberUpdateInput      `json:"data"`
	Where JobMemberWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateJobMember(params JobMemberUpdateParams) *JobMemberExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"JobMemberUpdateInput!", "JobMemberWhereUniqueInput!", "JobMember"},
		"updateJobMember",
		[]string{"id", "workId", "companyId", "publisherId", "participantId", "source", "progress", "proofFileUrl", "reward", "participateAt", "finishAt", "remark", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobMemberExec{ret}
}

type JobMemberUpdateManyParams struct {
	Data  JobMemberUpdateManyMutationInput `json:"data"`
	Where *JobMemberWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyJobMembers(params JobMemberUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"JobMemberUpdateManyMutationInput!", "JobMemberWhereInput"},
		"updateManyJobMembers")
	return &BatchPayloadExec{exec}
}

type JobMemberUpsertParams struct {
	Where  JobMemberWhereUniqueInput `json:"where"`
	Create JobMemberCreateInput      `json:"create"`
	Update JobMemberUpdateInput      `json:"update"`
}

func (client *Client) UpsertJobMember(params JobMemberUpsertParams) *JobMemberExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"JobMemberWhereUniqueInput!", "JobMemberCreateInput!", "JobMemberUpdateInput!", "JobMember"},
		"upsertJobMember",
		[]string{"id", "workId", "companyId", "publisherId", "participantId", "source", "progress", "proofFileUrl", "reward", "participateAt", "finishAt", "remark", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobMemberExec{ret}
}

func (client *Client) DeleteJobMember(params JobMemberWhereUniqueInput) *JobMemberExec {
	ret := client.Client.Delete(
		params,
		[2]string{"JobMemberWhereUniqueInput!", "JobMember"},
		"deleteJobMember",
		[]string{"id", "workId", "companyId", "publisherId", "participantId", "source", "progress", "proofFileUrl", "reward", "participateAt", "finishAt", "remark", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobMemberExec{ret}
}

func (client *Client) DeleteManyJobMembers(params *JobMemberWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "JobMemberWhereInput", "deleteManyJobMembers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateJobTemplate(params JobTemplateCreateInput) *JobTemplateExec {
	ret := client.Client.Create(
		params,
		[2]string{"JobTemplateCreateInput!", "JobTemplate"},
		"createJobTemplate",
		[]string{"id", "appId", "platformAppid", "companyId", "companyName", "serviceCompanyId", "serviceCompanyName", "userId", "workType", "signTemplateId", "serviceTypeId", "serviceTypeName", "name", "requirement", "settlementRule", "kpiTemplateUrl", "downloadCode", "displayName", "isEnable", "source", "extend", "bizContent", "remark", "contractNo", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateExec{ret}
}

type JobTemplateUpdateParams struct {
	Data  JobTemplateUpdateInput      `json:"data"`
	Where JobTemplateWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateJobTemplate(params JobTemplateUpdateParams) *JobTemplateExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"JobTemplateUpdateInput!", "JobTemplateWhereUniqueInput!", "JobTemplate"},
		"updateJobTemplate",
		[]string{"id", "appId", "platformAppid", "companyId", "companyName", "serviceCompanyId", "serviceCompanyName", "userId", "workType", "signTemplateId", "serviceTypeId", "serviceTypeName", "name", "requirement", "settlementRule", "kpiTemplateUrl", "downloadCode", "displayName", "isEnable", "source", "extend", "bizContent", "remark", "contractNo", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateExec{ret}
}

type JobTemplateUpdateManyParams struct {
	Data  JobTemplateUpdateManyMutationInput `json:"data"`
	Where *JobTemplateWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyJobTemplates(params JobTemplateUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"JobTemplateUpdateManyMutationInput!", "JobTemplateWhereInput"},
		"updateManyJobTemplates")
	return &BatchPayloadExec{exec}
}

type JobTemplateUpsertParams struct {
	Where  JobTemplateWhereUniqueInput `json:"where"`
	Create JobTemplateCreateInput      `json:"create"`
	Update JobTemplateUpdateInput      `json:"update"`
}

func (client *Client) UpsertJobTemplate(params JobTemplateUpsertParams) *JobTemplateExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"JobTemplateWhereUniqueInput!", "JobTemplateCreateInput!", "JobTemplateUpdateInput!", "JobTemplate"},
		"upsertJobTemplate",
		[]string{"id", "appId", "platformAppid", "companyId", "companyName", "serviceCompanyId", "serviceCompanyName", "userId", "workType", "signTemplateId", "serviceTypeId", "serviceTypeName", "name", "requirement", "settlementRule", "kpiTemplateUrl", "downloadCode", "displayName", "isEnable", "source", "extend", "bizContent", "remark", "contractNo", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateExec{ret}
}

func (client *Client) DeleteJobTemplate(params JobTemplateWhereUniqueInput) *JobTemplateExec {
	ret := client.Client.Delete(
		params,
		[2]string{"JobTemplateWhereUniqueInput!", "JobTemplate"},
		"deleteJobTemplate",
		[]string{"id", "appId", "platformAppid", "companyId", "companyName", "serviceCompanyId", "serviceCompanyName", "userId", "workType", "signTemplateId", "serviceTypeId", "serviceTypeName", "name", "requirement", "settlementRule", "kpiTemplateUrl", "downloadCode", "displayName", "isEnable", "source", "extend", "bizContent", "remark", "contractNo", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateExec{ret}
}

func (client *Client) DeleteManyJobTemplates(params *JobTemplateWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "JobTemplateWhereInput", "deleteManyJobTemplates")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateJobTemplateDelay(params JobTemplateDelayCreateInput) *JobTemplateDelayExec {
	ret := client.Client.Create(
		params,
		[2]string{"JobTemplateDelayCreateInput!", "JobTemplateDelay"},
		"createJobTemplateDelay",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "isNeedProcessBegin", "isNeedProcessEnd", "extend", "bizContent", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateDelayExec{ret}
}

type JobTemplateDelayUpdateParams struct {
	Data  JobTemplateDelayUpdateInput      `json:"data"`
	Where JobTemplateDelayWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateJobTemplateDelay(params JobTemplateDelayUpdateParams) *JobTemplateDelayExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"JobTemplateDelayUpdateInput!", "JobTemplateDelayWhereUniqueInput!", "JobTemplateDelay"},
		"updateJobTemplateDelay",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "isNeedProcessBegin", "isNeedProcessEnd", "extend", "bizContent", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateDelayExec{ret}
}

type JobTemplateDelayUpdateManyParams struct {
	Data  JobTemplateDelayUpdateManyMutationInput `json:"data"`
	Where *JobTemplateDelayWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyJobTemplateDelays(params JobTemplateDelayUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"JobTemplateDelayUpdateManyMutationInput!", "JobTemplateDelayWhereInput"},
		"updateManyJobTemplateDelays")
	return &BatchPayloadExec{exec}
}

type JobTemplateDelayUpsertParams struct {
	Where  JobTemplateDelayWhereUniqueInput `json:"where"`
	Create JobTemplateDelayCreateInput      `json:"create"`
	Update JobTemplateDelayUpdateInput      `json:"update"`
}

func (client *Client) UpsertJobTemplateDelay(params JobTemplateDelayUpsertParams) *JobTemplateDelayExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"JobTemplateDelayWhereUniqueInput!", "JobTemplateDelayCreateInput!", "JobTemplateDelayUpdateInput!", "JobTemplateDelay"},
		"upsertJobTemplateDelay",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "isNeedProcessBegin", "isNeedProcessEnd", "extend", "bizContent", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateDelayExec{ret}
}

func (client *Client) DeleteJobTemplateDelay(params JobTemplateDelayWhereUniqueInput) *JobTemplateDelayExec {
	ret := client.Client.Delete(
		params,
		[2]string{"JobTemplateDelayWhereUniqueInput!", "JobTemplateDelay"},
		"deleteJobTemplateDelay",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "isNeedProcessBegin", "isNeedProcessEnd", "extend", "bizContent", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateDelayExec{ret}
}

func (client *Client) DeleteManyJobTemplateDelays(params *JobTemplateDelayWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "JobTemplateDelayWhereInput", "deleteManyJobTemplateDelays")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateKpiUploadLog(params KpiUploadLogCreateInput) *KpiUploadLogExec {
	ret := client.Client.Create(
		params,
		[2]string{"KpiUploadLogCreateInput!", "KpiUploadLog"},
		"createKpiUploadLog",
		[]string{"id", "companyId", "fileName", "fileUrl", "hash", "createdAt", "updatedAt"})

	return &KpiUploadLogExec{ret}
}

type KpiUploadLogUpdateParams struct {
	Data  KpiUploadLogUpdateInput      `json:"data"`
	Where KpiUploadLogWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateKpiUploadLog(params KpiUploadLogUpdateParams) *KpiUploadLogExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"KpiUploadLogUpdateInput!", "KpiUploadLogWhereUniqueInput!", "KpiUploadLog"},
		"updateKpiUploadLog",
		[]string{"id", "companyId", "fileName", "fileUrl", "hash", "createdAt", "updatedAt"})

	return &KpiUploadLogExec{ret}
}

type KpiUploadLogUpdateManyParams struct {
	Data  KpiUploadLogUpdateManyMutationInput `json:"data"`
	Where *KpiUploadLogWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyKpiUploadLogs(params KpiUploadLogUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"KpiUploadLogUpdateManyMutationInput!", "KpiUploadLogWhereInput"},
		"updateManyKpiUploadLogs")
	return &BatchPayloadExec{exec}
}

type KpiUploadLogUpsertParams struct {
	Where  KpiUploadLogWhereUniqueInput `json:"where"`
	Create KpiUploadLogCreateInput      `json:"create"`
	Update KpiUploadLogUpdateInput      `json:"update"`
}

func (client *Client) UpsertKpiUploadLog(params KpiUploadLogUpsertParams) *KpiUploadLogExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"KpiUploadLogWhereUniqueInput!", "KpiUploadLogCreateInput!", "KpiUploadLogUpdateInput!", "KpiUploadLog"},
		"upsertKpiUploadLog",
		[]string{"id", "companyId", "fileName", "fileUrl", "hash", "createdAt", "updatedAt"})

	return &KpiUploadLogExec{ret}
}

func (client *Client) DeleteKpiUploadLog(params KpiUploadLogWhereUniqueInput) *KpiUploadLogExec {
	ret := client.Client.Delete(
		params,
		[2]string{"KpiUploadLogWhereUniqueInput!", "KpiUploadLog"},
		"deleteKpiUploadLog",
		[]string{"id", "companyId", "fileName", "fileUrl", "hash", "createdAt", "updatedAt"})

	return &KpiUploadLogExec{ret}
}

func (client *Client) DeleteManyKpiUploadLogs(params *KpiUploadLogWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "KpiUploadLogWhereInput", "deleteManyKpiUploadLogs")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUserWeChatAuthorize(params UserWeChatAuthorizeCreateInput) *UserWeChatAuthorizeExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserWeChatAuthorizeCreateInput!", "UserWeChatAuthorize"},
		"createUserWeChatAuthorize",
		[]string{"id", "userId", "mobile", "createdAt", "updatedAt", "deletedAt"})

	return &UserWeChatAuthorizeExec{ret}
}

type UserWeChatAuthorizeUpdateParams struct {
	Data  UserWeChatAuthorizeUpdateInput      `json:"data"`
	Where UserWeChatAuthorizeWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUserWeChatAuthorize(params UserWeChatAuthorizeUpdateParams) *UserWeChatAuthorizeExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserWeChatAuthorizeUpdateInput!", "UserWeChatAuthorizeWhereUniqueInput!", "UserWeChatAuthorize"},
		"updateUserWeChatAuthorize",
		[]string{"id", "userId", "mobile", "createdAt", "updatedAt", "deletedAt"})

	return &UserWeChatAuthorizeExec{ret}
}

type UserWeChatAuthorizeUpdateManyParams struct {
	Data  UserWeChatAuthorizeUpdateManyMutationInput `json:"data"`
	Where *UserWeChatAuthorizeWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUserWeChatAuthorizes(params UserWeChatAuthorizeUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserWeChatAuthorizeUpdateManyMutationInput!", "UserWeChatAuthorizeWhereInput"},
		"updateManyUserWeChatAuthorizes")
	return &BatchPayloadExec{exec}
}

type UserWeChatAuthorizeUpsertParams struct {
	Where  UserWeChatAuthorizeWhereUniqueInput `json:"where"`
	Create UserWeChatAuthorizeCreateInput      `json:"create"`
	Update UserWeChatAuthorizeUpdateInput      `json:"update"`
}

func (client *Client) UpsertUserWeChatAuthorize(params UserWeChatAuthorizeUpsertParams) *UserWeChatAuthorizeExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWeChatAuthorizeWhereUniqueInput!", "UserWeChatAuthorizeCreateInput!", "UserWeChatAuthorizeUpdateInput!", "UserWeChatAuthorize"},
		"upsertUserWeChatAuthorize",
		[]string{"id", "userId", "mobile", "createdAt", "updatedAt", "deletedAt"})

	return &UserWeChatAuthorizeExec{ret}
}

func (client *Client) DeleteUserWeChatAuthorize(params UserWeChatAuthorizeWhereUniqueInput) *UserWeChatAuthorizeExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWeChatAuthorizeWhereUniqueInput!", "UserWeChatAuthorize"},
		"deleteUserWeChatAuthorize",
		[]string{"id", "userId", "mobile", "createdAt", "updatedAt", "deletedAt"})

	return &UserWeChatAuthorizeExec{ret}
}

func (client *Client) DeleteManyUserWeChatAuthorizes(params *UserWeChatAuthorizeWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWeChatAuthorizeWhereInput", "deleteManyUserWeChatAuthorizes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateWork(params WorkCreateInput) *WorkExec {
	ret := client.Client.Create(
		params,
		[2]string{"WorkCreateInput!", "Work"},
		"createWork",
		[]string{"id", "appId", "companyId", "userId", "serviceTypeId", "workType", "name", "requirement", "payType", "duration", "endAt", "source", "status", "type", "isPublic", "mediaCoverUrl", "mediaUrls", "resume", "extend", "updatedAt", "createdAt", "deletedAt"})

	return &WorkExec{ret}
}

type WorkUpdateParams struct {
	Data  WorkUpdateInput      `json:"data"`
	Where WorkWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateWork(params WorkUpdateParams) *WorkExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"WorkUpdateInput!", "WorkWhereUniqueInput!", "Work"},
		"updateWork",
		[]string{"id", "appId", "companyId", "userId", "serviceTypeId", "workType", "name", "requirement", "payType", "duration", "endAt", "source", "status", "type", "isPublic", "mediaCoverUrl", "mediaUrls", "resume", "extend", "updatedAt", "createdAt", "deletedAt"})

	return &WorkExec{ret}
}

type WorkUpdateManyParams struct {
	Data  WorkUpdateManyMutationInput `json:"data"`
	Where *WorkWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyWorks(params WorkUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"WorkUpdateManyMutationInput!", "WorkWhereInput"},
		"updateManyWorks")
	return &BatchPayloadExec{exec}
}

type WorkUpsertParams struct {
	Where  WorkWhereUniqueInput `json:"where"`
	Create WorkCreateInput      `json:"create"`
	Update WorkUpdateInput      `json:"update"`
}

func (client *Client) UpsertWork(params WorkUpsertParams) *WorkExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"WorkWhereUniqueInput!", "WorkCreateInput!", "WorkUpdateInput!", "Work"},
		"upsertWork",
		[]string{"id", "appId", "companyId", "userId", "serviceTypeId", "workType", "name", "requirement", "payType", "duration", "endAt", "source", "status", "type", "isPublic", "mediaCoverUrl", "mediaUrls", "resume", "extend", "updatedAt", "createdAt", "deletedAt"})

	return &WorkExec{ret}
}

func (client *Client) DeleteWork(params WorkWhereUniqueInput) *WorkExec {
	ret := client.Client.Delete(
		params,
		[2]string{"WorkWhereUniqueInput!", "Work"},
		"deleteWork",
		[]string{"id", "appId", "companyId", "userId", "serviceTypeId", "workType", "name", "requirement", "payType", "duration", "endAt", "source", "status", "type", "isPublic", "mediaCoverUrl", "mediaUrls", "resume", "extend", "updatedAt", "createdAt", "deletedAt"})

	return &WorkExec{ret}
}

func (client *Client) DeleteManyWorks(params *WorkWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "WorkWhereInput", "deleteManyWorks")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateWorkExtend(params WorkExtendCreateInput) *WorkExtendExec {
	ret := client.Client.Create(
		params,
		[2]string{"WorkExtendCreateInput!", "WorkExtend"},
		"createWorkExtend",
		[]string{"id", "workId", "appId", "focusCount", "likeCount", "shareCount", "commentCount", "extend", "deletedAt", "createdAt", "updatedAt"})

	return &WorkExtendExec{ret}
}

type WorkExtendUpdateParams struct {
	Data  WorkExtendUpdateInput      `json:"data"`
	Where WorkExtendWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateWorkExtend(params WorkExtendUpdateParams) *WorkExtendExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"WorkExtendUpdateInput!", "WorkExtendWhereUniqueInput!", "WorkExtend"},
		"updateWorkExtend",
		[]string{"id", "workId", "appId", "focusCount", "likeCount", "shareCount", "commentCount", "extend", "deletedAt", "createdAt", "updatedAt"})

	return &WorkExtendExec{ret}
}

type WorkExtendUpdateManyParams struct {
	Data  WorkExtendUpdateManyMutationInput `json:"data"`
	Where *WorkExtendWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyWorkExtends(params WorkExtendUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"WorkExtendUpdateManyMutationInput!", "WorkExtendWhereInput"},
		"updateManyWorkExtends")
	return &BatchPayloadExec{exec}
}

type WorkExtendUpsertParams struct {
	Where  WorkExtendWhereUniqueInput `json:"where"`
	Create WorkExtendCreateInput      `json:"create"`
	Update WorkExtendUpdateInput      `json:"update"`
}

func (client *Client) UpsertWorkExtend(params WorkExtendUpsertParams) *WorkExtendExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"WorkExtendWhereUniqueInput!", "WorkExtendCreateInput!", "WorkExtendUpdateInput!", "WorkExtend"},
		"upsertWorkExtend",
		[]string{"id", "workId", "appId", "focusCount", "likeCount", "shareCount", "commentCount", "extend", "deletedAt", "createdAt", "updatedAt"})

	return &WorkExtendExec{ret}
}

func (client *Client) DeleteWorkExtend(params WorkExtendWhereUniqueInput) *WorkExtendExec {
	ret := client.Client.Delete(
		params,
		[2]string{"WorkExtendWhereUniqueInput!", "WorkExtend"},
		"deleteWorkExtend",
		[]string{"id", "workId", "appId", "focusCount", "likeCount", "shareCount", "commentCount", "extend", "deletedAt", "createdAt", "updatedAt"})

	return &WorkExtendExec{ret}
}

func (client *Client) DeleteManyWorkExtends(params *WorkExtendWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "WorkExtendWhereInput", "deleteManyWorkExtends")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateWorkProgress(params WorkProgressCreateInput) *WorkProgressExec {
	ret := client.Client.Create(
		params,
		[2]string{"WorkProgressCreateInput!", "WorkProgress"},
		"createWorkProgress",
		[]string{"id", "appId", "participantId", "publisherId", "workId", "type", "extend", "createdAt", "updatedAt"})

	return &WorkProgressExec{ret}
}

type WorkProgressUpdateParams struct {
	Data  WorkProgressUpdateInput      `json:"data"`
	Where WorkProgressWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateWorkProgress(params WorkProgressUpdateParams) *WorkProgressExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"WorkProgressUpdateInput!", "WorkProgressWhereUniqueInput!", "WorkProgress"},
		"updateWorkProgress",
		[]string{"id", "appId", "participantId", "publisherId", "workId", "type", "extend", "createdAt", "updatedAt"})

	return &WorkProgressExec{ret}
}

type WorkProgressUpdateManyParams struct {
	Data  WorkProgressUpdateManyMutationInput `json:"data"`
	Where *WorkProgressWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyWorkProgresses(params WorkProgressUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"WorkProgressUpdateManyMutationInput!", "WorkProgressWhereInput"},
		"updateManyWorkProgresses")
	return &BatchPayloadExec{exec}
}

type WorkProgressUpsertParams struct {
	Where  WorkProgressWhereUniqueInput `json:"where"`
	Create WorkProgressCreateInput      `json:"create"`
	Update WorkProgressUpdateInput      `json:"update"`
}

func (client *Client) UpsertWorkProgress(params WorkProgressUpsertParams) *WorkProgressExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"WorkProgressWhereUniqueInput!", "WorkProgressCreateInput!", "WorkProgressUpdateInput!", "WorkProgress"},
		"upsertWorkProgress",
		[]string{"id", "appId", "participantId", "publisherId", "workId", "type", "extend", "createdAt", "updatedAt"})

	return &WorkProgressExec{ret}
}

func (client *Client) DeleteWorkProgress(params WorkProgressWhereUniqueInput) *WorkProgressExec {
	ret := client.Client.Delete(
		params,
		[2]string{"WorkProgressWhereUniqueInput!", "WorkProgress"},
		"deleteWorkProgress",
		[]string{"id", "appId", "participantId", "publisherId", "workId", "type", "extend", "createdAt", "updatedAt"})

	return &WorkProgressExec{ret}
}

func (client *Client) DeleteManyWorkProgresses(params *WorkProgressWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "WorkProgressWhereInput", "deleteManyWorkProgresses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateWorkTemplate(params WorkTemplateCreateInput) *WorkTemplateExec {
	ret := client.Client.Create(
		params,
		[2]string{"WorkTemplateCreateInput!", "WorkTemplate"},
		"createWorkTemplate",
		[]string{"id", "companyId", "userId", "workType", "data", "createdAt", "updatedAt", "deletedAt"})

	return &WorkTemplateExec{ret}
}

type WorkTemplateUpdateParams struct {
	Data  WorkTemplateUpdateInput      `json:"data"`
	Where WorkTemplateWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateWorkTemplate(params WorkTemplateUpdateParams) *WorkTemplateExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"WorkTemplateUpdateInput!", "WorkTemplateWhereUniqueInput!", "WorkTemplate"},
		"updateWorkTemplate",
		[]string{"id", "companyId", "userId", "workType", "data", "createdAt", "updatedAt", "deletedAt"})

	return &WorkTemplateExec{ret}
}

type WorkTemplateUpdateManyParams struct {
	Data  WorkTemplateUpdateManyMutationInput `json:"data"`
	Where *WorkTemplateWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyWorkTemplates(params WorkTemplateUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"WorkTemplateUpdateManyMutationInput!", "WorkTemplateWhereInput"},
		"updateManyWorkTemplates")
	return &BatchPayloadExec{exec}
}

type WorkTemplateUpsertParams struct {
	Where  WorkTemplateWhereUniqueInput `json:"where"`
	Create WorkTemplateCreateInput      `json:"create"`
	Update WorkTemplateUpdateInput      `json:"update"`
}

func (client *Client) UpsertWorkTemplate(params WorkTemplateUpsertParams) *WorkTemplateExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"WorkTemplateWhereUniqueInput!", "WorkTemplateCreateInput!", "WorkTemplateUpdateInput!", "WorkTemplate"},
		"upsertWorkTemplate",
		[]string{"id", "companyId", "userId", "workType", "data", "createdAt", "updatedAt", "deletedAt"})

	return &WorkTemplateExec{ret}
}

func (client *Client) DeleteWorkTemplate(params WorkTemplateWhereUniqueInput) *WorkTemplateExec {
	ret := client.Client.Delete(
		params,
		[2]string{"WorkTemplateWhereUniqueInput!", "WorkTemplate"},
		"deleteWorkTemplate",
		[]string{"id", "companyId", "userId", "workType", "data", "createdAt", "updatedAt", "deletedAt"})

	return &WorkTemplateExec{ret}
}

func (client *Client) DeleteManyWorkTemplates(params *WorkTemplateWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "WorkTemplateWhereInput", "deleteManyWorkTemplates")
	return &BatchPayloadExec{exec}
}

type CommonlyUsedPersonnelOrderByInput string

const (
	CommonlyUsedPersonnelOrderByInputIDAsc           CommonlyUsedPersonnelOrderByInput = "id_ASC"
	CommonlyUsedPersonnelOrderByInputIDDesc          CommonlyUsedPersonnelOrderByInput = "id_DESC"
	CommonlyUsedPersonnelOrderByInputCompanyIdAsc    CommonlyUsedPersonnelOrderByInput = "companyId_ASC"
	CommonlyUsedPersonnelOrderByInputCompanyIdDesc   CommonlyUsedPersonnelOrderByInput = "companyId_DESC"
	CommonlyUsedPersonnelOrderByInputAppIdAsc        CommonlyUsedPersonnelOrderByInput = "appId_ASC"
	CommonlyUsedPersonnelOrderByInputAppIdDesc       CommonlyUsedPersonnelOrderByInput = "appId_DESC"
	CommonlyUsedPersonnelOrderByInputUserIdAsc       CommonlyUsedPersonnelOrderByInput = "userId_ASC"
	CommonlyUsedPersonnelOrderByInputUserIdDesc      CommonlyUsedPersonnelOrderByInput = "userId_DESC"
	CommonlyUsedPersonnelOrderByInputNameAsc         CommonlyUsedPersonnelOrderByInput = "name_ASC"
	CommonlyUsedPersonnelOrderByInputNameDesc        CommonlyUsedPersonnelOrderByInput = "name_DESC"
	CommonlyUsedPersonnelOrderByInputAvatarAsc       CommonlyUsedPersonnelOrderByInput = "avatar_ASC"
	CommonlyUsedPersonnelOrderByInputAvatarDesc      CommonlyUsedPersonnelOrderByInput = "avatar_DESC"
	CommonlyUsedPersonnelOrderByInputCardNoAsc       CommonlyUsedPersonnelOrderByInput = "cardNo_ASC"
	CommonlyUsedPersonnelOrderByInputCardNoDesc      CommonlyUsedPersonnelOrderByInput = "cardNo_DESC"
	CommonlyUsedPersonnelOrderByInputMobileAsc       CommonlyUsedPersonnelOrderByInput = "mobile_ASC"
	CommonlyUsedPersonnelOrderByInputMobileDesc      CommonlyUsedPersonnelOrderByInput = "mobile_DESC"
	CommonlyUsedPersonnelOrderByInputBankNoAsc       CommonlyUsedPersonnelOrderByInput = "bankNo_ASC"
	CommonlyUsedPersonnelOrderByInputBankNoDesc      CommonlyUsedPersonnelOrderByInput = "bankNo_DESC"
	CommonlyUsedPersonnelOrderByInputEducationAsc    CommonlyUsedPersonnelOrderByInput = "education_ASC"
	CommonlyUsedPersonnelOrderByInputEducationDesc   CommonlyUsedPersonnelOrderByInput = "education_DESC"
	CommonlyUsedPersonnelOrderByInputAddressAsc      CommonlyUsedPersonnelOrderByInput = "address_ASC"
	CommonlyUsedPersonnelOrderByInputAddressDesc     CommonlyUsedPersonnelOrderByInput = "address_DESC"
	CommonlyUsedPersonnelOrderByInputRemarkAsc       CommonlyUsedPersonnelOrderByInput = "remark_ASC"
	CommonlyUsedPersonnelOrderByInputRemarkDesc      CommonlyUsedPersonnelOrderByInput = "remark_DESC"
	CommonlyUsedPersonnelOrderByInputSigningTimeAsc  CommonlyUsedPersonnelOrderByInput = "signingTime_ASC"
	CommonlyUsedPersonnelOrderByInputSigningTimeDesc CommonlyUsedPersonnelOrderByInput = "signingTime_DESC"
	CommonlyUsedPersonnelOrderByInputCreatedAtAsc    CommonlyUsedPersonnelOrderByInput = "createdAt_ASC"
	CommonlyUsedPersonnelOrderByInputCreatedAtDesc   CommonlyUsedPersonnelOrderByInput = "createdAt_DESC"
	CommonlyUsedPersonnelOrderByInputUpdatedAtAsc    CommonlyUsedPersonnelOrderByInput = "updatedAt_ASC"
	CommonlyUsedPersonnelOrderByInputUpdatedAtDesc   CommonlyUsedPersonnelOrderByInput = "updatedAt_DESC"
	CommonlyUsedPersonnelOrderByInputDeletedAtAsc    CommonlyUsedPersonnelOrderByInput = "deletedAt_ASC"
	CommonlyUsedPersonnelOrderByInputDeletedAtDesc   CommonlyUsedPersonnelOrderByInput = "deletedAt_DESC"
)

type CompanyUserBlacklistOrderByInput string

const (
	CompanyUserBlacklistOrderByInputIDAsc             CompanyUserBlacklistOrderByInput = "id_ASC"
	CompanyUserBlacklistOrderByInputIDDesc            CompanyUserBlacklistOrderByInput = "id_DESC"
	CompanyUserBlacklistOrderByInputCompanyIdAsc      CompanyUserBlacklistOrderByInput = "companyId_ASC"
	CompanyUserBlacklistOrderByInputCompanyIdDesc     CompanyUserBlacklistOrderByInput = "companyId_DESC"
	CompanyUserBlacklistOrderByInputParticipantIdAsc  CompanyUserBlacklistOrderByInput = "participantId_ASC"
	CompanyUserBlacklistOrderByInputParticipantIdDesc CompanyUserBlacklistOrderByInput = "participantId_DESC"
	CompanyUserBlacklistOrderByInputPublisherIdAsc    CompanyUserBlacklistOrderByInput = "publisherId_ASC"
	CompanyUserBlacklistOrderByInputPublisherIdDesc   CompanyUserBlacklistOrderByInput = "publisherId_DESC"
	CompanyUserBlacklistOrderByInputWorkIdAsc         CompanyUserBlacklistOrderByInput = "workId_ASC"
	CompanyUserBlacklistOrderByInputWorkIdDesc        CompanyUserBlacklistOrderByInput = "workId_DESC"
	CompanyUserBlacklistOrderByInputTypeAsc           CompanyUserBlacklistOrderByInput = "type_ASC"
	CompanyUserBlacklistOrderByInputTypeDesc          CompanyUserBlacklistOrderByInput = "type_DESC"
	CompanyUserBlacklistOrderByInputCreatedAtAsc      CompanyUserBlacklistOrderByInput = "createdAt_ASC"
	CompanyUserBlacklistOrderByInputCreatedAtDesc     CompanyUserBlacklistOrderByInput = "createdAt_DESC"
	CompanyUserBlacklistOrderByInputUpdatedAtAsc      CompanyUserBlacklistOrderByInput = "updatedAt_ASC"
	CompanyUserBlacklistOrderByInputUpdatedAtDesc     CompanyUserBlacklistOrderByInput = "updatedAt_DESC"
	CompanyUserBlacklistOrderByInputDeletedAtAsc      CompanyUserBlacklistOrderByInput = "deletedAt_ASC"
	CompanyUserBlacklistOrderByInputDeletedAtDesc     CompanyUserBlacklistOrderByInput = "deletedAt_DESC"
)

type CompanyUserKpiOrderByInput string

const (
	CompanyUserKpiOrderByInputIDAsc              CompanyUserKpiOrderByInput = "id_ASC"
	CompanyUserKpiOrderByInputIDDesc             CompanyUserKpiOrderByInput = "id_DESC"
	CompanyUserKpiOrderByInputWorkIdAsc          CompanyUserKpiOrderByInput = "workId_ASC"
	CompanyUserKpiOrderByInputWorkIdDesc         CompanyUserKpiOrderByInput = "workId_DESC"
	CompanyUserKpiOrderByInputAmountAsc          CompanyUserKpiOrderByInput = "amount_ASC"
	CompanyUserKpiOrderByInputAmountDesc         CompanyUserKpiOrderByInput = "amount_DESC"
	CompanyUserKpiOrderByInputCompanyIdAsc       CompanyUserKpiOrderByInput = "companyId_ASC"
	CompanyUserKpiOrderByInputCompanyIdDesc      CompanyUserKpiOrderByInput = "companyId_DESC"
	CompanyUserKpiOrderByInputParticipantIdAsc   CompanyUserKpiOrderByInput = "participantId_ASC"
	CompanyUserKpiOrderByInputParticipantIdDesc  CompanyUserKpiOrderByInput = "participantId_DESC"
	CompanyUserKpiOrderByInputPayAtAsc           CompanyUserKpiOrderByInput = "payAt_ASC"
	CompanyUserKpiOrderByInputPayAtDesc          CompanyUserKpiOrderByInput = "payAt_DESC"
	CompanyUserKpiOrderByInputPublisherIdAsc     CompanyUserKpiOrderByInput = "publisherId_ASC"
	CompanyUserKpiOrderByInputPublisherIdDesc    CompanyUserKpiOrderByInput = "publisherId_DESC"
	CompanyUserKpiOrderByInputIsPaidAsc          CompanyUserKpiOrderByInput = "isPaid_ASC"
	CompanyUserKpiOrderByInputIsPaidDesc         CompanyUserKpiOrderByInput = "isPaid_DESC"
	CompanyUserKpiOrderByInputKpiCoefficientAsc  CompanyUserKpiOrderByInput = "kpiCoefficient_ASC"
	CompanyUserKpiOrderByInputKpiCoefficientDesc CompanyUserKpiOrderByInput = "kpiCoefficient_DESC"
	CompanyUserKpiOrderByInputExtendAsc          CompanyUserKpiOrderByInput = "extend_ASC"
	CompanyUserKpiOrderByInputExtendDesc         CompanyUserKpiOrderByInput = "extend_DESC"
	CompanyUserKpiOrderByInputCreatedAtAsc       CompanyUserKpiOrderByInput = "createdAt_ASC"
	CompanyUserKpiOrderByInputCreatedAtDesc      CompanyUserKpiOrderByInput = "createdAt_DESC"
	CompanyUserKpiOrderByInputUpdatedAtAsc       CompanyUserKpiOrderByInput = "updatedAt_ASC"
	CompanyUserKpiOrderByInputUpdatedAtDesc      CompanyUserKpiOrderByInput = "updatedAt_DESC"
)

type ImportLogsOrderByInput string

const (
	ImportLogsOrderByInputIDAsc          ImportLogsOrderByInput = "id_ASC"
	ImportLogsOrderByInputIDDesc         ImportLogsOrderByInput = "id_DESC"
	ImportLogsOrderByInputFileHashAsc    ImportLogsOrderByInput = "fileHash_ASC"
	ImportLogsOrderByInputFileHashDesc   ImportLogsOrderByInput = "fileHash_DESC"
	ImportLogsOrderByInputNameAsc        ImportLogsOrderByInput = "name_ASC"
	ImportLogsOrderByInputNameDesc       ImportLogsOrderByInput = "name_DESC"
	ImportLogsOrderByInputMobileAsc      ImportLogsOrderByInput = "mobile_ASC"
	ImportLogsOrderByInputMobileDesc     ImportLogsOrderByInput = "mobile_DESC"
	ImportLogsOrderByInputCardNoAsc      ImportLogsOrderByInput = "cardNo_ASC"
	ImportLogsOrderByInputCardNoDesc     ImportLogsOrderByInput = "cardNo_DESC"
	ImportLogsOrderByInputStatusAsc      ImportLogsOrderByInput = "status_ASC"
	ImportLogsOrderByInputStatusDesc     ImportLogsOrderByInput = "status_DESC"
	ImportLogsOrderByInputLogContentAsc  ImportLogsOrderByInput = "logContent_ASC"
	ImportLogsOrderByInputLogContentDesc ImportLogsOrderByInput = "logContent_DESC"
	ImportLogsOrderByInputCreatedAtAsc   ImportLogsOrderByInput = "createdAt_ASC"
	ImportLogsOrderByInputCreatedAtDesc  ImportLogsOrderByInput = "createdAt_DESC"
	ImportLogsOrderByInputUpdatedAtAsc   ImportLogsOrderByInput = "updatedAt_ASC"
	ImportLogsOrderByInputUpdatedAtDesc  ImportLogsOrderByInput = "updatedAt_DESC"
)

type JobOrderByInput string

const (
	JobOrderByInputIDAsc                JobOrderByInput = "id_ASC"
	JobOrderByInputIDDesc               JobOrderByInput = "id_DESC"
	JobOrderByInputWorkIdAsc            JobOrderByInput = "workId_ASC"
	JobOrderByInputWorkIdDesc           JobOrderByInput = "workId_DESC"
	JobOrderByInputCategoryAsc          JobOrderByInput = "category_ASC"
	JobOrderByInputCategoryDesc         JobOrderByInput = "category_DESC"
	JobOrderByInputSettlementRuleAsc    JobOrderByInput = "settlementRule_ASC"
	JobOrderByInputSettlementRuleDesc   JobOrderByInput = "settlementRule_DESC"
	JobOrderByInputPayStatusAsc         JobOrderByInput = "payStatus_ASC"
	JobOrderByInputPayStatusDesc        JobOrderByInput = "payStatus_DESC"
	JobOrderByInputProgressAsc          JobOrderByInput = "progress_ASC"
	JobOrderByInputProgressDesc         JobOrderByInput = "progress_DESC"
	JobOrderByInputQuotaAsc             JobOrderByInput = "quota_ASC"
	JobOrderByInputQuotaDesc            JobOrderByInput = "quota_DESC"
	JobOrderByInputSingleRewardMaxAsc   JobOrderByInput = "singleRewardMax_ASC"
	JobOrderByInputSingleRewardMaxDesc  JobOrderByInput = "singleRewardMax_DESC"
	JobOrderByInputSingleRewardMinAsc   JobOrderByInput = "singleRewardMin_ASC"
	JobOrderByInputSingleRewardMinDesc  JobOrderByInput = "singleRewardMin_DESC"
	JobOrderByInputIsCanCommentAsc      JobOrderByInput = "isCanComment_ASC"
	JobOrderByInputIsCanCommentDesc     JobOrderByInput = "isCanComment_DESC"
	JobOrderByInputIsNeedProofAsc       JobOrderByInput = "isNeedProof_ASC"
	JobOrderByInputIsNeedProofDesc      JobOrderByInput = "isNeedProof_DESC"
	JobOrderByInputProofDescriptionAsc  JobOrderByInput = "proofDescription_ASC"
	JobOrderByInputProofDescriptionDesc JobOrderByInput = "proofDescription_DESC"
	JobOrderByInputProofTypeAsc         JobOrderByInput = "proofType_ASC"
	JobOrderByInputProofTypeDesc        JobOrderByInput = "proofType_DESC"
	JobOrderByInputRemarkAsc            JobOrderByInput = "remark_ASC"
	JobOrderByInputRemarkDesc           JobOrderByInput = "remark_DESC"
	JobOrderByInputTemplateIdAsc        JobOrderByInput = "templateId_ASC"
	JobOrderByInputTemplateIdDesc       JobOrderByInput = "templateId_DESC"
	JobOrderByInputExtendAsc            JobOrderByInput = "extend_ASC"
	JobOrderByInputExtendDesc           JobOrderByInput = "extend_DESC"
	JobOrderByInputCreatedAtAsc         JobOrderByInput = "createdAt_ASC"
	JobOrderByInputCreatedAtDesc        JobOrderByInput = "createdAt_DESC"
	JobOrderByInputUpdatedAtAsc         JobOrderByInput = "updatedAt_ASC"
	JobOrderByInputUpdatedAtDesc        JobOrderByInput = "updatedAt_DESC"
	JobOrderByInputDeletedAtAsc         JobOrderByInput = "deletedAt_ASC"
	JobOrderByInputDeletedAtDesc        JobOrderByInput = "deletedAt_DESC"
)

type JobAchievementOrderByInput string

const (
	JobAchievementOrderByInputIDAsc         JobAchievementOrderByInput = "id_ASC"
	JobAchievementOrderByInputIDDesc        JobAchievementOrderByInput = "id_DESC"
	JobAchievementOrderByInputJobIdAsc      JobAchievementOrderByInput = "jobId_ASC"
	JobAchievementOrderByInputJobIdDesc     JobAchievementOrderByInput = "jobId_DESC"
	JobAchievementOrderByInputUserIdAsc     JobAchievementOrderByInput = "userId_ASC"
	JobAchievementOrderByInputUserIdDesc    JobAchievementOrderByInput = "userId_DESC"
	JobAchievementOrderByInputExtendAsc     JobAchievementOrderByInput = "extend_ASC"
	JobAchievementOrderByInputExtendDesc    JobAchievementOrderByInput = "extend_DESC"
	JobAchievementOrderByInputCreatedAtAsc  JobAchievementOrderByInput = "createdAt_ASC"
	JobAchievementOrderByInputCreatedAtDesc JobAchievementOrderByInput = "createdAt_DESC"
	JobAchievementOrderByInputUpdatedAtAsc  JobAchievementOrderByInput = "updatedAt_ASC"
	JobAchievementOrderByInputUpdatedAtDesc JobAchievementOrderByInput = "updatedAt_DESC"
	JobAchievementOrderByInputDeletedAtAsc  JobAchievementOrderByInput = "deletedAt_ASC"
	JobAchievementOrderByInputDeletedAtDesc JobAchievementOrderByInput = "deletedAt_DESC"
)

type JobContractJournalOrderByInput string

const (
	JobContractJournalOrderByInputIDAsc                JobContractJournalOrderByInput = "id_ASC"
	JobContractJournalOrderByInputIDDesc               JobContractJournalOrderByInput = "id_DESC"
	JobContractJournalOrderByInputContractNoAsc        JobContractJournalOrderByInput = "contractNo_ASC"
	JobContractJournalOrderByInputContractNoDesc       JobContractJournalOrderByInput = "contractNo_DESC"
	JobContractJournalOrderByInputCompanyIdAsc         JobContractJournalOrderByInput = "companyId_ASC"
	JobContractJournalOrderByInputCompanyIdDesc        JobContractJournalOrderByInput = "companyId_DESC"
	JobContractJournalOrderByInputServiceCompanyIdAsc  JobContractJournalOrderByInput = "serviceCompanyId_ASC"
	JobContractJournalOrderByInputServiceCompanyIdDesc JobContractJournalOrderByInput = "serviceCompanyId_DESC"
	JobContractJournalOrderByInputBeginTimestampAsc    JobContractJournalOrderByInput = "beginTimestamp_ASC"
	JobContractJournalOrderByInputBeginTimestampDesc   JobContractJournalOrderByInput = "beginTimestamp_DESC"
	JobContractJournalOrderByInputEndTimestampAsc      JobContractJournalOrderByInput = "endTimestamp_ASC"
	JobContractJournalOrderByInputEndTimestampDesc     JobContractJournalOrderByInput = "endTimestamp_DESC"
	JobContractJournalOrderByInputActiveTimestampAsc   JobContractJournalOrderByInput = "activeTimestamp_ASC"
	JobContractJournalOrderByInputActiveTimestampDesc  JobContractJournalOrderByInput = "activeTimestamp_DESC"
	JobContractJournalOrderByInputIsHandledAsc         JobContractJournalOrderByInput = "isHandled_ASC"
	JobContractJournalOrderByInputIsHandledDesc        JobContractJournalOrderByInput = "isHandled_DESC"
	JobContractJournalOrderByInputExtendAsc            JobContractJournalOrderByInput = "extend_ASC"
	JobContractJournalOrderByInputExtendDesc           JobContractJournalOrderByInput = "extend_DESC"
	JobContractJournalOrderByInputRemarkAsc            JobContractJournalOrderByInput = "remark_ASC"
	JobContractJournalOrderByInputRemarkDesc           JobContractJournalOrderByInput = "remark_DESC"
	JobContractJournalOrderByInputCreatedAtAsc         JobContractJournalOrderByInput = "createdAt_ASC"
	JobContractJournalOrderByInputCreatedAtDesc        JobContractJournalOrderByInput = "createdAt_DESC"
	JobContractJournalOrderByInputUpdatedAtAsc         JobContractJournalOrderByInput = "updatedAt_ASC"
	JobContractJournalOrderByInputUpdatedAtDesc        JobContractJournalOrderByInput = "updatedAt_DESC"
	JobContractJournalOrderByInputDeletedAtAsc         JobContractJournalOrderByInput = "deletedAt_ASC"
	JobContractJournalOrderByInputDeletedAtDesc        JobContractJournalOrderByInput = "deletedAt_DESC"
)

type JobMemberOrderByInput string

const (
	JobMemberOrderByInputIDAsc             JobMemberOrderByInput = "id_ASC"
	JobMemberOrderByInputIDDesc            JobMemberOrderByInput = "id_DESC"
	JobMemberOrderByInputWorkIdAsc         JobMemberOrderByInput = "workId_ASC"
	JobMemberOrderByInputWorkIdDesc        JobMemberOrderByInput = "workId_DESC"
	JobMemberOrderByInputCompanyIdAsc      JobMemberOrderByInput = "companyId_ASC"
	JobMemberOrderByInputCompanyIdDesc     JobMemberOrderByInput = "companyId_DESC"
	JobMemberOrderByInputPublisherIdAsc    JobMemberOrderByInput = "publisherId_ASC"
	JobMemberOrderByInputPublisherIdDesc   JobMemberOrderByInput = "publisherId_DESC"
	JobMemberOrderByInputParticipantIdAsc  JobMemberOrderByInput = "participantId_ASC"
	JobMemberOrderByInputParticipantIdDesc JobMemberOrderByInput = "participantId_DESC"
	JobMemberOrderByInputSourceAsc         JobMemberOrderByInput = "source_ASC"
	JobMemberOrderByInputSourceDesc        JobMemberOrderByInput = "source_DESC"
	JobMemberOrderByInputProgressAsc       JobMemberOrderByInput = "progress_ASC"
	JobMemberOrderByInputProgressDesc      JobMemberOrderByInput = "progress_DESC"
	JobMemberOrderByInputProofFileUrlAsc   JobMemberOrderByInput = "proofFileUrl_ASC"
	JobMemberOrderByInputProofFileUrlDesc  JobMemberOrderByInput = "proofFileUrl_DESC"
	JobMemberOrderByInputRewardAsc         JobMemberOrderByInput = "reward_ASC"
	JobMemberOrderByInputRewardDesc        JobMemberOrderByInput = "reward_DESC"
	JobMemberOrderByInputParticipateAtAsc  JobMemberOrderByInput = "participateAt_ASC"
	JobMemberOrderByInputParticipateAtDesc JobMemberOrderByInput = "participateAt_DESC"
	JobMemberOrderByInputFinishAtAsc       JobMemberOrderByInput = "finishAt_ASC"
	JobMemberOrderByInputFinishAtDesc      JobMemberOrderByInput = "finishAt_DESC"
	JobMemberOrderByInputRemarkAsc         JobMemberOrderByInput = "remark_ASC"
	JobMemberOrderByInputRemarkDesc        JobMemberOrderByInput = "remark_DESC"
	JobMemberOrderByInputExtendAsc         JobMemberOrderByInput = "extend_ASC"
	JobMemberOrderByInputExtendDesc        JobMemberOrderByInput = "extend_DESC"
	JobMemberOrderByInputCreatedAtAsc      JobMemberOrderByInput = "createdAt_ASC"
	JobMemberOrderByInputCreatedAtDesc     JobMemberOrderByInput = "createdAt_DESC"
	JobMemberOrderByInputUpdatedAtAsc      JobMemberOrderByInput = "updatedAt_ASC"
	JobMemberOrderByInputUpdatedAtDesc     JobMemberOrderByInput = "updatedAt_DESC"
	JobMemberOrderByInputDeletedAtAsc      JobMemberOrderByInput = "deletedAt_ASC"
	JobMemberOrderByInputDeletedAtDesc     JobMemberOrderByInput = "deletedAt_DESC"
)

type JobTemplateOrderByInput string

const (
	JobTemplateOrderByInputIDAsc                  JobTemplateOrderByInput = "id_ASC"
	JobTemplateOrderByInputIDDesc                 JobTemplateOrderByInput = "id_DESC"
	JobTemplateOrderByInputAppIdAsc               JobTemplateOrderByInput = "appId_ASC"
	JobTemplateOrderByInputAppIdDesc              JobTemplateOrderByInput = "appId_DESC"
	JobTemplateOrderByInputPlatformAppidAsc       JobTemplateOrderByInput = "platformAppid_ASC"
	JobTemplateOrderByInputPlatformAppidDesc      JobTemplateOrderByInput = "platformAppid_DESC"
	JobTemplateOrderByInputCompanyIdAsc           JobTemplateOrderByInput = "companyId_ASC"
	JobTemplateOrderByInputCompanyIdDesc          JobTemplateOrderByInput = "companyId_DESC"
	JobTemplateOrderByInputCompanyNameAsc         JobTemplateOrderByInput = "companyName_ASC"
	JobTemplateOrderByInputCompanyNameDesc        JobTemplateOrderByInput = "companyName_DESC"
	JobTemplateOrderByInputServiceCompanyIdAsc    JobTemplateOrderByInput = "serviceCompanyId_ASC"
	JobTemplateOrderByInputServiceCompanyIdDesc   JobTemplateOrderByInput = "serviceCompanyId_DESC"
	JobTemplateOrderByInputServiceCompanyNameAsc  JobTemplateOrderByInput = "serviceCompanyName_ASC"
	JobTemplateOrderByInputServiceCompanyNameDesc JobTemplateOrderByInput = "serviceCompanyName_DESC"
	JobTemplateOrderByInputUserIdAsc              JobTemplateOrderByInput = "userId_ASC"
	JobTemplateOrderByInputUserIdDesc             JobTemplateOrderByInput = "userId_DESC"
	JobTemplateOrderByInputWorkTypeAsc            JobTemplateOrderByInput = "workType_ASC"
	JobTemplateOrderByInputWorkTypeDesc           JobTemplateOrderByInput = "workType_DESC"
	JobTemplateOrderByInputSignTemplateIdAsc      JobTemplateOrderByInput = "signTemplateId_ASC"
	JobTemplateOrderByInputSignTemplateIdDesc     JobTemplateOrderByInput = "signTemplateId_DESC"
	JobTemplateOrderByInputServiceTypeIdAsc       JobTemplateOrderByInput = "serviceTypeId_ASC"
	JobTemplateOrderByInputServiceTypeIdDesc      JobTemplateOrderByInput = "serviceTypeId_DESC"
	JobTemplateOrderByInputServiceTypeNameAsc     JobTemplateOrderByInput = "serviceTypeName_ASC"
	JobTemplateOrderByInputServiceTypeNameDesc    JobTemplateOrderByInput = "serviceTypeName_DESC"
	JobTemplateOrderByInputNameAsc                JobTemplateOrderByInput = "name_ASC"
	JobTemplateOrderByInputNameDesc               JobTemplateOrderByInput = "name_DESC"
	JobTemplateOrderByInputRequirementAsc         JobTemplateOrderByInput = "requirement_ASC"
	JobTemplateOrderByInputRequirementDesc        JobTemplateOrderByInput = "requirement_DESC"
	JobTemplateOrderByInputSettlementRuleAsc      JobTemplateOrderByInput = "settlementRule_ASC"
	JobTemplateOrderByInputSettlementRuleDesc     JobTemplateOrderByInput = "settlementRule_DESC"
	JobTemplateOrderByInputKpiTemplateUrlAsc      JobTemplateOrderByInput = "kpiTemplateUrl_ASC"
	JobTemplateOrderByInputKpiTemplateUrlDesc     JobTemplateOrderByInput = "kpiTemplateUrl_DESC"
	JobTemplateOrderByInputDownloadCodeAsc        JobTemplateOrderByInput = "downloadCode_ASC"
	JobTemplateOrderByInputDownloadCodeDesc       JobTemplateOrderByInput = "downloadCode_DESC"
	JobTemplateOrderByInputDisplayNameAsc         JobTemplateOrderByInput = "displayName_ASC"
	JobTemplateOrderByInputDisplayNameDesc        JobTemplateOrderByInput = "displayName_DESC"
	JobTemplateOrderByInputIsEnableAsc            JobTemplateOrderByInput = "isEnable_ASC"
	JobTemplateOrderByInputIsEnableDesc           JobTemplateOrderByInput = "isEnable_DESC"
	JobTemplateOrderByInputSourceAsc              JobTemplateOrderByInput = "source_ASC"
	JobTemplateOrderByInputSourceDesc             JobTemplateOrderByInput = "source_DESC"
	JobTemplateOrderByInputExtendAsc              JobTemplateOrderByInput = "extend_ASC"
	JobTemplateOrderByInputExtendDesc             JobTemplateOrderByInput = "extend_DESC"
	JobTemplateOrderByInputBizContentAsc          JobTemplateOrderByInput = "bizContent_ASC"
	JobTemplateOrderByInputBizContentDesc         JobTemplateOrderByInput = "bizContent_DESC"
	JobTemplateOrderByInputRemarkAsc              JobTemplateOrderByInput = "remark_ASC"
	JobTemplateOrderByInputRemarkDesc             JobTemplateOrderByInput = "remark_DESC"
	JobTemplateOrderByInputContractNoAsc          JobTemplateOrderByInput = "contractNo_ASC"
	JobTemplateOrderByInputContractNoDesc         JobTemplateOrderByInput = "contractNo_DESC"
	JobTemplateOrderByInputCreatedAtAsc           JobTemplateOrderByInput = "createdAt_ASC"
	JobTemplateOrderByInputCreatedAtDesc          JobTemplateOrderByInput = "createdAt_DESC"
	JobTemplateOrderByInputUpdatedAtAsc           JobTemplateOrderByInput = "updatedAt_ASC"
	JobTemplateOrderByInputUpdatedAtDesc          JobTemplateOrderByInput = "updatedAt_DESC"
	JobTemplateOrderByInputDeletedAtAsc           JobTemplateOrderByInput = "deletedAt_ASC"
	JobTemplateOrderByInputDeletedAtDesc          JobTemplateOrderByInput = "deletedAt_DESC"
)

type JobTemplateDelayOrderByInput string

const (
	JobTemplateDelayOrderByInputIDAsc                  JobTemplateDelayOrderByInput = "id_ASC"
	JobTemplateDelayOrderByInputIDDesc                 JobTemplateDelayOrderByInput = "id_DESC"
	JobTemplateDelayOrderByInputContractNoAsc          JobTemplateDelayOrderByInput = "contractNo_ASC"
	JobTemplateDelayOrderByInputContractNoDesc         JobTemplateDelayOrderByInput = "contractNo_DESC"
	JobTemplateDelayOrderByInputCompanyIdAsc           JobTemplateDelayOrderByInput = "companyId_ASC"
	JobTemplateDelayOrderByInputCompanyIdDesc          JobTemplateDelayOrderByInput = "companyId_DESC"
	JobTemplateDelayOrderByInputServiceCompanyIdAsc    JobTemplateDelayOrderByInput = "serviceCompanyId_ASC"
	JobTemplateDelayOrderByInputServiceCompanyIdDesc   JobTemplateDelayOrderByInput = "serviceCompanyId_DESC"
	JobTemplateDelayOrderByInputBeginTimestampAsc      JobTemplateDelayOrderByInput = "beginTimestamp_ASC"
	JobTemplateDelayOrderByInputBeginTimestampDesc     JobTemplateDelayOrderByInput = "beginTimestamp_DESC"
	JobTemplateDelayOrderByInputEndTimestampAsc        JobTemplateDelayOrderByInput = "endTimestamp_ASC"
	JobTemplateDelayOrderByInputEndTimestampDesc       JobTemplateDelayOrderByInput = "endTimestamp_DESC"
	JobTemplateDelayOrderByInputIsNeedProcessBeginAsc  JobTemplateDelayOrderByInput = "isNeedProcessBegin_ASC"
	JobTemplateDelayOrderByInputIsNeedProcessBeginDesc JobTemplateDelayOrderByInput = "isNeedProcessBegin_DESC"
	JobTemplateDelayOrderByInputIsNeedProcessEndAsc    JobTemplateDelayOrderByInput = "isNeedProcessEnd_ASC"
	JobTemplateDelayOrderByInputIsNeedProcessEndDesc   JobTemplateDelayOrderByInput = "isNeedProcessEnd_DESC"
	JobTemplateDelayOrderByInputExtendAsc              JobTemplateDelayOrderByInput = "extend_ASC"
	JobTemplateDelayOrderByInputExtendDesc             JobTemplateDelayOrderByInput = "extend_DESC"
	JobTemplateDelayOrderByInputBizContentAsc          JobTemplateDelayOrderByInput = "bizContent_ASC"
	JobTemplateDelayOrderByInputBizContentDesc         JobTemplateDelayOrderByInput = "bizContent_DESC"
	JobTemplateDelayOrderByInputRemarkAsc              JobTemplateDelayOrderByInput = "remark_ASC"
	JobTemplateDelayOrderByInputRemarkDesc             JobTemplateDelayOrderByInput = "remark_DESC"
	JobTemplateDelayOrderByInputCreatedAtAsc           JobTemplateDelayOrderByInput = "createdAt_ASC"
	JobTemplateDelayOrderByInputCreatedAtDesc          JobTemplateDelayOrderByInput = "createdAt_DESC"
	JobTemplateDelayOrderByInputUpdatedAtAsc           JobTemplateDelayOrderByInput = "updatedAt_ASC"
	JobTemplateDelayOrderByInputUpdatedAtDesc          JobTemplateDelayOrderByInput = "updatedAt_DESC"
	JobTemplateDelayOrderByInputDeletedAtAsc           JobTemplateDelayOrderByInput = "deletedAt_ASC"
	JobTemplateDelayOrderByInputDeletedAtDesc          JobTemplateDelayOrderByInput = "deletedAt_DESC"
)

type KpiUploadLogOrderByInput string

const (
	KpiUploadLogOrderByInputIDAsc         KpiUploadLogOrderByInput = "id_ASC"
	KpiUploadLogOrderByInputIDDesc        KpiUploadLogOrderByInput = "id_DESC"
	KpiUploadLogOrderByInputCompanyIdAsc  KpiUploadLogOrderByInput = "companyId_ASC"
	KpiUploadLogOrderByInputCompanyIdDesc KpiUploadLogOrderByInput = "companyId_DESC"
	KpiUploadLogOrderByInputFileNameAsc   KpiUploadLogOrderByInput = "fileName_ASC"
	KpiUploadLogOrderByInputFileNameDesc  KpiUploadLogOrderByInput = "fileName_DESC"
	KpiUploadLogOrderByInputFileUrlAsc    KpiUploadLogOrderByInput = "fileUrl_ASC"
	KpiUploadLogOrderByInputFileUrlDesc   KpiUploadLogOrderByInput = "fileUrl_DESC"
	KpiUploadLogOrderByInputHashAsc       KpiUploadLogOrderByInput = "hash_ASC"
	KpiUploadLogOrderByInputHashDesc      KpiUploadLogOrderByInput = "hash_DESC"
	KpiUploadLogOrderByInputCreatedAtAsc  KpiUploadLogOrderByInput = "createdAt_ASC"
	KpiUploadLogOrderByInputCreatedAtDesc KpiUploadLogOrderByInput = "createdAt_DESC"
	KpiUploadLogOrderByInputUpdatedAtAsc  KpiUploadLogOrderByInput = "updatedAt_ASC"
	KpiUploadLogOrderByInputUpdatedAtDesc KpiUploadLogOrderByInput = "updatedAt_DESC"
)

type UserWeChatAuthorizeOrderByInput string

const (
	UserWeChatAuthorizeOrderByInputIDAsc         UserWeChatAuthorizeOrderByInput = "id_ASC"
	UserWeChatAuthorizeOrderByInputIDDesc        UserWeChatAuthorizeOrderByInput = "id_DESC"
	UserWeChatAuthorizeOrderByInputUserIdAsc     UserWeChatAuthorizeOrderByInput = "userId_ASC"
	UserWeChatAuthorizeOrderByInputUserIdDesc    UserWeChatAuthorizeOrderByInput = "userId_DESC"
	UserWeChatAuthorizeOrderByInputMobileAsc     UserWeChatAuthorizeOrderByInput = "mobile_ASC"
	UserWeChatAuthorizeOrderByInputMobileDesc    UserWeChatAuthorizeOrderByInput = "mobile_DESC"
	UserWeChatAuthorizeOrderByInputCreatedAtAsc  UserWeChatAuthorizeOrderByInput = "createdAt_ASC"
	UserWeChatAuthorizeOrderByInputCreatedAtDesc UserWeChatAuthorizeOrderByInput = "createdAt_DESC"
	UserWeChatAuthorizeOrderByInputUpdatedAtAsc  UserWeChatAuthorizeOrderByInput = "updatedAt_ASC"
	UserWeChatAuthorizeOrderByInputUpdatedAtDesc UserWeChatAuthorizeOrderByInput = "updatedAt_DESC"
	UserWeChatAuthorizeOrderByInputDeletedAtAsc  UserWeChatAuthorizeOrderByInput = "deletedAt_ASC"
	UserWeChatAuthorizeOrderByInputDeletedAtDesc UserWeChatAuthorizeOrderByInput = "deletedAt_DESC"
)

type WorkOrderByInput string

const (
	WorkOrderByInputIDAsc             WorkOrderByInput = "id_ASC"
	WorkOrderByInputIDDesc            WorkOrderByInput = "id_DESC"
	WorkOrderByInputAppIdAsc          WorkOrderByInput = "appId_ASC"
	WorkOrderByInputAppIdDesc         WorkOrderByInput = "appId_DESC"
	WorkOrderByInputCompanyIdAsc      WorkOrderByInput = "companyId_ASC"
	WorkOrderByInputCompanyIdDesc     WorkOrderByInput = "companyId_DESC"
	WorkOrderByInputUserIdAsc         WorkOrderByInput = "userId_ASC"
	WorkOrderByInputUserIdDesc        WorkOrderByInput = "userId_DESC"
	WorkOrderByInputServiceTypeIdAsc  WorkOrderByInput = "serviceTypeId_ASC"
	WorkOrderByInputServiceTypeIdDesc WorkOrderByInput = "serviceTypeId_DESC"
	WorkOrderByInputWorkTypeAsc       WorkOrderByInput = "workType_ASC"
	WorkOrderByInputWorkTypeDesc      WorkOrderByInput = "workType_DESC"
	WorkOrderByInputNameAsc           WorkOrderByInput = "name_ASC"
	WorkOrderByInputNameDesc          WorkOrderByInput = "name_DESC"
	WorkOrderByInputRequirementAsc    WorkOrderByInput = "requirement_ASC"
	WorkOrderByInputRequirementDesc   WorkOrderByInput = "requirement_DESC"
	WorkOrderByInputPayTypeAsc        WorkOrderByInput = "payType_ASC"
	WorkOrderByInputPayTypeDesc       WorkOrderByInput = "payType_DESC"
	WorkOrderByInputDurationAsc       WorkOrderByInput = "duration_ASC"
	WorkOrderByInputDurationDesc      WorkOrderByInput = "duration_DESC"
	WorkOrderByInputEndAtAsc          WorkOrderByInput = "endAt_ASC"
	WorkOrderByInputEndAtDesc         WorkOrderByInput = "endAt_DESC"
	WorkOrderByInputSourceAsc         WorkOrderByInput = "source_ASC"
	WorkOrderByInputSourceDesc        WorkOrderByInput = "source_DESC"
	WorkOrderByInputStatusAsc         WorkOrderByInput = "status_ASC"
	WorkOrderByInputStatusDesc        WorkOrderByInput = "status_DESC"
	WorkOrderByInputTypeAsc           WorkOrderByInput = "type_ASC"
	WorkOrderByInputTypeDesc          WorkOrderByInput = "type_DESC"
	WorkOrderByInputIsPublicAsc       WorkOrderByInput = "isPublic_ASC"
	WorkOrderByInputIsPublicDesc      WorkOrderByInput = "isPublic_DESC"
	WorkOrderByInputMediaCoverUrlAsc  WorkOrderByInput = "mediaCoverUrl_ASC"
	WorkOrderByInputMediaCoverUrlDesc WorkOrderByInput = "mediaCoverUrl_DESC"
	WorkOrderByInputMediaUrlsAsc      WorkOrderByInput = "mediaUrls_ASC"
	WorkOrderByInputMediaUrlsDesc     WorkOrderByInput = "mediaUrls_DESC"
	WorkOrderByInputResumeAsc         WorkOrderByInput = "resume_ASC"
	WorkOrderByInputResumeDesc        WorkOrderByInput = "resume_DESC"
	WorkOrderByInputExtendAsc         WorkOrderByInput = "extend_ASC"
	WorkOrderByInputExtendDesc        WorkOrderByInput = "extend_DESC"
	WorkOrderByInputUpdatedAtAsc      WorkOrderByInput = "updatedAt_ASC"
	WorkOrderByInputUpdatedAtDesc     WorkOrderByInput = "updatedAt_DESC"
	WorkOrderByInputCreatedAtAsc      WorkOrderByInput = "createdAt_ASC"
	WorkOrderByInputCreatedAtDesc     WorkOrderByInput = "createdAt_DESC"
	WorkOrderByInputDeletedAtAsc      WorkOrderByInput = "deletedAt_ASC"
	WorkOrderByInputDeletedAtDesc     WorkOrderByInput = "deletedAt_DESC"
)

type WorkExtendOrderByInput string

const (
	WorkExtendOrderByInputIDAsc            WorkExtendOrderByInput = "id_ASC"
	WorkExtendOrderByInputIDDesc           WorkExtendOrderByInput = "id_DESC"
	WorkExtendOrderByInputWorkIdAsc        WorkExtendOrderByInput = "workId_ASC"
	WorkExtendOrderByInputWorkIdDesc       WorkExtendOrderByInput = "workId_DESC"
	WorkExtendOrderByInputAppIdAsc         WorkExtendOrderByInput = "appId_ASC"
	WorkExtendOrderByInputAppIdDesc        WorkExtendOrderByInput = "appId_DESC"
	WorkExtendOrderByInputFocusCountAsc    WorkExtendOrderByInput = "focusCount_ASC"
	WorkExtendOrderByInputFocusCountDesc   WorkExtendOrderByInput = "focusCount_DESC"
	WorkExtendOrderByInputLikeCountAsc     WorkExtendOrderByInput = "likeCount_ASC"
	WorkExtendOrderByInputLikeCountDesc    WorkExtendOrderByInput = "likeCount_DESC"
	WorkExtendOrderByInputShareCountAsc    WorkExtendOrderByInput = "shareCount_ASC"
	WorkExtendOrderByInputShareCountDesc   WorkExtendOrderByInput = "shareCount_DESC"
	WorkExtendOrderByInputCommentCountAsc  WorkExtendOrderByInput = "commentCount_ASC"
	WorkExtendOrderByInputCommentCountDesc WorkExtendOrderByInput = "commentCount_DESC"
	WorkExtendOrderByInputExtendAsc        WorkExtendOrderByInput = "extend_ASC"
	WorkExtendOrderByInputExtendDesc       WorkExtendOrderByInput = "extend_DESC"
	WorkExtendOrderByInputDeletedAtAsc     WorkExtendOrderByInput = "deletedAt_ASC"
	WorkExtendOrderByInputDeletedAtDesc    WorkExtendOrderByInput = "deletedAt_DESC"
	WorkExtendOrderByInputCreatedAtAsc     WorkExtendOrderByInput = "createdAt_ASC"
	WorkExtendOrderByInputCreatedAtDesc    WorkExtendOrderByInput = "createdAt_DESC"
	WorkExtendOrderByInputUpdatedAtAsc     WorkExtendOrderByInput = "updatedAt_ASC"
	WorkExtendOrderByInputUpdatedAtDesc    WorkExtendOrderByInput = "updatedAt_DESC"
)

type WorkProgressOrderByInput string

const (
	WorkProgressOrderByInputIDAsc             WorkProgressOrderByInput = "id_ASC"
	WorkProgressOrderByInputIDDesc            WorkProgressOrderByInput = "id_DESC"
	WorkProgressOrderByInputAppIdAsc          WorkProgressOrderByInput = "appId_ASC"
	WorkProgressOrderByInputAppIdDesc         WorkProgressOrderByInput = "appId_DESC"
	WorkProgressOrderByInputParticipantIdAsc  WorkProgressOrderByInput = "participantId_ASC"
	WorkProgressOrderByInputParticipantIdDesc WorkProgressOrderByInput = "participantId_DESC"
	WorkProgressOrderByInputPublisherIdAsc    WorkProgressOrderByInput = "publisherId_ASC"
	WorkProgressOrderByInputPublisherIdDesc   WorkProgressOrderByInput = "publisherId_DESC"
	WorkProgressOrderByInputWorkIdAsc         WorkProgressOrderByInput = "workId_ASC"
	WorkProgressOrderByInputWorkIdDesc        WorkProgressOrderByInput = "workId_DESC"
	WorkProgressOrderByInputTypeAsc           WorkProgressOrderByInput = "type_ASC"
	WorkProgressOrderByInputTypeDesc          WorkProgressOrderByInput = "type_DESC"
	WorkProgressOrderByInputExtendAsc         WorkProgressOrderByInput = "extend_ASC"
	WorkProgressOrderByInputExtendDesc        WorkProgressOrderByInput = "extend_DESC"
	WorkProgressOrderByInputCreatedAtAsc      WorkProgressOrderByInput = "createdAt_ASC"
	WorkProgressOrderByInputCreatedAtDesc     WorkProgressOrderByInput = "createdAt_DESC"
	WorkProgressOrderByInputUpdatedAtAsc      WorkProgressOrderByInput = "updatedAt_ASC"
	WorkProgressOrderByInputUpdatedAtDesc     WorkProgressOrderByInput = "updatedAt_DESC"
)

type WorkTemplateOrderByInput string

const (
	WorkTemplateOrderByInputIDAsc         WorkTemplateOrderByInput = "id_ASC"
	WorkTemplateOrderByInputIDDesc        WorkTemplateOrderByInput = "id_DESC"
	WorkTemplateOrderByInputCompanyIdAsc  WorkTemplateOrderByInput = "companyId_ASC"
	WorkTemplateOrderByInputCompanyIdDesc WorkTemplateOrderByInput = "companyId_DESC"
	WorkTemplateOrderByInputUserIdAsc     WorkTemplateOrderByInput = "userId_ASC"
	WorkTemplateOrderByInputUserIdDesc    WorkTemplateOrderByInput = "userId_DESC"
	WorkTemplateOrderByInputWorkTypeAsc   WorkTemplateOrderByInput = "workType_ASC"
	WorkTemplateOrderByInputWorkTypeDesc  WorkTemplateOrderByInput = "workType_DESC"
	WorkTemplateOrderByInputDataAsc       WorkTemplateOrderByInput = "data_ASC"
	WorkTemplateOrderByInputDataDesc      WorkTemplateOrderByInput = "data_DESC"
	WorkTemplateOrderByInputCreatedAtAsc  WorkTemplateOrderByInput = "createdAt_ASC"
	WorkTemplateOrderByInputCreatedAtDesc WorkTemplateOrderByInput = "createdAt_DESC"
	WorkTemplateOrderByInputUpdatedAtAsc  WorkTemplateOrderByInput = "updatedAt_ASC"
	WorkTemplateOrderByInputUpdatedAtDesc WorkTemplateOrderByInput = "updatedAt_DESC"
	WorkTemplateOrderByInputDeletedAtAsc  WorkTemplateOrderByInput = "deletedAt_ASC"
	WorkTemplateOrderByInputDeletedAtDesc WorkTemplateOrderByInput = "deletedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type CommonlyUsedPersonnelWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type CommonlyUsedPersonnelWhereInput struct {
	ID                     *int32                            `json:"id,omitempty"`
	IDNot                  *int32                            `json:"id_not,omitempty"`
	IDIn                   []int32                           `json:"id_in,omitempty"`
	IDNotIn                []int32                           `json:"id_not_in,omitempty"`
	IDLt                   *int32                            `json:"id_lt,omitempty"`
	IDLte                  *int32                            `json:"id_lte,omitempty"`
	IDGt                   *int32                            `json:"id_gt,omitempty"`
	IDGte                  *int32                            `json:"id_gte,omitempty"`
	CompanyId              *int32                            `json:"companyId,omitempty"`
	CompanyIdNot           *int32                            `json:"companyId_not,omitempty"`
	CompanyIdIn            []int32                           `json:"companyId_in,omitempty"`
	CompanyIdNotIn         []int32                           `json:"companyId_not_in,omitempty"`
	CompanyIdLt            *int32                            `json:"companyId_lt,omitempty"`
	CompanyIdLte           *int32                            `json:"companyId_lte,omitempty"`
	CompanyIdGt            *int32                            `json:"companyId_gt,omitempty"`
	CompanyIdGte           *int32                            `json:"companyId_gte,omitempty"`
	AppId                  *string                           `json:"appId,omitempty"`
	AppIdNot               *string                           `json:"appId_not,omitempty"`
	AppIdIn                []string                          `json:"appId_in,omitempty"`
	AppIdNotIn             []string                          `json:"appId_not_in,omitempty"`
	AppIdLt                *string                           `json:"appId_lt,omitempty"`
	AppIdLte               *string                           `json:"appId_lte,omitempty"`
	AppIdGt                *string                           `json:"appId_gt,omitempty"`
	AppIdGte               *string                           `json:"appId_gte,omitempty"`
	AppIdContains          *string                           `json:"appId_contains,omitempty"`
	AppIdNotContains       *string                           `json:"appId_not_contains,omitempty"`
	AppIdStartsWith        *string                           `json:"appId_starts_with,omitempty"`
	AppIdNotStartsWith     *string                           `json:"appId_not_starts_with,omitempty"`
	AppIdEndsWith          *string                           `json:"appId_ends_with,omitempty"`
	AppIdNotEndsWith       *string                           `json:"appId_not_ends_with,omitempty"`
	UserId                 *string                           `json:"userId,omitempty"`
	UserIdNot              *string                           `json:"userId_not,omitempty"`
	UserIdIn               []string                          `json:"userId_in,omitempty"`
	UserIdNotIn            []string                          `json:"userId_not_in,omitempty"`
	UserIdLt               *string                           `json:"userId_lt,omitempty"`
	UserIdLte              *string                           `json:"userId_lte,omitempty"`
	UserIdGt               *string                           `json:"userId_gt,omitempty"`
	UserIdGte              *string                           `json:"userId_gte,omitempty"`
	UserIdContains         *string                           `json:"userId_contains,omitempty"`
	UserIdNotContains      *string                           `json:"userId_not_contains,omitempty"`
	UserIdStartsWith       *string                           `json:"userId_starts_with,omitempty"`
	UserIdNotStartsWith    *string                           `json:"userId_not_starts_with,omitempty"`
	UserIdEndsWith         *string                           `json:"userId_ends_with,omitempty"`
	UserIdNotEndsWith      *string                           `json:"userId_not_ends_with,omitempty"`
	Name                   *string                           `json:"name,omitempty"`
	NameNot                *string                           `json:"name_not,omitempty"`
	NameIn                 []string                          `json:"name_in,omitempty"`
	NameNotIn              []string                          `json:"name_not_in,omitempty"`
	NameLt                 *string                           `json:"name_lt,omitempty"`
	NameLte                *string                           `json:"name_lte,omitempty"`
	NameGt                 *string                           `json:"name_gt,omitempty"`
	NameGte                *string                           `json:"name_gte,omitempty"`
	NameContains           *string                           `json:"name_contains,omitempty"`
	NameNotContains        *string                           `json:"name_not_contains,omitempty"`
	NameStartsWith         *string                           `json:"name_starts_with,omitempty"`
	NameNotStartsWith      *string                           `json:"name_not_starts_with,omitempty"`
	NameEndsWith           *string                           `json:"name_ends_with,omitempty"`
	NameNotEndsWith        *string                           `json:"name_not_ends_with,omitempty"`
	Avatar                 *string                           `json:"avatar,omitempty"`
	AvatarNot              *string                           `json:"avatar_not,omitempty"`
	AvatarIn               []string                          `json:"avatar_in,omitempty"`
	AvatarNotIn            []string                          `json:"avatar_not_in,omitempty"`
	AvatarLt               *string                           `json:"avatar_lt,omitempty"`
	AvatarLte              *string                           `json:"avatar_lte,omitempty"`
	AvatarGt               *string                           `json:"avatar_gt,omitempty"`
	AvatarGte              *string                           `json:"avatar_gte,omitempty"`
	AvatarContains         *string                           `json:"avatar_contains,omitempty"`
	AvatarNotContains      *string                           `json:"avatar_not_contains,omitempty"`
	AvatarStartsWith       *string                           `json:"avatar_starts_with,omitempty"`
	AvatarNotStartsWith    *string                           `json:"avatar_not_starts_with,omitempty"`
	AvatarEndsWith         *string                           `json:"avatar_ends_with,omitempty"`
	AvatarNotEndsWith      *string                           `json:"avatar_not_ends_with,omitempty"`
	CardNo                 *string                           `json:"cardNo,omitempty"`
	CardNoNot              *string                           `json:"cardNo_not,omitempty"`
	CardNoIn               []string                          `json:"cardNo_in,omitempty"`
	CardNoNotIn            []string                          `json:"cardNo_not_in,omitempty"`
	CardNoLt               *string                           `json:"cardNo_lt,omitempty"`
	CardNoLte              *string                           `json:"cardNo_lte,omitempty"`
	CardNoGt               *string                           `json:"cardNo_gt,omitempty"`
	CardNoGte              *string                           `json:"cardNo_gte,omitempty"`
	CardNoContains         *string                           `json:"cardNo_contains,omitempty"`
	CardNoNotContains      *string                           `json:"cardNo_not_contains,omitempty"`
	CardNoStartsWith       *string                           `json:"cardNo_starts_with,omitempty"`
	CardNoNotStartsWith    *string                           `json:"cardNo_not_starts_with,omitempty"`
	CardNoEndsWith         *string                           `json:"cardNo_ends_with,omitempty"`
	CardNoNotEndsWith      *string                           `json:"cardNo_not_ends_with,omitempty"`
	Mobile                 *string                           `json:"mobile,omitempty"`
	MobileNot              *string                           `json:"mobile_not,omitempty"`
	MobileIn               []string                          `json:"mobile_in,omitempty"`
	MobileNotIn            []string                          `json:"mobile_not_in,omitempty"`
	MobileLt               *string                           `json:"mobile_lt,omitempty"`
	MobileLte              *string                           `json:"mobile_lte,omitempty"`
	MobileGt               *string                           `json:"mobile_gt,omitempty"`
	MobileGte              *string                           `json:"mobile_gte,omitempty"`
	MobileContains         *string                           `json:"mobile_contains,omitempty"`
	MobileNotContains      *string                           `json:"mobile_not_contains,omitempty"`
	MobileStartsWith       *string                           `json:"mobile_starts_with,omitempty"`
	MobileNotStartsWith    *string                           `json:"mobile_not_starts_with,omitempty"`
	MobileEndsWith         *string                           `json:"mobile_ends_with,omitempty"`
	MobileNotEndsWith      *string                           `json:"mobile_not_ends_with,omitempty"`
	BankNo                 *string                           `json:"bankNo,omitempty"`
	BankNoNot              *string                           `json:"bankNo_not,omitempty"`
	BankNoIn               []string                          `json:"bankNo_in,omitempty"`
	BankNoNotIn            []string                          `json:"bankNo_not_in,omitempty"`
	BankNoLt               *string                           `json:"bankNo_lt,omitempty"`
	BankNoLte              *string                           `json:"bankNo_lte,omitempty"`
	BankNoGt               *string                           `json:"bankNo_gt,omitempty"`
	BankNoGte              *string                           `json:"bankNo_gte,omitempty"`
	BankNoContains         *string                           `json:"bankNo_contains,omitempty"`
	BankNoNotContains      *string                           `json:"bankNo_not_contains,omitempty"`
	BankNoStartsWith       *string                           `json:"bankNo_starts_with,omitempty"`
	BankNoNotStartsWith    *string                           `json:"bankNo_not_starts_with,omitempty"`
	BankNoEndsWith         *string                           `json:"bankNo_ends_with,omitempty"`
	BankNoNotEndsWith      *string                           `json:"bankNo_not_ends_with,omitempty"`
	Education              *string                           `json:"education,omitempty"`
	EducationNot           *string                           `json:"education_not,omitempty"`
	EducationIn            []string                          `json:"education_in,omitempty"`
	EducationNotIn         []string                          `json:"education_not_in,omitempty"`
	EducationLt            *string                           `json:"education_lt,omitempty"`
	EducationLte           *string                           `json:"education_lte,omitempty"`
	EducationGt            *string                           `json:"education_gt,omitempty"`
	EducationGte           *string                           `json:"education_gte,omitempty"`
	EducationContains      *string                           `json:"education_contains,omitempty"`
	EducationNotContains   *string                           `json:"education_not_contains,omitempty"`
	EducationStartsWith    *string                           `json:"education_starts_with,omitempty"`
	EducationNotStartsWith *string                           `json:"education_not_starts_with,omitempty"`
	EducationEndsWith      *string                           `json:"education_ends_with,omitempty"`
	EducationNotEndsWith   *string                           `json:"education_not_ends_with,omitempty"`
	Address                *string                           `json:"address,omitempty"`
	AddressNot             *string                           `json:"address_not,omitempty"`
	AddressIn              []string                          `json:"address_in,omitempty"`
	AddressNotIn           []string                          `json:"address_not_in,omitempty"`
	AddressLt              *string                           `json:"address_lt,omitempty"`
	AddressLte             *string                           `json:"address_lte,omitempty"`
	AddressGt              *string                           `json:"address_gt,omitempty"`
	AddressGte             *string                           `json:"address_gte,omitempty"`
	AddressContains        *string                           `json:"address_contains,omitempty"`
	AddressNotContains     *string                           `json:"address_not_contains,omitempty"`
	AddressStartsWith      *string                           `json:"address_starts_with,omitempty"`
	AddressNotStartsWith   *string                           `json:"address_not_starts_with,omitempty"`
	AddressEndsWith        *string                           `json:"address_ends_with,omitempty"`
	AddressNotEndsWith     *string                           `json:"address_not_ends_with,omitempty"`
	Remark                 *string                           `json:"remark,omitempty"`
	RemarkNot              *string                           `json:"remark_not,omitempty"`
	RemarkIn               []string                          `json:"remark_in,omitempty"`
	RemarkNotIn            []string                          `json:"remark_not_in,omitempty"`
	RemarkLt               *string                           `json:"remark_lt,omitempty"`
	RemarkLte              *string                           `json:"remark_lte,omitempty"`
	RemarkGt               *string                           `json:"remark_gt,omitempty"`
	RemarkGte              *string                           `json:"remark_gte,omitempty"`
	RemarkContains         *string                           `json:"remark_contains,omitempty"`
	RemarkNotContains      *string                           `json:"remark_not_contains,omitempty"`
	RemarkStartsWith       *string                           `json:"remark_starts_with,omitempty"`
	RemarkNotStartsWith    *string                           `json:"remark_not_starts_with,omitempty"`
	RemarkEndsWith         *string                           `json:"remark_ends_with,omitempty"`
	RemarkNotEndsWith      *string                           `json:"remark_not_ends_with,omitempty"`
	SigningTime            *int32                            `json:"signingTime,omitempty"`
	SigningTimeNot         *int32                            `json:"signingTime_not,omitempty"`
	SigningTimeIn          []int32                           `json:"signingTime_in,omitempty"`
	SigningTimeNotIn       []int32                           `json:"signingTime_not_in,omitempty"`
	SigningTimeLt          *int32                            `json:"signingTime_lt,omitempty"`
	SigningTimeLte         *int32                            `json:"signingTime_lte,omitempty"`
	SigningTimeGt          *int32                            `json:"signingTime_gt,omitempty"`
	SigningTimeGte         *int32                            `json:"signingTime_gte,omitempty"`
	CreatedAt              *string                           `json:"createdAt,omitempty"`
	CreatedAtNot           *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string                           `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string                           `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string                           `json:"updatedAt_gte,omitempty"`
	DeletedAt              *int32                            `json:"deletedAt,omitempty"`
	DeletedAtNot           *int32                            `json:"deletedAt_not,omitempty"`
	DeletedAtIn            []int32                           `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn         []int32                           `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt            *int32                            `json:"deletedAt_lt,omitempty"`
	DeletedAtLte           *int32                            `json:"deletedAt_lte,omitempty"`
	DeletedAtGt            *int32                            `json:"deletedAt_gt,omitempty"`
	DeletedAtGte           *int32                            `json:"deletedAt_gte,omitempty"`
	And                    []CommonlyUsedPersonnelWhereInput `json:"AND,omitempty"`
	Or                     []CommonlyUsedPersonnelWhereInput `json:"OR,omitempty"`
	Not                    []CommonlyUsedPersonnelWhereInput `json:"NOT,omitempty"`
}

type CompanyUserBlacklistWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type CompanyUserBlacklistWhereInput struct {
	ID                         *int32                           `json:"id,omitempty"`
	IDNot                      *int32                           `json:"id_not,omitempty"`
	IDIn                       []int32                          `json:"id_in,omitempty"`
	IDNotIn                    []int32                          `json:"id_not_in,omitempty"`
	IDLt                       *int32                           `json:"id_lt,omitempty"`
	IDLte                      *int32                           `json:"id_lte,omitempty"`
	IDGt                       *int32                           `json:"id_gt,omitempty"`
	IDGte                      *int32                           `json:"id_gte,omitempty"`
	CompanyId                  *int32                           `json:"companyId,omitempty"`
	CompanyIdNot               *int32                           `json:"companyId_not,omitempty"`
	CompanyIdIn                []int32                          `json:"companyId_in,omitempty"`
	CompanyIdNotIn             []int32                          `json:"companyId_not_in,omitempty"`
	CompanyIdLt                *int32                           `json:"companyId_lt,omitempty"`
	CompanyIdLte               *int32                           `json:"companyId_lte,omitempty"`
	CompanyIdGt                *int32                           `json:"companyId_gt,omitempty"`
	CompanyIdGte               *int32                           `json:"companyId_gte,omitempty"`
	ParticipantId              *string                          `json:"participantId,omitempty"`
	ParticipantIdNot           *string                          `json:"participantId_not,omitempty"`
	ParticipantIdIn            []string                         `json:"participantId_in,omitempty"`
	ParticipantIdNotIn         []string                         `json:"participantId_not_in,omitempty"`
	ParticipantIdLt            *string                          `json:"participantId_lt,omitempty"`
	ParticipantIdLte           *string                          `json:"participantId_lte,omitempty"`
	ParticipantIdGt            *string                          `json:"participantId_gt,omitempty"`
	ParticipantIdGte           *string                          `json:"participantId_gte,omitempty"`
	ParticipantIdContains      *string                          `json:"participantId_contains,omitempty"`
	ParticipantIdNotContains   *string                          `json:"participantId_not_contains,omitempty"`
	ParticipantIdStartsWith    *string                          `json:"participantId_starts_with,omitempty"`
	ParticipantIdNotStartsWith *string                          `json:"participantId_not_starts_with,omitempty"`
	ParticipantIdEndsWith      *string                          `json:"participantId_ends_with,omitempty"`
	ParticipantIdNotEndsWith   *string                          `json:"participantId_not_ends_with,omitempty"`
	PublisherId                *string                          `json:"publisherId,omitempty"`
	PublisherIdNot             *string                          `json:"publisherId_not,omitempty"`
	PublisherIdIn              []string                         `json:"publisherId_in,omitempty"`
	PublisherIdNotIn           []string                         `json:"publisherId_not_in,omitempty"`
	PublisherIdLt              *string                          `json:"publisherId_lt,omitempty"`
	PublisherIdLte             *string                          `json:"publisherId_lte,omitempty"`
	PublisherIdGt              *string                          `json:"publisherId_gt,omitempty"`
	PublisherIdGte             *string                          `json:"publisherId_gte,omitempty"`
	PublisherIdContains        *string                          `json:"publisherId_contains,omitempty"`
	PublisherIdNotContains     *string                          `json:"publisherId_not_contains,omitempty"`
	PublisherIdStartsWith      *string                          `json:"publisherId_starts_with,omitempty"`
	PublisherIdNotStartsWith   *string                          `json:"publisherId_not_starts_with,omitempty"`
	PublisherIdEndsWith        *string                          `json:"publisherId_ends_with,omitempty"`
	PublisherIdNotEndsWith     *string                          `json:"publisherId_not_ends_with,omitempty"`
	WorkId                     *int32                           `json:"workId,omitempty"`
	WorkIdNot                  *int32                           `json:"workId_not,omitempty"`
	WorkIdIn                   []int32                          `json:"workId_in,omitempty"`
	WorkIdNotIn                []int32                          `json:"workId_not_in,omitempty"`
	WorkIdLt                   *int32                           `json:"workId_lt,omitempty"`
	WorkIdLte                  *int32                           `json:"workId_lte,omitempty"`
	WorkIdGt                   *int32                           `json:"workId_gt,omitempty"`
	WorkIdGte                  *int32                           `json:"workId_gte,omitempty"`
	Type                       *int32                           `json:"type,omitempty"`
	TypeNot                    *int32                           `json:"type_not,omitempty"`
	TypeIn                     []int32                          `json:"type_in,omitempty"`
	TypeNotIn                  []int32                          `json:"type_not_in,omitempty"`
	TypeLt                     *int32                           `json:"type_lt,omitempty"`
	TypeLte                    *int32                           `json:"type_lte,omitempty"`
	TypeGt                     *int32                           `json:"type_gt,omitempty"`
	TypeGte                    *int32                           `json:"type_gte,omitempty"`
	CreatedAt                  *string                          `json:"createdAt,omitempty"`
	CreatedAtNot               *string                          `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string                         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string                         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string                          `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string                          `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string                          `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string                          `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string                          `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string                          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string                         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string                         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string                          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string                          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string                          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string                          `json:"updatedAt_gte,omitempty"`
	DeletedAt                  *int32                           `json:"deletedAt,omitempty"`
	DeletedAtNot               *int32                           `json:"deletedAt_not,omitempty"`
	DeletedAtIn                []int32                          `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn             []int32                          `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt                *int32                           `json:"deletedAt_lt,omitempty"`
	DeletedAtLte               *int32                           `json:"deletedAt_lte,omitempty"`
	DeletedAtGt                *int32                           `json:"deletedAt_gt,omitempty"`
	DeletedAtGte               *int32                           `json:"deletedAt_gte,omitempty"`
	And                        []CompanyUserBlacklistWhereInput `json:"AND,omitempty"`
	Or                         []CompanyUserBlacklistWhereInput `json:"OR,omitempty"`
	Not                        []CompanyUserBlacklistWhereInput `json:"NOT,omitempty"`
}

type CompanyUserKpiWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type CompanyUserKpiWhereInput struct {
	ID                         *int32                     `json:"id,omitempty"`
	IDNot                      *int32                     `json:"id_not,omitempty"`
	IDIn                       []int32                    `json:"id_in,omitempty"`
	IDNotIn                    []int32                    `json:"id_not_in,omitempty"`
	IDLt                       *int32                     `json:"id_lt,omitempty"`
	IDLte                      *int32                     `json:"id_lte,omitempty"`
	IDGt                       *int32                     `json:"id_gt,omitempty"`
	IDGte                      *int32                     `json:"id_gte,omitempty"`
	WorkId                     *int32                     `json:"workId,omitempty"`
	WorkIdNot                  *int32                     `json:"workId_not,omitempty"`
	WorkIdIn                   []int32                    `json:"workId_in,omitempty"`
	WorkIdNotIn                []int32                    `json:"workId_not_in,omitempty"`
	WorkIdLt                   *int32                     `json:"workId_lt,omitempty"`
	WorkIdLte                  *int32                     `json:"workId_lte,omitempty"`
	WorkIdGt                   *int32                     `json:"workId_gt,omitempty"`
	WorkIdGte                  *int32                     `json:"workId_gte,omitempty"`
	Amount                     *float64                   `json:"amount,omitempty"`
	AmountNot                  *float64                   `json:"amount_not,omitempty"`
	AmountIn                   []float64                  `json:"amount_in,omitempty"`
	AmountNotIn                []float64                  `json:"amount_not_in,omitempty"`
	AmountLt                   *float64                   `json:"amount_lt,omitempty"`
	AmountLte                  *float64                   `json:"amount_lte,omitempty"`
	AmountGt                   *float64                   `json:"amount_gt,omitempty"`
	AmountGte                  *float64                   `json:"amount_gte,omitempty"`
	CompanyId                  *int32                     `json:"companyId,omitempty"`
	CompanyIdNot               *int32                     `json:"companyId_not,omitempty"`
	CompanyIdIn                []int32                    `json:"companyId_in,omitempty"`
	CompanyIdNotIn             []int32                    `json:"companyId_not_in,omitempty"`
	CompanyIdLt                *int32                     `json:"companyId_lt,omitempty"`
	CompanyIdLte               *int32                     `json:"companyId_lte,omitempty"`
	CompanyIdGt                *int32                     `json:"companyId_gt,omitempty"`
	CompanyIdGte               *int32                     `json:"companyId_gte,omitempty"`
	ParticipantId              *string                    `json:"participantId,omitempty"`
	ParticipantIdNot           *string                    `json:"participantId_not,omitempty"`
	ParticipantIdIn            []string                   `json:"participantId_in,omitempty"`
	ParticipantIdNotIn         []string                   `json:"participantId_not_in,omitempty"`
	ParticipantIdLt            *string                    `json:"participantId_lt,omitempty"`
	ParticipantIdLte           *string                    `json:"participantId_lte,omitempty"`
	ParticipantIdGt            *string                    `json:"participantId_gt,omitempty"`
	ParticipantIdGte           *string                    `json:"participantId_gte,omitempty"`
	ParticipantIdContains      *string                    `json:"participantId_contains,omitempty"`
	ParticipantIdNotContains   *string                    `json:"participantId_not_contains,omitempty"`
	ParticipantIdStartsWith    *string                    `json:"participantId_starts_with,omitempty"`
	ParticipantIdNotStartsWith *string                    `json:"participantId_not_starts_with,omitempty"`
	ParticipantIdEndsWith      *string                    `json:"participantId_ends_with,omitempty"`
	ParticipantIdNotEndsWith   *string                    `json:"participantId_not_ends_with,omitempty"`
	PayAt                      *int32                     `json:"payAt,omitempty"`
	PayAtNot                   *int32                     `json:"payAt_not,omitempty"`
	PayAtIn                    []int32                    `json:"payAt_in,omitempty"`
	PayAtNotIn                 []int32                    `json:"payAt_not_in,omitempty"`
	PayAtLt                    *int32                     `json:"payAt_lt,omitempty"`
	PayAtLte                   *int32                     `json:"payAt_lte,omitempty"`
	PayAtGt                    *int32                     `json:"payAt_gt,omitempty"`
	PayAtGte                   *int32                     `json:"payAt_gte,omitempty"`
	PublisherId                *string                    `json:"publisherId,omitempty"`
	PublisherIdNot             *string                    `json:"publisherId_not,omitempty"`
	PublisherIdIn              []string                   `json:"publisherId_in,omitempty"`
	PublisherIdNotIn           []string                   `json:"publisherId_not_in,omitempty"`
	PublisherIdLt              *string                    `json:"publisherId_lt,omitempty"`
	PublisherIdLte             *string                    `json:"publisherId_lte,omitempty"`
	PublisherIdGt              *string                    `json:"publisherId_gt,omitempty"`
	PublisherIdGte             *string                    `json:"publisherId_gte,omitempty"`
	PublisherIdContains        *string                    `json:"publisherId_contains,omitempty"`
	PublisherIdNotContains     *string                    `json:"publisherId_not_contains,omitempty"`
	PublisherIdStartsWith      *string                    `json:"publisherId_starts_with,omitempty"`
	PublisherIdNotStartsWith   *string                    `json:"publisherId_not_starts_with,omitempty"`
	PublisherIdEndsWith        *string                    `json:"publisherId_ends_with,omitempty"`
	PublisherIdNotEndsWith     *string                    `json:"publisherId_not_ends_with,omitempty"`
	IsPaid                     *int32                     `json:"isPaid,omitempty"`
	IsPaidNot                  *int32                     `json:"isPaid_not,omitempty"`
	IsPaidIn                   []int32                    `json:"isPaid_in,omitempty"`
	IsPaidNotIn                []int32                    `json:"isPaid_not_in,omitempty"`
	IsPaidLt                   *int32                     `json:"isPaid_lt,omitempty"`
	IsPaidLte                  *int32                     `json:"isPaid_lte,omitempty"`
	IsPaidGt                   *int32                     `json:"isPaid_gt,omitempty"`
	IsPaidGte                  *int32                     `json:"isPaid_gte,omitempty"`
	KpiCoefficient             *float64                   `json:"kpiCoefficient,omitempty"`
	KpiCoefficientNot          *float64                   `json:"kpiCoefficient_not,omitempty"`
	KpiCoefficientIn           []float64                  `json:"kpiCoefficient_in,omitempty"`
	KpiCoefficientNotIn        []float64                  `json:"kpiCoefficient_not_in,omitempty"`
	KpiCoefficientLt           *float64                   `json:"kpiCoefficient_lt,omitempty"`
	KpiCoefficientLte          *float64                   `json:"kpiCoefficient_lte,omitempty"`
	KpiCoefficientGt           *float64                   `json:"kpiCoefficient_gt,omitempty"`
	KpiCoefficientGte          *float64                   `json:"kpiCoefficient_gte,omitempty"`
	Extend                     *string                    `json:"extend,omitempty"`
	ExtendNot                  *string                    `json:"extend_not,omitempty"`
	ExtendIn                   []string                   `json:"extend_in,omitempty"`
	ExtendNotIn                []string                   `json:"extend_not_in,omitempty"`
	ExtendLt                   *string                    `json:"extend_lt,omitempty"`
	ExtendLte                  *string                    `json:"extend_lte,omitempty"`
	ExtendGt                   *string                    `json:"extend_gt,omitempty"`
	ExtendGte                  *string                    `json:"extend_gte,omitempty"`
	ExtendContains             *string                    `json:"extend_contains,omitempty"`
	ExtendNotContains          *string                    `json:"extend_not_contains,omitempty"`
	ExtendStartsWith           *string                    `json:"extend_starts_with,omitempty"`
	ExtendNotStartsWith        *string                    `json:"extend_not_starts_with,omitempty"`
	ExtendEndsWith             *string                    `json:"extend_ends_with,omitempty"`
	ExtendNotEndsWith          *string                    `json:"extend_not_ends_with,omitempty"`
	CreatedAt                  *string                    `json:"createdAt,omitempty"`
	CreatedAtNot               *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string                    `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string                    `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string                    `json:"updatedAt_gte,omitempty"`
	And                        []CompanyUserKpiWhereInput `json:"AND,omitempty"`
	Or                         []CompanyUserKpiWhereInput `json:"OR,omitempty"`
	Not                        []CompanyUserKpiWhereInput `json:"NOT,omitempty"`
}

type ImportLogsWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type ImportLogsWhereInput struct {
	ID                      *int32                 `json:"id,omitempty"`
	IDNot                   *int32                 `json:"id_not,omitempty"`
	IDIn                    []int32                `json:"id_in,omitempty"`
	IDNotIn                 []int32                `json:"id_not_in,omitempty"`
	IDLt                    *int32                 `json:"id_lt,omitempty"`
	IDLte                   *int32                 `json:"id_lte,omitempty"`
	IDGt                    *int32                 `json:"id_gt,omitempty"`
	IDGte                   *int32                 `json:"id_gte,omitempty"`
	FileHash                *string                `json:"fileHash,omitempty"`
	FileHashNot             *string                `json:"fileHash_not,omitempty"`
	FileHashIn              []string               `json:"fileHash_in,omitempty"`
	FileHashNotIn           []string               `json:"fileHash_not_in,omitempty"`
	FileHashLt              *string                `json:"fileHash_lt,omitempty"`
	FileHashLte             *string                `json:"fileHash_lte,omitempty"`
	FileHashGt              *string                `json:"fileHash_gt,omitempty"`
	FileHashGte             *string                `json:"fileHash_gte,omitempty"`
	FileHashContains        *string                `json:"fileHash_contains,omitempty"`
	FileHashNotContains     *string                `json:"fileHash_not_contains,omitempty"`
	FileHashStartsWith      *string                `json:"fileHash_starts_with,omitempty"`
	FileHashNotStartsWith   *string                `json:"fileHash_not_starts_with,omitempty"`
	FileHashEndsWith        *string                `json:"fileHash_ends_with,omitempty"`
	FileHashNotEndsWith     *string                `json:"fileHash_not_ends_with,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	NameNot                 *string                `json:"name_not,omitempty"`
	NameIn                  []string               `json:"name_in,omitempty"`
	NameNotIn               []string               `json:"name_not_in,omitempty"`
	NameLt                  *string                `json:"name_lt,omitempty"`
	NameLte                 *string                `json:"name_lte,omitempty"`
	NameGt                  *string                `json:"name_gt,omitempty"`
	NameGte                 *string                `json:"name_gte,omitempty"`
	NameContains            *string                `json:"name_contains,omitempty"`
	NameNotContains         *string                `json:"name_not_contains,omitempty"`
	NameStartsWith          *string                `json:"name_starts_with,omitempty"`
	NameNotStartsWith       *string                `json:"name_not_starts_with,omitempty"`
	NameEndsWith            *string                `json:"name_ends_with,omitempty"`
	NameNotEndsWith         *string                `json:"name_not_ends_with,omitempty"`
	Mobile                  *string                `json:"mobile,omitempty"`
	MobileNot               *string                `json:"mobile_not,omitempty"`
	MobileIn                []string               `json:"mobile_in,omitempty"`
	MobileNotIn             []string               `json:"mobile_not_in,omitempty"`
	MobileLt                *string                `json:"mobile_lt,omitempty"`
	MobileLte               *string                `json:"mobile_lte,omitempty"`
	MobileGt                *string                `json:"mobile_gt,omitempty"`
	MobileGte               *string                `json:"mobile_gte,omitempty"`
	MobileContains          *string                `json:"mobile_contains,omitempty"`
	MobileNotContains       *string                `json:"mobile_not_contains,omitempty"`
	MobileStartsWith        *string                `json:"mobile_starts_with,omitempty"`
	MobileNotStartsWith     *string                `json:"mobile_not_starts_with,omitempty"`
	MobileEndsWith          *string                `json:"mobile_ends_with,omitempty"`
	MobileNotEndsWith       *string                `json:"mobile_not_ends_with,omitempty"`
	CardNo                  *string                `json:"cardNo,omitempty"`
	CardNoNot               *string                `json:"cardNo_not,omitempty"`
	CardNoIn                []string               `json:"cardNo_in,omitempty"`
	CardNoNotIn             []string               `json:"cardNo_not_in,omitempty"`
	CardNoLt                *string                `json:"cardNo_lt,omitempty"`
	CardNoLte               *string                `json:"cardNo_lte,omitempty"`
	CardNoGt                *string                `json:"cardNo_gt,omitempty"`
	CardNoGte               *string                `json:"cardNo_gte,omitempty"`
	CardNoContains          *string                `json:"cardNo_contains,omitempty"`
	CardNoNotContains       *string                `json:"cardNo_not_contains,omitempty"`
	CardNoStartsWith        *string                `json:"cardNo_starts_with,omitempty"`
	CardNoNotStartsWith     *string                `json:"cardNo_not_starts_with,omitempty"`
	CardNoEndsWith          *string                `json:"cardNo_ends_with,omitempty"`
	CardNoNotEndsWith       *string                `json:"cardNo_not_ends_with,omitempty"`
	Status                  *int32                 `json:"status,omitempty"`
	StatusNot               *int32                 `json:"status_not,omitempty"`
	StatusIn                []int32                `json:"status_in,omitempty"`
	StatusNotIn             []int32                `json:"status_not_in,omitempty"`
	StatusLt                *int32                 `json:"status_lt,omitempty"`
	StatusLte               *int32                 `json:"status_lte,omitempty"`
	StatusGt                *int32                 `json:"status_gt,omitempty"`
	StatusGte               *int32                 `json:"status_gte,omitempty"`
	LogContent              *string                `json:"logContent,omitempty"`
	LogContentNot           *string                `json:"logContent_not,omitempty"`
	LogContentIn            []string               `json:"logContent_in,omitempty"`
	LogContentNotIn         []string               `json:"logContent_not_in,omitempty"`
	LogContentLt            *string                `json:"logContent_lt,omitempty"`
	LogContentLte           *string                `json:"logContent_lte,omitempty"`
	LogContentGt            *string                `json:"logContent_gt,omitempty"`
	LogContentGte           *string                `json:"logContent_gte,omitempty"`
	LogContentContains      *string                `json:"logContent_contains,omitempty"`
	LogContentNotContains   *string                `json:"logContent_not_contains,omitempty"`
	LogContentStartsWith    *string                `json:"logContent_starts_with,omitempty"`
	LogContentNotStartsWith *string                `json:"logContent_not_starts_with,omitempty"`
	LogContentEndsWith      *string                `json:"logContent_ends_with,omitempty"`
	LogContentNotEndsWith   *string                `json:"logContent_not_ends_with,omitempty"`
	CreatedAt               *string                `json:"createdAt,omitempty"`
	CreatedAtNot            *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn             []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn          []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt             *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte            *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt             *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte            *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt               *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot            *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn             []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn          []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt             *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte            *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt             *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte            *string                `json:"updatedAt_gte,omitempty"`
	And                     []ImportLogsWhereInput `json:"AND,omitempty"`
	Or                      []ImportLogsWhereInput `json:"OR,omitempty"`
	Not                     []ImportLogsWhereInput `json:"NOT,omitempty"`
}

type JobWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type JobWhereInput struct {
	ID                            *int32          `json:"id,omitempty"`
	IDNot                         *int32          `json:"id_not,omitempty"`
	IDIn                          []int32         `json:"id_in,omitempty"`
	IDNotIn                       []int32         `json:"id_not_in,omitempty"`
	IDLt                          *int32          `json:"id_lt,omitempty"`
	IDLte                         *int32          `json:"id_lte,omitempty"`
	IDGt                          *int32          `json:"id_gt,omitempty"`
	IDGte                         *int32          `json:"id_gte,omitempty"`
	WorkId                        *int32          `json:"workId,omitempty"`
	WorkIdNot                     *int32          `json:"workId_not,omitempty"`
	WorkIdIn                      []int32         `json:"workId_in,omitempty"`
	WorkIdNotIn                   []int32         `json:"workId_not_in,omitempty"`
	WorkIdLt                      *int32          `json:"workId_lt,omitempty"`
	WorkIdLte                     *int32          `json:"workId_lte,omitempty"`
	WorkIdGt                      *int32          `json:"workId_gt,omitempty"`
	WorkIdGte                     *int32          `json:"workId_gte,omitempty"`
	Category                      *int32          `json:"category,omitempty"`
	CategoryNot                   *int32          `json:"category_not,omitempty"`
	CategoryIn                    []int32         `json:"category_in,omitempty"`
	CategoryNotIn                 []int32         `json:"category_not_in,omitempty"`
	CategoryLt                    *int32          `json:"category_lt,omitempty"`
	CategoryLte                   *int32          `json:"category_lte,omitempty"`
	CategoryGt                    *int32          `json:"category_gt,omitempty"`
	CategoryGte                   *int32          `json:"category_gte,omitempty"`
	SettlementRule                *string         `json:"settlementRule,omitempty"`
	SettlementRuleNot             *string         `json:"settlementRule_not,omitempty"`
	SettlementRuleIn              []string        `json:"settlementRule_in,omitempty"`
	SettlementRuleNotIn           []string        `json:"settlementRule_not_in,omitempty"`
	SettlementRuleLt              *string         `json:"settlementRule_lt,omitempty"`
	SettlementRuleLte             *string         `json:"settlementRule_lte,omitempty"`
	SettlementRuleGt              *string         `json:"settlementRule_gt,omitempty"`
	SettlementRuleGte             *string         `json:"settlementRule_gte,omitempty"`
	SettlementRuleContains        *string         `json:"settlementRule_contains,omitempty"`
	SettlementRuleNotContains     *string         `json:"settlementRule_not_contains,omitempty"`
	SettlementRuleStartsWith      *string         `json:"settlementRule_starts_with,omitempty"`
	SettlementRuleNotStartsWith   *string         `json:"settlementRule_not_starts_with,omitempty"`
	SettlementRuleEndsWith        *string         `json:"settlementRule_ends_with,omitempty"`
	SettlementRuleNotEndsWith     *string         `json:"settlementRule_not_ends_with,omitempty"`
	PayStatus                     *int32          `json:"payStatus,omitempty"`
	PayStatusNot                  *int32          `json:"payStatus_not,omitempty"`
	PayStatusIn                   []int32         `json:"payStatus_in,omitempty"`
	PayStatusNotIn                []int32         `json:"payStatus_not_in,omitempty"`
	PayStatusLt                   *int32          `json:"payStatus_lt,omitempty"`
	PayStatusLte                  *int32          `json:"payStatus_lte,omitempty"`
	PayStatusGt                   *int32          `json:"payStatus_gt,omitempty"`
	PayStatusGte                  *int32          `json:"payStatus_gte,omitempty"`
	Progress                      *int32          `json:"progress,omitempty"`
	ProgressNot                   *int32          `json:"progress_not,omitempty"`
	ProgressIn                    []int32         `json:"progress_in,omitempty"`
	ProgressNotIn                 []int32         `json:"progress_not_in,omitempty"`
	ProgressLt                    *int32          `json:"progress_lt,omitempty"`
	ProgressLte                   *int32          `json:"progress_lte,omitempty"`
	ProgressGt                    *int32          `json:"progress_gt,omitempty"`
	ProgressGte                   *int32          `json:"progress_gte,omitempty"`
	Quota                         *int32          `json:"quota,omitempty"`
	QuotaNot                      *int32          `json:"quota_not,omitempty"`
	QuotaIn                       []int32         `json:"quota_in,omitempty"`
	QuotaNotIn                    []int32         `json:"quota_not_in,omitempty"`
	QuotaLt                       *int32          `json:"quota_lt,omitempty"`
	QuotaLte                      *int32          `json:"quota_lte,omitempty"`
	QuotaGt                       *int32          `json:"quota_gt,omitempty"`
	QuotaGte                      *int32          `json:"quota_gte,omitempty"`
	SingleRewardMax               *float64        `json:"singleRewardMax,omitempty"`
	SingleRewardMaxNot            *float64        `json:"singleRewardMax_not,omitempty"`
	SingleRewardMaxIn             []float64       `json:"singleRewardMax_in,omitempty"`
	SingleRewardMaxNotIn          []float64       `json:"singleRewardMax_not_in,omitempty"`
	SingleRewardMaxLt             *float64        `json:"singleRewardMax_lt,omitempty"`
	SingleRewardMaxLte            *float64        `json:"singleRewardMax_lte,omitempty"`
	SingleRewardMaxGt             *float64        `json:"singleRewardMax_gt,omitempty"`
	SingleRewardMaxGte            *float64        `json:"singleRewardMax_gte,omitempty"`
	SingleRewardMin               *float64        `json:"singleRewardMin,omitempty"`
	SingleRewardMinNot            *float64        `json:"singleRewardMin_not,omitempty"`
	SingleRewardMinIn             []float64       `json:"singleRewardMin_in,omitempty"`
	SingleRewardMinNotIn          []float64       `json:"singleRewardMin_not_in,omitempty"`
	SingleRewardMinLt             *float64        `json:"singleRewardMin_lt,omitempty"`
	SingleRewardMinLte            *float64        `json:"singleRewardMin_lte,omitempty"`
	SingleRewardMinGt             *float64        `json:"singleRewardMin_gt,omitempty"`
	SingleRewardMinGte            *float64        `json:"singleRewardMin_gte,omitempty"`
	IsCanComment                  *int32          `json:"isCanComment,omitempty"`
	IsCanCommentNot               *int32          `json:"isCanComment_not,omitempty"`
	IsCanCommentIn                []int32         `json:"isCanComment_in,omitempty"`
	IsCanCommentNotIn             []int32         `json:"isCanComment_not_in,omitempty"`
	IsCanCommentLt                *int32          `json:"isCanComment_lt,omitempty"`
	IsCanCommentLte               *int32          `json:"isCanComment_lte,omitempty"`
	IsCanCommentGt                *int32          `json:"isCanComment_gt,omitempty"`
	IsCanCommentGte               *int32          `json:"isCanComment_gte,omitempty"`
	IsNeedProof                   *int32          `json:"isNeedProof,omitempty"`
	IsNeedProofNot                *int32          `json:"isNeedProof_not,omitempty"`
	IsNeedProofIn                 []int32         `json:"isNeedProof_in,omitempty"`
	IsNeedProofNotIn              []int32         `json:"isNeedProof_not_in,omitempty"`
	IsNeedProofLt                 *int32          `json:"isNeedProof_lt,omitempty"`
	IsNeedProofLte                *int32          `json:"isNeedProof_lte,omitempty"`
	IsNeedProofGt                 *int32          `json:"isNeedProof_gt,omitempty"`
	IsNeedProofGte                *int32          `json:"isNeedProof_gte,omitempty"`
	ProofDescription              *string         `json:"proofDescription,omitempty"`
	ProofDescriptionNot           *string         `json:"proofDescription_not,omitempty"`
	ProofDescriptionIn            []string        `json:"proofDescription_in,omitempty"`
	ProofDescriptionNotIn         []string        `json:"proofDescription_not_in,omitempty"`
	ProofDescriptionLt            *string         `json:"proofDescription_lt,omitempty"`
	ProofDescriptionLte           *string         `json:"proofDescription_lte,omitempty"`
	ProofDescriptionGt            *string         `json:"proofDescription_gt,omitempty"`
	ProofDescriptionGte           *string         `json:"proofDescription_gte,omitempty"`
	ProofDescriptionContains      *string         `json:"proofDescription_contains,omitempty"`
	ProofDescriptionNotContains   *string         `json:"proofDescription_not_contains,omitempty"`
	ProofDescriptionStartsWith    *string         `json:"proofDescription_starts_with,omitempty"`
	ProofDescriptionNotStartsWith *string         `json:"proofDescription_not_starts_with,omitempty"`
	ProofDescriptionEndsWith      *string         `json:"proofDescription_ends_with,omitempty"`
	ProofDescriptionNotEndsWith   *string         `json:"proofDescription_not_ends_with,omitempty"`
	ProofType                     *int32          `json:"proofType,omitempty"`
	ProofTypeNot                  *int32          `json:"proofType_not,omitempty"`
	ProofTypeIn                   []int32         `json:"proofType_in,omitempty"`
	ProofTypeNotIn                []int32         `json:"proofType_not_in,omitempty"`
	ProofTypeLt                   *int32          `json:"proofType_lt,omitempty"`
	ProofTypeLte                  *int32          `json:"proofType_lte,omitempty"`
	ProofTypeGt                   *int32          `json:"proofType_gt,omitempty"`
	ProofTypeGte                  *int32          `json:"proofType_gte,omitempty"`
	Remark                        *string         `json:"remark,omitempty"`
	RemarkNot                     *string         `json:"remark_not,omitempty"`
	RemarkIn                      []string        `json:"remark_in,omitempty"`
	RemarkNotIn                   []string        `json:"remark_not_in,omitempty"`
	RemarkLt                      *string         `json:"remark_lt,omitempty"`
	RemarkLte                     *string         `json:"remark_lte,omitempty"`
	RemarkGt                      *string         `json:"remark_gt,omitempty"`
	RemarkGte                     *string         `json:"remark_gte,omitempty"`
	RemarkContains                *string         `json:"remark_contains,omitempty"`
	RemarkNotContains             *string         `json:"remark_not_contains,omitempty"`
	RemarkStartsWith              *string         `json:"remark_starts_with,omitempty"`
	RemarkNotStartsWith           *string         `json:"remark_not_starts_with,omitempty"`
	RemarkEndsWith                *string         `json:"remark_ends_with,omitempty"`
	RemarkNotEndsWith             *string         `json:"remark_not_ends_with,omitempty"`
	TemplateId                    *int32          `json:"templateId,omitempty"`
	TemplateIdNot                 *int32          `json:"templateId_not,omitempty"`
	TemplateIdIn                  []int32         `json:"templateId_in,omitempty"`
	TemplateIdNotIn               []int32         `json:"templateId_not_in,omitempty"`
	TemplateIdLt                  *int32          `json:"templateId_lt,omitempty"`
	TemplateIdLte                 *int32          `json:"templateId_lte,omitempty"`
	TemplateIdGt                  *int32          `json:"templateId_gt,omitempty"`
	TemplateIdGte                 *int32          `json:"templateId_gte,omitempty"`
	Extend                        *string         `json:"extend,omitempty"`
	ExtendNot                     *string         `json:"extend_not,omitempty"`
	ExtendIn                      []string        `json:"extend_in,omitempty"`
	ExtendNotIn                   []string        `json:"extend_not_in,omitempty"`
	ExtendLt                      *string         `json:"extend_lt,omitempty"`
	ExtendLte                     *string         `json:"extend_lte,omitempty"`
	ExtendGt                      *string         `json:"extend_gt,omitempty"`
	ExtendGte                     *string         `json:"extend_gte,omitempty"`
	ExtendContains                *string         `json:"extend_contains,omitempty"`
	ExtendNotContains             *string         `json:"extend_not_contains,omitempty"`
	ExtendStartsWith              *string         `json:"extend_starts_with,omitempty"`
	ExtendNotStartsWith           *string         `json:"extend_not_starts_with,omitempty"`
	ExtendEndsWith                *string         `json:"extend_ends_with,omitempty"`
	ExtendNotEndsWith             *string         `json:"extend_not_ends_with,omitempty"`
	CreatedAt                     *string         `json:"createdAt,omitempty"`
	CreatedAtNot                  *string         `json:"createdAt_not,omitempty"`
	CreatedAtIn                   []string        `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                []string        `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                   *string         `json:"createdAt_lt,omitempty"`
	CreatedAtLte                  *string         `json:"createdAt_lte,omitempty"`
	CreatedAtGt                   *string         `json:"createdAt_gt,omitempty"`
	CreatedAtGte                  *string         `json:"createdAt_gte,omitempty"`
	UpdatedAt                     *string         `json:"updatedAt,omitempty"`
	UpdatedAtNot                  *string         `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                   []string        `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                []string        `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                   *string         `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                  *string         `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                   *string         `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                  *string         `json:"updatedAt_gte,omitempty"`
	DeletedAt                     *int32          `json:"deletedAt,omitempty"`
	DeletedAtNot                  *int32          `json:"deletedAt_not,omitempty"`
	DeletedAtIn                   []int32         `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn                []int32         `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt                   *int32          `json:"deletedAt_lt,omitempty"`
	DeletedAtLte                  *int32          `json:"deletedAt_lte,omitempty"`
	DeletedAtGt                   *int32          `json:"deletedAt_gt,omitempty"`
	DeletedAtGte                  *int32          `json:"deletedAt_gte,omitempty"`
	And                           []JobWhereInput `json:"AND,omitempty"`
	Or                            []JobWhereInput `json:"OR,omitempty"`
	Not                           []JobWhereInput `json:"NOT,omitempty"`
}

type JobAchievementWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type JobAchievementWhereInput struct {
	ID                  *int32                     `json:"id,omitempty"`
	IDNot               *int32                     `json:"id_not,omitempty"`
	IDIn                []int32                    `json:"id_in,omitempty"`
	IDNotIn             []int32                    `json:"id_not_in,omitempty"`
	IDLt                *int32                     `json:"id_lt,omitempty"`
	IDLte               *int32                     `json:"id_lte,omitempty"`
	IDGt                *int32                     `json:"id_gt,omitempty"`
	IDGte               *int32                     `json:"id_gte,omitempty"`
	JobId               *int32                     `json:"jobId,omitempty"`
	JobIdNot            *int32                     `json:"jobId_not,omitempty"`
	JobIdIn             []int32                    `json:"jobId_in,omitempty"`
	JobIdNotIn          []int32                    `json:"jobId_not_in,omitempty"`
	JobIdLt             *int32                     `json:"jobId_lt,omitempty"`
	JobIdLte            *int32                     `json:"jobId_lte,omitempty"`
	JobIdGt             *int32                     `json:"jobId_gt,omitempty"`
	JobIdGte            *int32                     `json:"jobId_gte,omitempty"`
	UserId              *string                    `json:"userId,omitempty"`
	UserIdNot           *string                    `json:"userId_not,omitempty"`
	UserIdIn            []string                   `json:"userId_in,omitempty"`
	UserIdNotIn         []string                   `json:"userId_not_in,omitempty"`
	UserIdLt            *string                    `json:"userId_lt,omitempty"`
	UserIdLte           *string                    `json:"userId_lte,omitempty"`
	UserIdGt            *string                    `json:"userId_gt,omitempty"`
	UserIdGte           *string                    `json:"userId_gte,omitempty"`
	UserIdContains      *string                    `json:"userId_contains,omitempty"`
	UserIdNotContains   *string                    `json:"userId_not_contains,omitempty"`
	UserIdStartsWith    *string                    `json:"userId_starts_with,omitempty"`
	UserIdNotStartsWith *string                    `json:"userId_not_starts_with,omitempty"`
	UserIdEndsWith      *string                    `json:"userId_ends_with,omitempty"`
	UserIdNotEndsWith   *string                    `json:"userId_not_ends_with,omitempty"`
	Extend              *string                    `json:"extend,omitempty"`
	ExtendNot           *string                    `json:"extend_not,omitempty"`
	ExtendIn            []string                   `json:"extend_in,omitempty"`
	ExtendNotIn         []string                   `json:"extend_not_in,omitempty"`
	ExtendLt            *string                    `json:"extend_lt,omitempty"`
	ExtendLte           *string                    `json:"extend_lte,omitempty"`
	ExtendGt            *string                    `json:"extend_gt,omitempty"`
	ExtendGte           *string                    `json:"extend_gte,omitempty"`
	ExtendContains      *string                    `json:"extend_contains,omitempty"`
	ExtendNotContains   *string                    `json:"extend_not_contains,omitempty"`
	ExtendStartsWith    *string                    `json:"extend_starts_with,omitempty"`
	ExtendNotStartsWith *string                    `json:"extend_not_starts_with,omitempty"`
	ExtendEndsWith      *string                    `json:"extend_ends_with,omitempty"`
	ExtendNotEndsWith   *string                    `json:"extend_not_ends_with,omitempty"`
	CreatedAt           *string                    `json:"createdAt,omitempty"`
	CreatedAtNot        *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                    `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                    `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                    `json:"updatedAt_gte,omitempty"`
	DeletedAt           *int32                     `json:"deletedAt,omitempty"`
	DeletedAtNot        *int32                     `json:"deletedAt_not,omitempty"`
	DeletedAtIn         []int32                    `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn      []int32                    `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt         *int32                     `json:"deletedAt_lt,omitempty"`
	DeletedAtLte        *int32                     `json:"deletedAt_lte,omitempty"`
	DeletedAtGt         *int32                     `json:"deletedAt_gt,omitempty"`
	DeletedAtGte        *int32                     `json:"deletedAt_gte,omitempty"`
	And                 []JobAchievementWhereInput `json:"AND,omitempty"`
	Or                  []JobAchievementWhereInput `json:"OR,omitempty"`
	Not                 []JobAchievementWhereInput `json:"NOT,omitempty"`
}

type JobContractJournalWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type JobContractJournalWhereInput struct {
	ID                      *int32                         `json:"id,omitempty"`
	IDNot                   *int32                         `json:"id_not,omitempty"`
	IDIn                    []int32                        `json:"id_in,omitempty"`
	IDNotIn                 []int32                        `json:"id_not_in,omitempty"`
	IDLt                    *int32                         `json:"id_lt,omitempty"`
	IDLte                   *int32                         `json:"id_lte,omitempty"`
	IDGt                    *int32                         `json:"id_gt,omitempty"`
	IDGte                   *int32                         `json:"id_gte,omitempty"`
	ContractNo              *string                        `json:"contractNo,omitempty"`
	ContractNoNot           *string                        `json:"contractNo_not,omitempty"`
	ContractNoIn            []string                       `json:"contractNo_in,omitempty"`
	ContractNoNotIn         []string                       `json:"contractNo_not_in,omitempty"`
	ContractNoLt            *string                        `json:"contractNo_lt,omitempty"`
	ContractNoLte           *string                        `json:"contractNo_lte,omitempty"`
	ContractNoGt            *string                        `json:"contractNo_gt,omitempty"`
	ContractNoGte           *string                        `json:"contractNo_gte,omitempty"`
	ContractNoContains      *string                        `json:"contractNo_contains,omitempty"`
	ContractNoNotContains   *string                        `json:"contractNo_not_contains,omitempty"`
	ContractNoStartsWith    *string                        `json:"contractNo_starts_with,omitempty"`
	ContractNoNotStartsWith *string                        `json:"contractNo_not_starts_with,omitempty"`
	ContractNoEndsWith      *string                        `json:"contractNo_ends_with,omitempty"`
	ContractNoNotEndsWith   *string                        `json:"contractNo_not_ends_with,omitempty"`
	CompanyId               *int32                         `json:"companyId,omitempty"`
	CompanyIdNot            *int32                         `json:"companyId_not,omitempty"`
	CompanyIdIn             []int32                        `json:"companyId_in,omitempty"`
	CompanyIdNotIn          []int32                        `json:"companyId_not_in,omitempty"`
	CompanyIdLt             *int32                         `json:"companyId_lt,omitempty"`
	CompanyIdLte            *int32                         `json:"companyId_lte,omitempty"`
	CompanyIdGt             *int32                         `json:"companyId_gt,omitempty"`
	CompanyIdGte            *int32                         `json:"companyId_gte,omitempty"`
	ServiceCompanyId        *int32                         `json:"serviceCompanyId,omitempty"`
	ServiceCompanyIdNot     *int32                         `json:"serviceCompanyId_not,omitempty"`
	ServiceCompanyIdIn      []int32                        `json:"serviceCompanyId_in,omitempty"`
	ServiceCompanyIdNotIn   []int32                        `json:"serviceCompanyId_not_in,omitempty"`
	ServiceCompanyIdLt      *int32                         `json:"serviceCompanyId_lt,omitempty"`
	ServiceCompanyIdLte     *int32                         `json:"serviceCompanyId_lte,omitempty"`
	ServiceCompanyIdGt      *int32                         `json:"serviceCompanyId_gt,omitempty"`
	ServiceCompanyIdGte     *int32                         `json:"serviceCompanyId_gte,omitempty"`
	BeginTimestamp          *int32                         `json:"beginTimestamp,omitempty"`
	BeginTimestampNot       *int32                         `json:"beginTimestamp_not,omitempty"`
	BeginTimestampIn        []int32                        `json:"beginTimestamp_in,omitempty"`
	BeginTimestampNotIn     []int32                        `json:"beginTimestamp_not_in,omitempty"`
	BeginTimestampLt        *int32                         `json:"beginTimestamp_lt,omitempty"`
	BeginTimestampLte       *int32                         `json:"beginTimestamp_lte,omitempty"`
	BeginTimestampGt        *int32                         `json:"beginTimestamp_gt,omitempty"`
	BeginTimestampGte       *int32                         `json:"beginTimestamp_gte,omitempty"`
	EndTimestamp            *int32                         `json:"endTimestamp,omitempty"`
	EndTimestampNot         *int32                         `json:"endTimestamp_not,omitempty"`
	EndTimestampIn          []int32                        `json:"endTimestamp_in,omitempty"`
	EndTimestampNotIn       []int32                        `json:"endTimestamp_not_in,omitempty"`
	EndTimestampLt          *int32                         `json:"endTimestamp_lt,omitempty"`
	EndTimestampLte         *int32                         `json:"endTimestamp_lte,omitempty"`
	EndTimestampGt          *int32                         `json:"endTimestamp_gt,omitempty"`
	EndTimestampGte         *int32                         `json:"endTimestamp_gte,omitempty"`
	ActiveTimestamp         *int32                         `json:"activeTimestamp,omitempty"`
	ActiveTimestampNot      *int32                         `json:"activeTimestamp_not,omitempty"`
	ActiveTimestampIn       []int32                        `json:"activeTimestamp_in,omitempty"`
	ActiveTimestampNotIn    []int32                        `json:"activeTimestamp_not_in,omitempty"`
	ActiveTimestampLt       *int32                         `json:"activeTimestamp_lt,omitempty"`
	ActiveTimestampLte      *int32                         `json:"activeTimestamp_lte,omitempty"`
	ActiveTimestampGt       *int32                         `json:"activeTimestamp_gt,omitempty"`
	ActiveTimestampGte      *int32                         `json:"activeTimestamp_gte,omitempty"`
	IsHandled               *int32                         `json:"isHandled,omitempty"`
	IsHandledNot            *int32                         `json:"isHandled_not,omitempty"`
	IsHandledIn             []int32                        `json:"isHandled_in,omitempty"`
	IsHandledNotIn          []int32                        `json:"isHandled_not_in,omitempty"`
	IsHandledLt             *int32                         `json:"isHandled_lt,omitempty"`
	IsHandledLte            *int32                         `json:"isHandled_lte,omitempty"`
	IsHandledGt             *int32                         `json:"isHandled_gt,omitempty"`
	IsHandledGte            *int32                         `json:"isHandled_gte,omitempty"`
	Extend                  *string                        `json:"extend,omitempty"`
	ExtendNot               *string                        `json:"extend_not,omitempty"`
	ExtendIn                []string                       `json:"extend_in,omitempty"`
	ExtendNotIn             []string                       `json:"extend_not_in,omitempty"`
	ExtendLt                *string                        `json:"extend_lt,omitempty"`
	ExtendLte               *string                        `json:"extend_lte,omitempty"`
	ExtendGt                *string                        `json:"extend_gt,omitempty"`
	ExtendGte               *string                        `json:"extend_gte,omitempty"`
	ExtendContains          *string                        `json:"extend_contains,omitempty"`
	ExtendNotContains       *string                        `json:"extend_not_contains,omitempty"`
	ExtendStartsWith        *string                        `json:"extend_starts_with,omitempty"`
	ExtendNotStartsWith     *string                        `json:"extend_not_starts_with,omitempty"`
	ExtendEndsWith          *string                        `json:"extend_ends_with,omitempty"`
	ExtendNotEndsWith       *string                        `json:"extend_not_ends_with,omitempty"`
	Remark                  *string                        `json:"remark,omitempty"`
	RemarkNot               *string                        `json:"remark_not,omitempty"`
	RemarkIn                []string                       `json:"remark_in,omitempty"`
	RemarkNotIn             []string                       `json:"remark_not_in,omitempty"`
	RemarkLt                *string                        `json:"remark_lt,omitempty"`
	RemarkLte               *string                        `json:"remark_lte,omitempty"`
	RemarkGt                *string                        `json:"remark_gt,omitempty"`
	RemarkGte               *string                        `json:"remark_gte,omitempty"`
	RemarkContains          *string                        `json:"remark_contains,omitempty"`
	RemarkNotContains       *string                        `json:"remark_not_contains,omitempty"`
	RemarkStartsWith        *string                        `json:"remark_starts_with,omitempty"`
	RemarkNotStartsWith     *string                        `json:"remark_not_starts_with,omitempty"`
	RemarkEndsWith          *string                        `json:"remark_ends_with,omitempty"`
	RemarkNotEndsWith       *string                        `json:"remark_not_ends_with,omitempty"`
	CreatedAt               *string                        `json:"createdAt,omitempty"`
	CreatedAtNot            *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn             []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn          []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt             *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte            *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt             *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte            *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt               *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot            *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn             []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn          []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt             *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte            *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt             *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte            *string                        `json:"updatedAt_gte,omitempty"`
	DeletedAt               *int32                         `json:"deletedAt,omitempty"`
	DeletedAtNot            *int32                         `json:"deletedAt_not,omitempty"`
	DeletedAtIn             []int32                        `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn          []int32                        `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt             *int32                         `json:"deletedAt_lt,omitempty"`
	DeletedAtLte            *int32                         `json:"deletedAt_lte,omitempty"`
	DeletedAtGt             *int32                         `json:"deletedAt_gt,omitempty"`
	DeletedAtGte            *int32                         `json:"deletedAt_gte,omitempty"`
	And                     []JobContractJournalWhereInput `json:"AND,omitempty"`
	Or                      []JobContractJournalWhereInput `json:"OR,omitempty"`
	Not                     []JobContractJournalWhereInput `json:"NOT,omitempty"`
}

type JobMemberWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type JobMemberWhereInput struct {
	ID                         *int32                `json:"id,omitempty"`
	IDNot                      *int32                `json:"id_not,omitempty"`
	IDIn                       []int32               `json:"id_in,omitempty"`
	IDNotIn                    []int32               `json:"id_not_in,omitempty"`
	IDLt                       *int32                `json:"id_lt,omitempty"`
	IDLte                      *int32                `json:"id_lte,omitempty"`
	IDGt                       *int32                `json:"id_gt,omitempty"`
	IDGte                      *int32                `json:"id_gte,omitempty"`
	WorkId                     *int32                `json:"workId,omitempty"`
	WorkIdNot                  *int32                `json:"workId_not,omitempty"`
	WorkIdIn                   []int32               `json:"workId_in,omitempty"`
	WorkIdNotIn                []int32               `json:"workId_not_in,omitempty"`
	WorkIdLt                   *int32                `json:"workId_lt,omitempty"`
	WorkIdLte                  *int32                `json:"workId_lte,omitempty"`
	WorkIdGt                   *int32                `json:"workId_gt,omitempty"`
	WorkIdGte                  *int32                `json:"workId_gte,omitempty"`
	CompanyId                  *int32                `json:"companyId,omitempty"`
	CompanyIdNot               *int32                `json:"companyId_not,omitempty"`
	CompanyIdIn                []int32               `json:"companyId_in,omitempty"`
	CompanyIdNotIn             []int32               `json:"companyId_not_in,omitempty"`
	CompanyIdLt                *int32                `json:"companyId_lt,omitempty"`
	CompanyIdLte               *int32                `json:"companyId_lte,omitempty"`
	CompanyIdGt                *int32                `json:"companyId_gt,omitempty"`
	CompanyIdGte               *int32                `json:"companyId_gte,omitempty"`
	PublisherId                *string               `json:"publisherId,omitempty"`
	PublisherIdNot             *string               `json:"publisherId_not,omitempty"`
	PublisherIdIn              []string              `json:"publisherId_in,omitempty"`
	PublisherIdNotIn           []string              `json:"publisherId_not_in,omitempty"`
	PublisherIdLt              *string               `json:"publisherId_lt,omitempty"`
	PublisherIdLte             *string               `json:"publisherId_lte,omitempty"`
	PublisherIdGt              *string               `json:"publisherId_gt,omitempty"`
	PublisherIdGte             *string               `json:"publisherId_gte,omitempty"`
	PublisherIdContains        *string               `json:"publisherId_contains,omitempty"`
	PublisherIdNotContains     *string               `json:"publisherId_not_contains,omitempty"`
	PublisherIdStartsWith      *string               `json:"publisherId_starts_with,omitempty"`
	PublisherIdNotStartsWith   *string               `json:"publisherId_not_starts_with,omitempty"`
	PublisherIdEndsWith        *string               `json:"publisherId_ends_with,omitempty"`
	PublisherIdNotEndsWith     *string               `json:"publisherId_not_ends_with,omitempty"`
	ParticipantId              *string               `json:"participantId,omitempty"`
	ParticipantIdNot           *string               `json:"participantId_not,omitempty"`
	ParticipantIdIn            []string              `json:"participantId_in,omitempty"`
	ParticipantIdNotIn         []string              `json:"participantId_not_in,omitempty"`
	ParticipantIdLt            *string               `json:"participantId_lt,omitempty"`
	ParticipantIdLte           *string               `json:"participantId_lte,omitempty"`
	ParticipantIdGt            *string               `json:"participantId_gt,omitempty"`
	ParticipantIdGte           *string               `json:"participantId_gte,omitempty"`
	ParticipantIdContains      *string               `json:"participantId_contains,omitempty"`
	ParticipantIdNotContains   *string               `json:"participantId_not_contains,omitempty"`
	ParticipantIdStartsWith    *string               `json:"participantId_starts_with,omitempty"`
	ParticipantIdNotStartsWith *string               `json:"participantId_not_starts_with,omitempty"`
	ParticipantIdEndsWith      *string               `json:"participantId_ends_with,omitempty"`
	ParticipantIdNotEndsWith   *string               `json:"participantId_not_ends_with,omitempty"`
	Source                     *int32                `json:"source,omitempty"`
	SourceNot                  *int32                `json:"source_not,omitempty"`
	SourceIn                   []int32               `json:"source_in,omitempty"`
	SourceNotIn                []int32               `json:"source_not_in,omitempty"`
	SourceLt                   *int32                `json:"source_lt,omitempty"`
	SourceLte                  *int32                `json:"source_lte,omitempty"`
	SourceGt                   *int32                `json:"source_gt,omitempty"`
	SourceGte                  *int32                `json:"source_gte,omitempty"`
	Progress                   *int32                `json:"progress,omitempty"`
	ProgressNot                *int32                `json:"progress_not,omitempty"`
	ProgressIn                 []int32               `json:"progress_in,omitempty"`
	ProgressNotIn              []int32               `json:"progress_not_in,omitempty"`
	ProgressLt                 *int32                `json:"progress_lt,omitempty"`
	ProgressLte                *int32                `json:"progress_lte,omitempty"`
	ProgressGt                 *int32                `json:"progress_gt,omitempty"`
	ProgressGte                *int32                `json:"progress_gte,omitempty"`
	ProofFileUrl               *string               `json:"proofFileUrl,omitempty"`
	ProofFileUrlNot            *string               `json:"proofFileUrl_not,omitempty"`
	ProofFileUrlIn             []string              `json:"proofFileUrl_in,omitempty"`
	ProofFileUrlNotIn          []string              `json:"proofFileUrl_not_in,omitempty"`
	ProofFileUrlLt             *string               `json:"proofFileUrl_lt,omitempty"`
	ProofFileUrlLte            *string               `json:"proofFileUrl_lte,omitempty"`
	ProofFileUrlGt             *string               `json:"proofFileUrl_gt,omitempty"`
	ProofFileUrlGte            *string               `json:"proofFileUrl_gte,omitempty"`
	ProofFileUrlContains       *string               `json:"proofFileUrl_contains,omitempty"`
	ProofFileUrlNotContains    *string               `json:"proofFileUrl_not_contains,omitempty"`
	ProofFileUrlStartsWith     *string               `json:"proofFileUrl_starts_with,omitempty"`
	ProofFileUrlNotStartsWith  *string               `json:"proofFileUrl_not_starts_with,omitempty"`
	ProofFileUrlEndsWith       *string               `json:"proofFileUrl_ends_with,omitempty"`
	ProofFileUrlNotEndsWith    *string               `json:"proofFileUrl_not_ends_with,omitempty"`
	Reward                     *float64              `json:"reward,omitempty"`
	RewardNot                  *float64              `json:"reward_not,omitempty"`
	RewardIn                   []float64             `json:"reward_in,omitempty"`
	RewardNotIn                []float64             `json:"reward_not_in,omitempty"`
	RewardLt                   *float64              `json:"reward_lt,omitempty"`
	RewardLte                  *float64              `json:"reward_lte,omitempty"`
	RewardGt                   *float64              `json:"reward_gt,omitempty"`
	RewardGte                  *float64              `json:"reward_gte,omitempty"`
	ParticipateAt              *int32                `json:"participateAt,omitempty"`
	ParticipateAtNot           *int32                `json:"participateAt_not,omitempty"`
	ParticipateAtIn            []int32               `json:"participateAt_in,omitempty"`
	ParticipateAtNotIn         []int32               `json:"participateAt_not_in,omitempty"`
	ParticipateAtLt            *int32                `json:"participateAt_lt,omitempty"`
	ParticipateAtLte           *int32                `json:"participateAt_lte,omitempty"`
	ParticipateAtGt            *int32                `json:"participateAt_gt,omitempty"`
	ParticipateAtGte           *int32                `json:"participateAt_gte,omitempty"`
	FinishAt                   *int32                `json:"finishAt,omitempty"`
	FinishAtNot                *int32                `json:"finishAt_not,omitempty"`
	FinishAtIn                 []int32               `json:"finishAt_in,omitempty"`
	FinishAtNotIn              []int32               `json:"finishAt_not_in,omitempty"`
	FinishAtLt                 *int32                `json:"finishAt_lt,omitempty"`
	FinishAtLte                *int32                `json:"finishAt_lte,omitempty"`
	FinishAtGt                 *int32                `json:"finishAt_gt,omitempty"`
	FinishAtGte                *int32                `json:"finishAt_gte,omitempty"`
	Remark                     *string               `json:"remark,omitempty"`
	RemarkNot                  *string               `json:"remark_not,omitempty"`
	RemarkIn                   []string              `json:"remark_in,omitempty"`
	RemarkNotIn                []string              `json:"remark_not_in,omitempty"`
	RemarkLt                   *string               `json:"remark_lt,omitempty"`
	RemarkLte                  *string               `json:"remark_lte,omitempty"`
	RemarkGt                   *string               `json:"remark_gt,omitempty"`
	RemarkGte                  *string               `json:"remark_gte,omitempty"`
	RemarkContains             *string               `json:"remark_contains,omitempty"`
	RemarkNotContains          *string               `json:"remark_not_contains,omitempty"`
	RemarkStartsWith           *string               `json:"remark_starts_with,omitempty"`
	RemarkNotStartsWith        *string               `json:"remark_not_starts_with,omitempty"`
	RemarkEndsWith             *string               `json:"remark_ends_with,omitempty"`
	RemarkNotEndsWith          *string               `json:"remark_not_ends_with,omitempty"`
	Extend                     *string               `json:"extend,omitempty"`
	ExtendNot                  *string               `json:"extend_not,omitempty"`
	ExtendIn                   []string              `json:"extend_in,omitempty"`
	ExtendNotIn                []string              `json:"extend_not_in,omitempty"`
	ExtendLt                   *string               `json:"extend_lt,omitempty"`
	ExtendLte                  *string               `json:"extend_lte,omitempty"`
	ExtendGt                   *string               `json:"extend_gt,omitempty"`
	ExtendGte                  *string               `json:"extend_gte,omitempty"`
	ExtendContains             *string               `json:"extend_contains,omitempty"`
	ExtendNotContains          *string               `json:"extend_not_contains,omitempty"`
	ExtendStartsWith           *string               `json:"extend_starts_with,omitempty"`
	ExtendNotStartsWith        *string               `json:"extend_not_starts_with,omitempty"`
	ExtendEndsWith             *string               `json:"extend_ends_with,omitempty"`
	ExtendNotEndsWith          *string               `json:"extend_not_ends_with,omitempty"`
	CreatedAt                  *string               `json:"createdAt,omitempty"`
	CreatedAtNot               *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string               `json:"updatedAt_gte,omitempty"`
	DeletedAt                  *int32                `json:"deletedAt,omitempty"`
	DeletedAtNot               *int32                `json:"deletedAt_not,omitempty"`
	DeletedAtIn                []int32               `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn             []int32               `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt                *int32                `json:"deletedAt_lt,omitempty"`
	DeletedAtLte               *int32                `json:"deletedAt_lte,omitempty"`
	DeletedAtGt                *int32                `json:"deletedAt_gt,omitempty"`
	DeletedAtGte               *int32                `json:"deletedAt_gte,omitempty"`
	And                        []JobMemberWhereInput `json:"AND,omitempty"`
	Or                         []JobMemberWhereInput `json:"OR,omitempty"`
	Not                        []JobMemberWhereInput `json:"NOT,omitempty"`
}

type JobTemplateWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type JobTemplateWhereInput struct {
	ID                              *int32                  `json:"id,omitempty"`
	IDNot                           *int32                  `json:"id_not,omitempty"`
	IDIn                            []int32                 `json:"id_in,omitempty"`
	IDNotIn                         []int32                 `json:"id_not_in,omitempty"`
	IDLt                            *int32                  `json:"id_lt,omitempty"`
	IDLte                           *int32                  `json:"id_lte,omitempty"`
	IDGt                            *int32                  `json:"id_gt,omitempty"`
	IDGte                           *int32                  `json:"id_gte,omitempty"`
	AppId                           *string                 `json:"appId,omitempty"`
	AppIdNot                        *string                 `json:"appId_not,omitempty"`
	AppIdIn                         []string                `json:"appId_in,omitempty"`
	AppIdNotIn                      []string                `json:"appId_not_in,omitempty"`
	AppIdLt                         *string                 `json:"appId_lt,omitempty"`
	AppIdLte                        *string                 `json:"appId_lte,omitempty"`
	AppIdGt                         *string                 `json:"appId_gt,omitempty"`
	AppIdGte                        *string                 `json:"appId_gte,omitempty"`
	AppIdContains                   *string                 `json:"appId_contains,omitempty"`
	AppIdNotContains                *string                 `json:"appId_not_contains,omitempty"`
	AppIdStartsWith                 *string                 `json:"appId_starts_with,omitempty"`
	AppIdNotStartsWith              *string                 `json:"appId_not_starts_with,omitempty"`
	AppIdEndsWith                   *string                 `json:"appId_ends_with,omitempty"`
	AppIdNotEndsWith                *string                 `json:"appId_not_ends_with,omitempty"`
	PlatformAppid                   *string                 `json:"platformAppid,omitempty"`
	PlatformAppidNot                *string                 `json:"platformAppid_not,omitempty"`
	PlatformAppidIn                 []string                `json:"platformAppid_in,omitempty"`
	PlatformAppidNotIn              []string                `json:"platformAppid_not_in,omitempty"`
	PlatformAppidLt                 *string                 `json:"platformAppid_lt,omitempty"`
	PlatformAppidLte                *string                 `json:"platformAppid_lte,omitempty"`
	PlatformAppidGt                 *string                 `json:"platformAppid_gt,omitempty"`
	PlatformAppidGte                *string                 `json:"platformAppid_gte,omitempty"`
	PlatformAppidContains           *string                 `json:"platformAppid_contains,omitempty"`
	PlatformAppidNotContains        *string                 `json:"platformAppid_not_contains,omitempty"`
	PlatformAppidStartsWith         *string                 `json:"platformAppid_starts_with,omitempty"`
	PlatformAppidNotStartsWith      *string                 `json:"platformAppid_not_starts_with,omitempty"`
	PlatformAppidEndsWith           *string                 `json:"platformAppid_ends_with,omitempty"`
	PlatformAppidNotEndsWith        *string                 `json:"platformAppid_not_ends_with,omitempty"`
	CompanyId                       *int32                  `json:"companyId,omitempty"`
	CompanyIdNot                    *int32                  `json:"companyId_not,omitempty"`
	CompanyIdIn                     []int32                 `json:"companyId_in,omitempty"`
	CompanyIdNotIn                  []int32                 `json:"companyId_not_in,omitempty"`
	CompanyIdLt                     *int32                  `json:"companyId_lt,omitempty"`
	CompanyIdLte                    *int32                  `json:"companyId_lte,omitempty"`
	CompanyIdGt                     *int32                  `json:"companyId_gt,omitempty"`
	CompanyIdGte                    *int32                  `json:"companyId_gte,omitempty"`
	CompanyName                     *string                 `json:"companyName,omitempty"`
	CompanyNameNot                  *string                 `json:"companyName_not,omitempty"`
	CompanyNameIn                   []string                `json:"companyName_in,omitempty"`
	CompanyNameNotIn                []string                `json:"companyName_not_in,omitempty"`
	CompanyNameLt                   *string                 `json:"companyName_lt,omitempty"`
	CompanyNameLte                  *string                 `json:"companyName_lte,omitempty"`
	CompanyNameGt                   *string                 `json:"companyName_gt,omitempty"`
	CompanyNameGte                  *string                 `json:"companyName_gte,omitempty"`
	CompanyNameContains             *string                 `json:"companyName_contains,omitempty"`
	CompanyNameNotContains          *string                 `json:"companyName_not_contains,omitempty"`
	CompanyNameStartsWith           *string                 `json:"companyName_starts_with,omitempty"`
	CompanyNameNotStartsWith        *string                 `json:"companyName_not_starts_with,omitempty"`
	CompanyNameEndsWith             *string                 `json:"companyName_ends_with,omitempty"`
	CompanyNameNotEndsWith          *string                 `json:"companyName_not_ends_with,omitempty"`
	ServiceCompanyId                *int32                  `json:"serviceCompanyId,omitempty"`
	ServiceCompanyIdNot             *int32                  `json:"serviceCompanyId_not,omitempty"`
	ServiceCompanyIdIn              []int32                 `json:"serviceCompanyId_in,omitempty"`
	ServiceCompanyIdNotIn           []int32                 `json:"serviceCompanyId_not_in,omitempty"`
	ServiceCompanyIdLt              *int32                  `json:"serviceCompanyId_lt,omitempty"`
	ServiceCompanyIdLte             *int32                  `json:"serviceCompanyId_lte,omitempty"`
	ServiceCompanyIdGt              *int32                  `json:"serviceCompanyId_gt,omitempty"`
	ServiceCompanyIdGte             *int32                  `json:"serviceCompanyId_gte,omitempty"`
	ServiceCompanyName              *string                 `json:"serviceCompanyName,omitempty"`
	ServiceCompanyNameNot           *string                 `json:"serviceCompanyName_not,omitempty"`
	ServiceCompanyNameIn            []string                `json:"serviceCompanyName_in,omitempty"`
	ServiceCompanyNameNotIn         []string                `json:"serviceCompanyName_not_in,omitempty"`
	ServiceCompanyNameLt            *string                 `json:"serviceCompanyName_lt,omitempty"`
	ServiceCompanyNameLte           *string                 `json:"serviceCompanyName_lte,omitempty"`
	ServiceCompanyNameGt            *string                 `json:"serviceCompanyName_gt,omitempty"`
	ServiceCompanyNameGte           *string                 `json:"serviceCompanyName_gte,omitempty"`
	ServiceCompanyNameContains      *string                 `json:"serviceCompanyName_contains,omitempty"`
	ServiceCompanyNameNotContains   *string                 `json:"serviceCompanyName_not_contains,omitempty"`
	ServiceCompanyNameStartsWith    *string                 `json:"serviceCompanyName_starts_with,omitempty"`
	ServiceCompanyNameNotStartsWith *string                 `json:"serviceCompanyName_not_starts_with,omitempty"`
	ServiceCompanyNameEndsWith      *string                 `json:"serviceCompanyName_ends_with,omitempty"`
	ServiceCompanyNameNotEndsWith   *string                 `json:"serviceCompanyName_not_ends_with,omitempty"`
	UserId                          *string                 `json:"userId,omitempty"`
	UserIdNot                       *string                 `json:"userId_not,omitempty"`
	UserIdIn                        []string                `json:"userId_in,omitempty"`
	UserIdNotIn                     []string                `json:"userId_not_in,omitempty"`
	UserIdLt                        *string                 `json:"userId_lt,omitempty"`
	UserIdLte                       *string                 `json:"userId_lte,omitempty"`
	UserIdGt                        *string                 `json:"userId_gt,omitempty"`
	UserIdGte                       *string                 `json:"userId_gte,omitempty"`
	UserIdContains                  *string                 `json:"userId_contains,omitempty"`
	UserIdNotContains               *string                 `json:"userId_not_contains,omitempty"`
	UserIdStartsWith                *string                 `json:"userId_starts_with,omitempty"`
	UserIdNotStartsWith             *string                 `json:"userId_not_starts_with,omitempty"`
	UserIdEndsWith                  *string                 `json:"userId_ends_with,omitempty"`
	UserIdNotEndsWith               *string                 `json:"userId_not_ends_with,omitempty"`
	WorkType                        *int32                  `json:"workType,omitempty"`
	WorkTypeNot                     *int32                  `json:"workType_not,omitempty"`
	WorkTypeIn                      []int32                 `json:"workType_in,omitempty"`
	WorkTypeNotIn                   []int32                 `json:"workType_not_in,omitempty"`
	WorkTypeLt                      *int32                  `json:"workType_lt,omitempty"`
	WorkTypeLte                     *int32                  `json:"workType_lte,omitempty"`
	WorkTypeGt                      *int32                  `json:"workType_gt,omitempty"`
	WorkTypeGte                     *int32                  `json:"workType_gte,omitempty"`
	SignTemplateId                  *int32                  `json:"signTemplateId,omitempty"`
	SignTemplateIdNot               *int32                  `json:"signTemplateId_not,omitempty"`
	SignTemplateIdIn                []int32                 `json:"signTemplateId_in,omitempty"`
	SignTemplateIdNotIn             []int32                 `json:"signTemplateId_not_in,omitempty"`
	SignTemplateIdLt                *int32                  `json:"signTemplateId_lt,omitempty"`
	SignTemplateIdLte               *int32                  `json:"signTemplateId_lte,omitempty"`
	SignTemplateIdGt                *int32                  `json:"signTemplateId_gt,omitempty"`
	SignTemplateIdGte               *int32                  `json:"signTemplateId_gte,omitempty"`
	ServiceTypeId                   *int32                  `json:"serviceTypeId,omitempty"`
	ServiceTypeIdNot                *int32                  `json:"serviceTypeId_not,omitempty"`
	ServiceTypeIdIn                 []int32                 `json:"serviceTypeId_in,omitempty"`
	ServiceTypeIdNotIn              []int32                 `json:"serviceTypeId_not_in,omitempty"`
	ServiceTypeIdLt                 *int32                  `json:"serviceTypeId_lt,omitempty"`
	ServiceTypeIdLte                *int32                  `json:"serviceTypeId_lte,omitempty"`
	ServiceTypeIdGt                 *int32                  `json:"serviceTypeId_gt,omitempty"`
	ServiceTypeIdGte                *int32                  `json:"serviceTypeId_gte,omitempty"`
	ServiceTypeName                 *string                 `json:"serviceTypeName,omitempty"`
	ServiceTypeNameNot              *string                 `json:"serviceTypeName_not,omitempty"`
	ServiceTypeNameIn               []string                `json:"serviceTypeName_in,omitempty"`
	ServiceTypeNameNotIn            []string                `json:"serviceTypeName_not_in,omitempty"`
	ServiceTypeNameLt               *string                 `json:"serviceTypeName_lt,omitempty"`
	ServiceTypeNameLte              *string                 `json:"serviceTypeName_lte,omitempty"`
	ServiceTypeNameGt               *string                 `json:"serviceTypeName_gt,omitempty"`
	ServiceTypeNameGte              *string                 `json:"serviceTypeName_gte,omitempty"`
	ServiceTypeNameContains         *string                 `json:"serviceTypeName_contains,omitempty"`
	ServiceTypeNameNotContains      *string                 `json:"serviceTypeName_not_contains,omitempty"`
	ServiceTypeNameStartsWith       *string                 `json:"serviceTypeName_starts_with,omitempty"`
	ServiceTypeNameNotStartsWith    *string                 `json:"serviceTypeName_not_starts_with,omitempty"`
	ServiceTypeNameEndsWith         *string                 `json:"serviceTypeName_ends_with,omitempty"`
	ServiceTypeNameNotEndsWith      *string                 `json:"serviceTypeName_not_ends_with,omitempty"`
	Name                            *string                 `json:"name,omitempty"`
	NameNot                         *string                 `json:"name_not,omitempty"`
	NameIn                          []string                `json:"name_in,omitempty"`
	NameNotIn                       []string                `json:"name_not_in,omitempty"`
	NameLt                          *string                 `json:"name_lt,omitempty"`
	NameLte                         *string                 `json:"name_lte,omitempty"`
	NameGt                          *string                 `json:"name_gt,omitempty"`
	NameGte                         *string                 `json:"name_gte,omitempty"`
	NameContains                    *string                 `json:"name_contains,omitempty"`
	NameNotContains                 *string                 `json:"name_not_contains,omitempty"`
	NameStartsWith                  *string                 `json:"name_starts_with,omitempty"`
	NameNotStartsWith               *string                 `json:"name_not_starts_with,omitempty"`
	NameEndsWith                    *string                 `json:"name_ends_with,omitempty"`
	NameNotEndsWith                 *string                 `json:"name_not_ends_with,omitempty"`
	Requirement                     *string                 `json:"requirement,omitempty"`
	RequirementNot                  *string                 `json:"requirement_not,omitempty"`
	RequirementIn                   []string                `json:"requirement_in,omitempty"`
	RequirementNotIn                []string                `json:"requirement_not_in,omitempty"`
	RequirementLt                   *string                 `json:"requirement_lt,omitempty"`
	RequirementLte                  *string                 `json:"requirement_lte,omitempty"`
	RequirementGt                   *string                 `json:"requirement_gt,omitempty"`
	RequirementGte                  *string                 `json:"requirement_gte,omitempty"`
	RequirementContains             *string                 `json:"requirement_contains,omitempty"`
	RequirementNotContains          *string                 `json:"requirement_not_contains,omitempty"`
	RequirementStartsWith           *string                 `json:"requirement_starts_with,omitempty"`
	RequirementNotStartsWith        *string                 `json:"requirement_not_starts_with,omitempty"`
	RequirementEndsWith             *string                 `json:"requirement_ends_with,omitempty"`
	RequirementNotEndsWith          *string                 `json:"requirement_not_ends_with,omitempty"`
	SettlementRule                  *string                 `json:"settlementRule,omitempty"`
	SettlementRuleNot               *string                 `json:"settlementRule_not,omitempty"`
	SettlementRuleIn                []string                `json:"settlementRule_in,omitempty"`
	SettlementRuleNotIn             []string                `json:"settlementRule_not_in,omitempty"`
	SettlementRuleLt                *string                 `json:"settlementRule_lt,omitempty"`
	SettlementRuleLte               *string                 `json:"settlementRule_lte,omitempty"`
	SettlementRuleGt                *string                 `json:"settlementRule_gt,omitempty"`
	SettlementRuleGte               *string                 `json:"settlementRule_gte,omitempty"`
	SettlementRuleContains          *string                 `json:"settlementRule_contains,omitempty"`
	SettlementRuleNotContains       *string                 `json:"settlementRule_not_contains,omitempty"`
	SettlementRuleStartsWith        *string                 `json:"settlementRule_starts_with,omitempty"`
	SettlementRuleNotStartsWith     *string                 `json:"settlementRule_not_starts_with,omitempty"`
	SettlementRuleEndsWith          *string                 `json:"settlementRule_ends_with,omitempty"`
	SettlementRuleNotEndsWith       *string                 `json:"settlementRule_not_ends_with,omitempty"`
	KpiTemplateUrl                  *string                 `json:"kpiTemplateUrl,omitempty"`
	KpiTemplateUrlNot               *string                 `json:"kpiTemplateUrl_not,omitempty"`
	KpiTemplateUrlIn                []string                `json:"kpiTemplateUrl_in,omitempty"`
	KpiTemplateUrlNotIn             []string                `json:"kpiTemplateUrl_not_in,omitempty"`
	KpiTemplateUrlLt                *string                 `json:"kpiTemplateUrl_lt,omitempty"`
	KpiTemplateUrlLte               *string                 `json:"kpiTemplateUrl_lte,omitempty"`
	KpiTemplateUrlGt                *string                 `json:"kpiTemplateUrl_gt,omitempty"`
	KpiTemplateUrlGte               *string                 `json:"kpiTemplateUrl_gte,omitempty"`
	KpiTemplateUrlContains          *string                 `json:"kpiTemplateUrl_contains,omitempty"`
	KpiTemplateUrlNotContains       *string                 `json:"kpiTemplateUrl_not_contains,omitempty"`
	KpiTemplateUrlStartsWith        *string                 `json:"kpiTemplateUrl_starts_with,omitempty"`
	KpiTemplateUrlNotStartsWith     *string                 `json:"kpiTemplateUrl_not_starts_with,omitempty"`
	KpiTemplateUrlEndsWith          *string                 `json:"kpiTemplateUrl_ends_with,omitempty"`
	KpiTemplateUrlNotEndsWith       *string                 `json:"kpiTemplateUrl_not_ends_with,omitempty"`
	DownloadCode                    *string                 `json:"downloadCode,omitempty"`
	DownloadCodeNot                 *string                 `json:"downloadCode_not,omitempty"`
	DownloadCodeIn                  []string                `json:"downloadCode_in,omitempty"`
	DownloadCodeNotIn               []string                `json:"downloadCode_not_in,omitempty"`
	DownloadCodeLt                  *string                 `json:"downloadCode_lt,omitempty"`
	DownloadCodeLte                 *string                 `json:"downloadCode_lte,omitempty"`
	DownloadCodeGt                  *string                 `json:"downloadCode_gt,omitempty"`
	DownloadCodeGte                 *string                 `json:"downloadCode_gte,omitempty"`
	DownloadCodeContains            *string                 `json:"downloadCode_contains,omitempty"`
	DownloadCodeNotContains         *string                 `json:"downloadCode_not_contains,omitempty"`
	DownloadCodeStartsWith          *string                 `json:"downloadCode_starts_with,omitempty"`
	DownloadCodeNotStartsWith       *string                 `json:"downloadCode_not_starts_with,omitempty"`
	DownloadCodeEndsWith            *string                 `json:"downloadCode_ends_with,omitempty"`
	DownloadCodeNotEndsWith         *string                 `json:"downloadCode_not_ends_with,omitempty"`
	DisplayName                     *string                 `json:"displayName,omitempty"`
	DisplayNameNot                  *string                 `json:"displayName_not,omitempty"`
	DisplayNameIn                   []string                `json:"displayName_in,omitempty"`
	DisplayNameNotIn                []string                `json:"displayName_not_in,omitempty"`
	DisplayNameLt                   *string                 `json:"displayName_lt,omitempty"`
	DisplayNameLte                  *string                 `json:"displayName_lte,omitempty"`
	DisplayNameGt                   *string                 `json:"displayName_gt,omitempty"`
	DisplayNameGte                  *string                 `json:"displayName_gte,omitempty"`
	DisplayNameContains             *string                 `json:"displayName_contains,omitempty"`
	DisplayNameNotContains          *string                 `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith           *string                 `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith        *string                 `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith             *string                 `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith          *string                 `json:"displayName_not_ends_with,omitempty"`
	IsEnable                        *int32                  `json:"isEnable,omitempty"`
	IsEnableNot                     *int32                  `json:"isEnable_not,omitempty"`
	IsEnableIn                      []int32                 `json:"isEnable_in,omitempty"`
	IsEnableNotIn                   []int32                 `json:"isEnable_not_in,omitempty"`
	IsEnableLt                      *int32                  `json:"isEnable_lt,omitempty"`
	IsEnableLte                     *int32                  `json:"isEnable_lte,omitempty"`
	IsEnableGt                      *int32                  `json:"isEnable_gt,omitempty"`
	IsEnableGte                     *int32                  `json:"isEnable_gte,omitempty"`
	Source                          *int32                  `json:"source,omitempty"`
	SourceNot                       *int32                  `json:"source_not,omitempty"`
	SourceIn                        []int32                 `json:"source_in,omitempty"`
	SourceNotIn                     []int32                 `json:"source_not_in,omitempty"`
	SourceLt                        *int32                  `json:"source_lt,omitempty"`
	SourceLte                       *int32                  `json:"source_lte,omitempty"`
	SourceGt                        *int32                  `json:"source_gt,omitempty"`
	SourceGte                       *int32                  `json:"source_gte,omitempty"`
	Extend                          *string                 `json:"extend,omitempty"`
	ExtendNot                       *string                 `json:"extend_not,omitempty"`
	ExtendIn                        []string                `json:"extend_in,omitempty"`
	ExtendNotIn                     []string                `json:"extend_not_in,omitempty"`
	ExtendLt                        *string                 `json:"extend_lt,omitempty"`
	ExtendLte                       *string                 `json:"extend_lte,omitempty"`
	ExtendGt                        *string                 `json:"extend_gt,omitempty"`
	ExtendGte                       *string                 `json:"extend_gte,omitempty"`
	ExtendContains                  *string                 `json:"extend_contains,omitempty"`
	ExtendNotContains               *string                 `json:"extend_not_contains,omitempty"`
	ExtendStartsWith                *string                 `json:"extend_starts_with,omitempty"`
	ExtendNotStartsWith             *string                 `json:"extend_not_starts_with,omitempty"`
	ExtendEndsWith                  *string                 `json:"extend_ends_with,omitempty"`
	ExtendNotEndsWith               *string                 `json:"extend_not_ends_with,omitempty"`
	BizContent                      *string                 `json:"bizContent,omitempty"`
	BizContentNot                   *string                 `json:"bizContent_not,omitempty"`
	BizContentIn                    []string                `json:"bizContent_in,omitempty"`
	BizContentNotIn                 []string                `json:"bizContent_not_in,omitempty"`
	BizContentLt                    *string                 `json:"bizContent_lt,omitempty"`
	BizContentLte                   *string                 `json:"bizContent_lte,omitempty"`
	BizContentGt                    *string                 `json:"bizContent_gt,omitempty"`
	BizContentGte                   *string                 `json:"bizContent_gte,omitempty"`
	BizContentContains              *string                 `json:"bizContent_contains,omitempty"`
	BizContentNotContains           *string                 `json:"bizContent_not_contains,omitempty"`
	BizContentStartsWith            *string                 `json:"bizContent_starts_with,omitempty"`
	BizContentNotStartsWith         *string                 `json:"bizContent_not_starts_with,omitempty"`
	BizContentEndsWith              *string                 `json:"bizContent_ends_with,omitempty"`
	BizContentNotEndsWith           *string                 `json:"bizContent_not_ends_with,omitempty"`
	Remark                          *string                 `json:"remark,omitempty"`
	RemarkNot                       *string                 `json:"remark_not,omitempty"`
	RemarkIn                        []string                `json:"remark_in,omitempty"`
	RemarkNotIn                     []string                `json:"remark_not_in,omitempty"`
	RemarkLt                        *string                 `json:"remark_lt,omitempty"`
	RemarkLte                       *string                 `json:"remark_lte,omitempty"`
	RemarkGt                        *string                 `json:"remark_gt,omitempty"`
	RemarkGte                       *string                 `json:"remark_gte,omitempty"`
	RemarkContains                  *string                 `json:"remark_contains,omitempty"`
	RemarkNotContains               *string                 `json:"remark_not_contains,omitempty"`
	RemarkStartsWith                *string                 `json:"remark_starts_with,omitempty"`
	RemarkNotStartsWith             *string                 `json:"remark_not_starts_with,omitempty"`
	RemarkEndsWith                  *string                 `json:"remark_ends_with,omitempty"`
	RemarkNotEndsWith               *string                 `json:"remark_not_ends_with,omitempty"`
	ContractNo                      *string                 `json:"contractNo,omitempty"`
	ContractNoNot                   *string                 `json:"contractNo_not,omitempty"`
	ContractNoIn                    []string                `json:"contractNo_in,omitempty"`
	ContractNoNotIn                 []string                `json:"contractNo_not_in,omitempty"`
	ContractNoLt                    *string                 `json:"contractNo_lt,omitempty"`
	ContractNoLte                   *string                 `json:"contractNo_lte,omitempty"`
	ContractNoGt                    *string                 `json:"contractNo_gt,omitempty"`
	ContractNoGte                   *string                 `json:"contractNo_gte,omitempty"`
	ContractNoContains              *string                 `json:"contractNo_contains,omitempty"`
	ContractNoNotContains           *string                 `json:"contractNo_not_contains,omitempty"`
	ContractNoStartsWith            *string                 `json:"contractNo_starts_with,omitempty"`
	ContractNoNotStartsWith         *string                 `json:"contractNo_not_starts_with,omitempty"`
	ContractNoEndsWith              *string                 `json:"contractNo_ends_with,omitempty"`
	ContractNoNotEndsWith           *string                 `json:"contractNo_not_ends_with,omitempty"`
	CreatedAt                       *string                 `json:"createdAt,omitempty"`
	CreatedAtNot                    *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn                     []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                  []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                     *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte                    *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt                     *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte                    *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt                       *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot                    *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                     []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                  []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                     *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                    *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                     *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                    *string                 `json:"updatedAt_gte,omitempty"`
	DeletedAt                       *int32                  `json:"deletedAt,omitempty"`
	DeletedAtNot                    *int32                  `json:"deletedAt_not,omitempty"`
	DeletedAtIn                     []int32                 `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn                  []int32                 `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt                     *int32                  `json:"deletedAt_lt,omitempty"`
	DeletedAtLte                    *int32                  `json:"deletedAt_lte,omitempty"`
	DeletedAtGt                     *int32                  `json:"deletedAt_gt,omitempty"`
	DeletedAtGte                    *int32                  `json:"deletedAt_gte,omitempty"`
	And                             []JobTemplateWhereInput `json:"AND,omitempty"`
	Or                              []JobTemplateWhereInput `json:"OR,omitempty"`
	Not                             []JobTemplateWhereInput `json:"NOT,omitempty"`
}

type JobTemplateDelayWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type JobTemplateDelayWhereInput struct {
	ID                      *int32                       `json:"id,omitempty"`
	IDNot                   *int32                       `json:"id_not,omitempty"`
	IDIn                    []int32                      `json:"id_in,omitempty"`
	IDNotIn                 []int32                      `json:"id_not_in,omitempty"`
	IDLt                    *int32                       `json:"id_lt,omitempty"`
	IDLte                   *int32                       `json:"id_lte,omitempty"`
	IDGt                    *int32                       `json:"id_gt,omitempty"`
	IDGte                   *int32                       `json:"id_gte,omitempty"`
	ContractNo              *string                      `json:"contractNo,omitempty"`
	ContractNoNot           *string                      `json:"contractNo_not,omitempty"`
	ContractNoIn            []string                     `json:"contractNo_in,omitempty"`
	ContractNoNotIn         []string                     `json:"contractNo_not_in,omitempty"`
	ContractNoLt            *string                      `json:"contractNo_lt,omitempty"`
	ContractNoLte           *string                      `json:"contractNo_lte,omitempty"`
	ContractNoGt            *string                      `json:"contractNo_gt,omitempty"`
	ContractNoGte           *string                      `json:"contractNo_gte,omitempty"`
	ContractNoContains      *string                      `json:"contractNo_contains,omitempty"`
	ContractNoNotContains   *string                      `json:"contractNo_not_contains,omitempty"`
	ContractNoStartsWith    *string                      `json:"contractNo_starts_with,omitempty"`
	ContractNoNotStartsWith *string                      `json:"contractNo_not_starts_with,omitempty"`
	ContractNoEndsWith      *string                      `json:"contractNo_ends_with,omitempty"`
	ContractNoNotEndsWith   *string                      `json:"contractNo_not_ends_with,omitempty"`
	CompanyId               *int32                       `json:"companyId,omitempty"`
	CompanyIdNot            *int32                       `json:"companyId_not,omitempty"`
	CompanyIdIn             []int32                      `json:"companyId_in,omitempty"`
	CompanyIdNotIn          []int32                      `json:"companyId_not_in,omitempty"`
	CompanyIdLt             *int32                       `json:"companyId_lt,omitempty"`
	CompanyIdLte            *int32                       `json:"companyId_lte,omitempty"`
	CompanyIdGt             *int32                       `json:"companyId_gt,omitempty"`
	CompanyIdGte            *int32                       `json:"companyId_gte,omitempty"`
	ServiceCompanyId        *int32                       `json:"serviceCompanyId,omitempty"`
	ServiceCompanyIdNot     *int32                       `json:"serviceCompanyId_not,omitempty"`
	ServiceCompanyIdIn      []int32                      `json:"serviceCompanyId_in,omitempty"`
	ServiceCompanyIdNotIn   []int32                      `json:"serviceCompanyId_not_in,omitempty"`
	ServiceCompanyIdLt      *int32                       `json:"serviceCompanyId_lt,omitempty"`
	ServiceCompanyIdLte     *int32                       `json:"serviceCompanyId_lte,omitempty"`
	ServiceCompanyIdGt      *int32                       `json:"serviceCompanyId_gt,omitempty"`
	ServiceCompanyIdGte     *int32                       `json:"serviceCompanyId_gte,omitempty"`
	BeginTimestamp          *int32                       `json:"beginTimestamp,omitempty"`
	BeginTimestampNot       *int32                       `json:"beginTimestamp_not,omitempty"`
	BeginTimestampIn        []int32                      `json:"beginTimestamp_in,omitempty"`
	BeginTimestampNotIn     []int32                      `json:"beginTimestamp_not_in,omitempty"`
	BeginTimestampLt        *int32                       `json:"beginTimestamp_lt,omitempty"`
	BeginTimestampLte       *int32                       `json:"beginTimestamp_lte,omitempty"`
	BeginTimestampGt        *int32                       `json:"beginTimestamp_gt,omitempty"`
	BeginTimestampGte       *int32                       `json:"beginTimestamp_gte,omitempty"`
	EndTimestamp            *int32                       `json:"endTimestamp,omitempty"`
	EndTimestampNot         *int32                       `json:"endTimestamp_not,omitempty"`
	EndTimestampIn          []int32                      `json:"endTimestamp_in,omitempty"`
	EndTimestampNotIn       []int32                      `json:"endTimestamp_not_in,omitempty"`
	EndTimestampLt          *int32                       `json:"endTimestamp_lt,omitempty"`
	EndTimestampLte         *int32                       `json:"endTimestamp_lte,omitempty"`
	EndTimestampGt          *int32                       `json:"endTimestamp_gt,omitempty"`
	EndTimestampGte         *int32                       `json:"endTimestamp_gte,omitempty"`
	IsNeedProcessBegin      *int32                       `json:"isNeedProcessBegin,omitempty"`
	IsNeedProcessBeginNot   *int32                       `json:"isNeedProcessBegin_not,omitempty"`
	IsNeedProcessBeginIn    []int32                      `json:"isNeedProcessBegin_in,omitempty"`
	IsNeedProcessBeginNotIn []int32                      `json:"isNeedProcessBegin_not_in,omitempty"`
	IsNeedProcessBeginLt    *int32                       `json:"isNeedProcessBegin_lt,omitempty"`
	IsNeedProcessBeginLte   *int32                       `json:"isNeedProcessBegin_lte,omitempty"`
	IsNeedProcessBeginGt    *int32                       `json:"isNeedProcessBegin_gt,omitempty"`
	IsNeedProcessBeginGte   *int32                       `json:"isNeedProcessBegin_gte,omitempty"`
	IsNeedProcessEnd        *int32                       `json:"isNeedProcessEnd,omitempty"`
	IsNeedProcessEndNot     *int32                       `json:"isNeedProcessEnd_not,omitempty"`
	IsNeedProcessEndIn      []int32                      `json:"isNeedProcessEnd_in,omitempty"`
	IsNeedProcessEndNotIn   []int32                      `json:"isNeedProcessEnd_not_in,omitempty"`
	IsNeedProcessEndLt      *int32                       `json:"isNeedProcessEnd_lt,omitempty"`
	IsNeedProcessEndLte     *int32                       `json:"isNeedProcessEnd_lte,omitempty"`
	IsNeedProcessEndGt      *int32                       `json:"isNeedProcessEnd_gt,omitempty"`
	IsNeedProcessEndGte     *int32                       `json:"isNeedProcessEnd_gte,omitempty"`
	Extend                  *string                      `json:"extend,omitempty"`
	ExtendNot               *string                      `json:"extend_not,omitempty"`
	ExtendIn                []string                     `json:"extend_in,omitempty"`
	ExtendNotIn             []string                     `json:"extend_not_in,omitempty"`
	ExtendLt                *string                      `json:"extend_lt,omitempty"`
	ExtendLte               *string                      `json:"extend_lte,omitempty"`
	ExtendGt                *string                      `json:"extend_gt,omitempty"`
	ExtendGte               *string                      `json:"extend_gte,omitempty"`
	ExtendContains          *string                      `json:"extend_contains,omitempty"`
	ExtendNotContains       *string                      `json:"extend_not_contains,omitempty"`
	ExtendStartsWith        *string                      `json:"extend_starts_with,omitempty"`
	ExtendNotStartsWith     *string                      `json:"extend_not_starts_with,omitempty"`
	ExtendEndsWith          *string                      `json:"extend_ends_with,omitempty"`
	ExtendNotEndsWith       *string                      `json:"extend_not_ends_with,omitempty"`
	BizContent              *string                      `json:"bizContent,omitempty"`
	BizContentNot           *string                      `json:"bizContent_not,omitempty"`
	BizContentIn            []string                     `json:"bizContent_in,omitempty"`
	BizContentNotIn         []string                     `json:"bizContent_not_in,omitempty"`
	BizContentLt            *string                      `json:"bizContent_lt,omitempty"`
	BizContentLte           *string                      `json:"bizContent_lte,omitempty"`
	BizContentGt            *string                      `json:"bizContent_gt,omitempty"`
	BizContentGte           *string                      `json:"bizContent_gte,omitempty"`
	BizContentContains      *string                      `json:"bizContent_contains,omitempty"`
	BizContentNotContains   *string                      `json:"bizContent_not_contains,omitempty"`
	BizContentStartsWith    *string                      `json:"bizContent_starts_with,omitempty"`
	BizContentNotStartsWith *string                      `json:"bizContent_not_starts_with,omitempty"`
	BizContentEndsWith      *string                      `json:"bizContent_ends_with,omitempty"`
	BizContentNotEndsWith   *string                      `json:"bizContent_not_ends_with,omitempty"`
	Remark                  *string                      `json:"remark,omitempty"`
	RemarkNot               *string                      `json:"remark_not,omitempty"`
	RemarkIn                []string                     `json:"remark_in,omitempty"`
	RemarkNotIn             []string                     `json:"remark_not_in,omitempty"`
	RemarkLt                *string                      `json:"remark_lt,omitempty"`
	RemarkLte               *string                      `json:"remark_lte,omitempty"`
	RemarkGt                *string                      `json:"remark_gt,omitempty"`
	RemarkGte               *string                      `json:"remark_gte,omitempty"`
	RemarkContains          *string                      `json:"remark_contains,omitempty"`
	RemarkNotContains       *string                      `json:"remark_not_contains,omitempty"`
	RemarkStartsWith        *string                      `json:"remark_starts_with,omitempty"`
	RemarkNotStartsWith     *string                      `json:"remark_not_starts_with,omitempty"`
	RemarkEndsWith          *string                      `json:"remark_ends_with,omitempty"`
	RemarkNotEndsWith       *string                      `json:"remark_not_ends_with,omitempty"`
	CreatedAt               *string                      `json:"createdAt,omitempty"`
	CreatedAtNot            *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn             []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn          []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt             *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte            *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt             *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte            *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt               *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot            *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn             []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn          []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt             *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte            *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt             *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte            *string                      `json:"updatedAt_gte,omitempty"`
	DeletedAt               *int32                       `json:"deletedAt,omitempty"`
	DeletedAtNot            *int32                       `json:"deletedAt_not,omitempty"`
	DeletedAtIn             []int32                      `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn          []int32                      `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt             *int32                       `json:"deletedAt_lt,omitempty"`
	DeletedAtLte            *int32                       `json:"deletedAt_lte,omitempty"`
	DeletedAtGt             *int32                       `json:"deletedAt_gt,omitempty"`
	DeletedAtGte            *int32                       `json:"deletedAt_gte,omitempty"`
	And                     []JobTemplateDelayWhereInput `json:"AND,omitempty"`
	Or                      []JobTemplateDelayWhereInput `json:"OR,omitempty"`
	Not                     []JobTemplateDelayWhereInput `json:"NOT,omitempty"`
}

type KpiUploadLogWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type KpiUploadLogWhereInput struct {
	ID                    *int32                   `json:"id,omitempty"`
	IDNot                 *int32                   `json:"id_not,omitempty"`
	IDIn                  []int32                  `json:"id_in,omitempty"`
	IDNotIn               []int32                  `json:"id_not_in,omitempty"`
	IDLt                  *int32                   `json:"id_lt,omitempty"`
	IDLte                 *int32                   `json:"id_lte,omitempty"`
	IDGt                  *int32                   `json:"id_gt,omitempty"`
	IDGte                 *int32                   `json:"id_gte,omitempty"`
	CompanyId             *int32                   `json:"companyId,omitempty"`
	CompanyIdNot          *int32                   `json:"companyId_not,omitempty"`
	CompanyIdIn           []int32                  `json:"companyId_in,omitempty"`
	CompanyIdNotIn        []int32                  `json:"companyId_not_in,omitempty"`
	CompanyIdLt           *int32                   `json:"companyId_lt,omitempty"`
	CompanyIdLte          *int32                   `json:"companyId_lte,omitempty"`
	CompanyIdGt           *int32                   `json:"companyId_gt,omitempty"`
	CompanyIdGte          *int32                   `json:"companyId_gte,omitempty"`
	FileName              *string                  `json:"fileName,omitempty"`
	FileNameNot           *string                  `json:"fileName_not,omitempty"`
	FileNameIn            []string                 `json:"fileName_in,omitempty"`
	FileNameNotIn         []string                 `json:"fileName_not_in,omitempty"`
	FileNameLt            *string                  `json:"fileName_lt,omitempty"`
	FileNameLte           *string                  `json:"fileName_lte,omitempty"`
	FileNameGt            *string                  `json:"fileName_gt,omitempty"`
	FileNameGte           *string                  `json:"fileName_gte,omitempty"`
	FileNameContains      *string                  `json:"fileName_contains,omitempty"`
	FileNameNotContains   *string                  `json:"fileName_not_contains,omitempty"`
	FileNameStartsWith    *string                  `json:"fileName_starts_with,omitempty"`
	FileNameNotStartsWith *string                  `json:"fileName_not_starts_with,omitempty"`
	FileNameEndsWith      *string                  `json:"fileName_ends_with,omitempty"`
	FileNameNotEndsWith   *string                  `json:"fileName_not_ends_with,omitempty"`
	FileUrl               *string                  `json:"fileUrl,omitempty"`
	FileUrlNot            *string                  `json:"fileUrl_not,omitempty"`
	FileUrlIn             []string                 `json:"fileUrl_in,omitempty"`
	FileUrlNotIn          []string                 `json:"fileUrl_not_in,omitempty"`
	FileUrlLt             *string                  `json:"fileUrl_lt,omitempty"`
	FileUrlLte            *string                  `json:"fileUrl_lte,omitempty"`
	FileUrlGt             *string                  `json:"fileUrl_gt,omitempty"`
	FileUrlGte            *string                  `json:"fileUrl_gte,omitempty"`
	FileUrlContains       *string                  `json:"fileUrl_contains,omitempty"`
	FileUrlNotContains    *string                  `json:"fileUrl_not_contains,omitempty"`
	FileUrlStartsWith     *string                  `json:"fileUrl_starts_with,omitempty"`
	FileUrlNotStartsWith  *string                  `json:"fileUrl_not_starts_with,omitempty"`
	FileUrlEndsWith       *string                  `json:"fileUrl_ends_with,omitempty"`
	FileUrlNotEndsWith    *string                  `json:"fileUrl_not_ends_with,omitempty"`
	Hash                  *string                  `json:"hash,omitempty"`
	HashNot               *string                  `json:"hash_not,omitempty"`
	HashIn                []string                 `json:"hash_in,omitempty"`
	HashNotIn             []string                 `json:"hash_not_in,omitempty"`
	HashLt                *string                  `json:"hash_lt,omitempty"`
	HashLte               *string                  `json:"hash_lte,omitempty"`
	HashGt                *string                  `json:"hash_gt,omitempty"`
	HashGte               *string                  `json:"hash_gte,omitempty"`
	HashContains          *string                  `json:"hash_contains,omitempty"`
	HashNotContains       *string                  `json:"hash_not_contains,omitempty"`
	HashStartsWith        *string                  `json:"hash_starts_with,omitempty"`
	HashNotStartsWith     *string                  `json:"hash_not_starts_with,omitempty"`
	HashEndsWith          *string                  `json:"hash_ends_with,omitempty"`
	HashNotEndsWith       *string                  `json:"hash_not_ends_with,omitempty"`
	CreatedAt             *string                  `json:"createdAt,omitempty"`
	CreatedAtNot          *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                  `json:"updatedAt_gte,omitempty"`
	And                   []KpiUploadLogWhereInput `json:"AND,omitempty"`
	Or                    []KpiUploadLogWhereInput `json:"OR,omitempty"`
	Not                   []KpiUploadLogWhereInput `json:"NOT,omitempty"`
}

type UserWeChatAuthorizeWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type UserWeChatAuthorizeWhereInput struct {
	ID                  *int32                          `json:"id,omitempty"`
	IDNot               *int32                          `json:"id_not,omitempty"`
	IDIn                []int32                         `json:"id_in,omitempty"`
	IDNotIn             []int32                         `json:"id_not_in,omitempty"`
	IDLt                *int32                          `json:"id_lt,omitempty"`
	IDLte               *int32                          `json:"id_lte,omitempty"`
	IDGt                *int32                          `json:"id_gt,omitempty"`
	IDGte               *int32                          `json:"id_gte,omitempty"`
	UserId              *string                         `json:"userId,omitempty"`
	UserIdNot           *string                         `json:"userId_not,omitempty"`
	UserIdIn            []string                        `json:"userId_in,omitempty"`
	UserIdNotIn         []string                        `json:"userId_not_in,omitempty"`
	UserIdLt            *string                         `json:"userId_lt,omitempty"`
	UserIdLte           *string                         `json:"userId_lte,omitempty"`
	UserIdGt            *string                         `json:"userId_gt,omitempty"`
	UserIdGte           *string                         `json:"userId_gte,omitempty"`
	UserIdContains      *string                         `json:"userId_contains,omitempty"`
	UserIdNotContains   *string                         `json:"userId_not_contains,omitempty"`
	UserIdStartsWith    *string                         `json:"userId_starts_with,omitempty"`
	UserIdNotStartsWith *string                         `json:"userId_not_starts_with,omitempty"`
	UserIdEndsWith      *string                         `json:"userId_ends_with,omitempty"`
	UserIdNotEndsWith   *string                         `json:"userId_not_ends_with,omitempty"`
	Mobile              *string                         `json:"mobile,omitempty"`
	MobileNot           *string                         `json:"mobile_not,omitempty"`
	MobileIn            []string                        `json:"mobile_in,omitempty"`
	MobileNotIn         []string                        `json:"mobile_not_in,omitempty"`
	MobileLt            *string                         `json:"mobile_lt,omitempty"`
	MobileLte           *string                         `json:"mobile_lte,omitempty"`
	MobileGt            *string                         `json:"mobile_gt,omitempty"`
	MobileGte           *string                         `json:"mobile_gte,omitempty"`
	MobileContains      *string                         `json:"mobile_contains,omitempty"`
	MobileNotContains   *string                         `json:"mobile_not_contains,omitempty"`
	MobileStartsWith    *string                         `json:"mobile_starts_with,omitempty"`
	MobileNotStartsWith *string                         `json:"mobile_not_starts_with,omitempty"`
	MobileEndsWith      *string                         `json:"mobile_ends_with,omitempty"`
	MobileNotEndsWith   *string                         `json:"mobile_not_ends_with,omitempty"`
	CreatedAt           *string                         `json:"createdAt,omitempty"`
	CreatedAtNot        *string                         `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string                        `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string                        `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                         `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                         `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                         `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                         `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                         `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                         `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string                        `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string                        `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                         `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                         `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                         `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                         `json:"updatedAt_gte,omitempty"`
	DeletedAt           *int32                          `json:"deletedAt,omitempty"`
	DeletedAtNot        *int32                          `json:"deletedAt_not,omitempty"`
	DeletedAtIn         []int32                         `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn      []int32                         `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt         *int32                          `json:"deletedAt_lt,omitempty"`
	DeletedAtLte        *int32                          `json:"deletedAt_lte,omitempty"`
	DeletedAtGt         *int32                          `json:"deletedAt_gt,omitempty"`
	DeletedAtGte        *int32                          `json:"deletedAt_gte,omitempty"`
	And                 []UserWeChatAuthorizeWhereInput `json:"AND,omitempty"`
	Or                  []UserWeChatAuthorizeWhereInput `json:"OR,omitempty"`
	Not                 []UserWeChatAuthorizeWhereInput `json:"NOT,omitempty"`
}

type WorkWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type WorkWhereInput struct {
	ID                         *int32           `json:"id,omitempty"`
	IDNot                      *int32           `json:"id_not,omitempty"`
	IDIn                       []int32          `json:"id_in,omitempty"`
	IDNotIn                    []int32          `json:"id_not_in,omitempty"`
	IDLt                       *int32           `json:"id_lt,omitempty"`
	IDLte                      *int32           `json:"id_lte,omitempty"`
	IDGt                       *int32           `json:"id_gt,omitempty"`
	IDGte                      *int32           `json:"id_gte,omitempty"`
	AppId                      *string          `json:"appId,omitempty"`
	AppIdNot                   *string          `json:"appId_not,omitempty"`
	AppIdIn                    []string         `json:"appId_in,omitempty"`
	AppIdNotIn                 []string         `json:"appId_not_in,omitempty"`
	AppIdLt                    *string          `json:"appId_lt,omitempty"`
	AppIdLte                   *string          `json:"appId_lte,omitempty"`
	AppIdGt                    *string          `json:"appId_gt,omitempty"`
	AppIdGte                   *string          `json:"appId_gte,omitempty"`
	AppIdContains              *string          `json:"appId_contains,omitempty"`
	AppIdNotContains           *string          `json:"appId_not_contains,omitempty"`
	AppIdStartsWith            *string          `json:"appId_starts_with,omitempty"`
	AppIdNotStartsWith         *string          `json:"appId_not_starts_with,omitempty"`
	AppIdEndsWith              *string          `json:"appId_ends_with,omitempty"`
	AppIdNotEndsWith           *string          `json:"appId_not_ends_with,omitempty"`
	CompanyId                  *int32           `json:"companyId,omitempty"`
	CompanyIdNot               *int32           `json:"companyId_not,omitempty"`
	CompanyIdIn                []int32          `json:"companyId_in,omitempty"`
	CompanyIdNotIn             []int32          `json:"companyId_not_in,omitempty"`
	CompanyIdLt                *int32           `json:"companyId_lt,omitempty"`
	CompanyIdLte               *int32           `json:"companyId_lte,omitempty"`
	CompanyIdGt                *int32           `json:"companyId_gt,omitempty"`
	CompanyIdGte               *int32           `json:"companyId_gte,omitempty"`
	UserId                     *string          `json:"userId,omitempty"`
	UserIdNot                  *string          `json:"userId_not,omitempty"`
	UserIdIn                   []string         `json:"userId_in,omitempty"`
	UserIdNotIn                []string         `json:"userId_not_in,omitempty"`
	UserIdLt                   *string          `json:"userId_lt,omitempty"`
	UserIdLte                  *string          `json:"userId_lte,omitempty"`
	UserIdGt                   *string          `json:"userId_gt,omitempty"`
	UserIdGte                  *string          `json:"userId_gte,omitempty"`
	UserIdContains             *string          `json:"userId_contains,omitempty"`
	UserIdNotContains          *string          `json:"userId_not_contains,omitempty"`
	UserIdStartsWith           *string          `json:"userId_starts_with,omitempty"`
	UserIdNotStartsWith        *string          `json:"userId_not_starts_with,omitempty"`
	UserIdEndsWith             *string          `json:"userId_ends_with,omitempty"`
	UserIdNotEndsWith          *string          `json:"userId_not_ends_with,omitempty"`
	ServiceTypeId              *int32           `json:"serviceTypeId,omitempty"`
	ServiceTypeIdNot           *int32           `json:"serviceTypeId_not,omitempty"`
	ServiceTypeIdIn            []int32          `json:"serviceTypeId_in,omitempty"`
	ServiceTypeIdNotIn         []int32          `json:"serviceTypeId_not_in,omitempty"`
	ServiceTypeIdLt            *int32           `json:"serviceTypeId_lt,omitempty"`
	ServiceTypeIdLte           *int32           `json:"serviceTypeId_lte,omitempty"`
	ServiceTypeIdGt            *int32           `json:"serviceTypeId_gt,omitempty"`
	ServiceTypeIdGte           *int32           `json:"serviceTypeId_gte,omitempty"`
	WorkType                   *int32           `json:"workType,omitempty"`
	WorkTypeNot                *int32           `json:"workType_not,omitempty"`
	WorkTypeIn                 []int32          `json:"workType_in,omitempty"`
	WorkTypeNotIn              []int32          `json:"workType_not_in,omitempty"`
	WorkTypeLt                 *int32           `json:"workType_lt,omitempty"`
	WorkTypeLte                *int32           `json:"workType_lte,omitempty"`
	WorkTypeGt                 *int32           `json:"workType_gt,omitempty"`
	WorkTypeGte                *int32           `json:"workType_gte,omitempty"`
	Name                       *string          `json:"name,omitempty"`
	NameNot                    *string          `json:"name_not,omitempty"`
	NameIn                     []string         `json:"name_in,omitempty"`
	NameNotIn                  []string         `json:"name_not_in,omitempty"`
	NameLt                     *string          `json:"name_lt,omitempty"`
	NameLte                    *string          `json:"name_lte,omitempty"`
	NameGt                     *string          `json:"name_gt,omitempty"`
	NameGte                    *string          `json:"name_gte,omitempty"`
	NameContains               *string          `json:"name_contains,omitempty"`
	NameNotContains            *string          `json:"name_not_contains,omitempty"`
	NameStartsWith             *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith          *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith               *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith            *string          `json:"name_not_ends_with,omitempty"`
	Requirement                *string          `json:"requirement,omitempty"`
	RequirementNot             *string          `json:"requirement_not,omitempty"`
	RequirementIn              []string         `json:"requirement_in,omitempty"`
	RequirementNotIn           []string         `json:"requirement_not_in,omitempty"`
	RequirementLt              *string          `json:"requirement_lt,omitempty"`
	RequirementLte             *string          `json:"requirement_lte,omitempty"`
	RequirementGt              *string          `json:"requirement_gt,omitempty"`
	RequirementGte             *string          `json:"requirement_gte,omitempty"`
	RequirementContains        *string          `json:"requirement_contains,omitempty"`
	RequirementNotContains     *string          `json:"requirement_not_contains,omitempty"`
	RequirementStartsWith      *string          `json:"requirement_starts_with,omitempty"`
	RequirementNotStartsWith   *string          `json:"requirement_not_starts_with,omitempty"`
	RequirementEndsWith        *string          `json:"requirement_ends_with,omitempty"`
	RequirementNotEndsWith     *string          `json:"requirement_not_ends_with,omitempty"`
	PayType                    *int32           `json:"payType,omitempty"`
	PayTypeNot                 *int32           `json:"payType_not,omitempty"`
	PayTypeIn                  []int32          `json:"payType_in,omitempty"`
	PayTypeNotIn               []int32          `json:"payType_not_in,omitempty"`
	PayTypeLt                  *int32           `json:"payType_lt,omitempty"`
	PayTypeLte                 *int32           `json:"payType_lte,omitempty"`
	PayTypeGt                  *int32           `json:"payType_gt,omitempty"`
	PayTypeGte                 *int32           `json:"payType_gte,omitempty"`
	Duration                   *int32           `json:"duration,omitempty"`
	DurationNot                *int32           `json:"duration_not,omitempty"`
	DurationIn                 []int32          `json:"duration_in,omitempty"`
	DurationNotIn              []int32          `json:"duration_not_in,omitempty"`
	DurationLt                 *int32           `json:"duration_lt,omitempty"`
	DurationLte                *int32           `json:"duration_lte,omitempty"`
	DurationGt                 *int32           `json:"duration_gt,omitempty"`
	DurationGte                *int32           `json:"duration_gte,omitempty"`
	EndAt                      *int32           `json:"endAt,omitempty"`
	EndAtNot                   *int32           `json:"endAt_not,omitempty"`
	EndAtIn                    []int32          `json:"endAt_in,omitempty"`
	EndAtNotIn                 []int32          `json:"endAt_not_in,omitempty"`
	EndAtLt                    *int32           `json:"endAt_lt,omitempty"`
	EndAtLte                   *int32           `json:"endAt_lte,omitempty"`
	EndAtGt                    *int32           `json:"endAt_gt,omitempty"`
	EndAtGte                   *int32           `json:"endAt_gte,omitempty"`
	Source                     *int32           `json:"source,omitempty"`
	SourceNot                  *int32           `json:"source_not,omitempty"`
	SourceIn                   []int32          `json:"source_in,omitempty"`
	SourceNotIn                []int32          `json:"source_not_in,omitempty"`
	SourceLt                   *int32           `json:"source_lt,omitempty"`
	SourceLte                  *int32           `json:"source_lte,omitempty"`
	SourceGt                   *int32           `json:"source_gt,omitempty"`
	SourceGte                  *int32           `json:"source_gte,omitempty"`
	Status                     *int32           `json:"status,omitempty"`
	StatusNot                  *int32           `json:"status_not,omitempty"`
	StatusIn                   []int32          `json:"status_in,omitempty"`
	StatusNotIn                []int32          `json:"status_not_in,omitempty"`
	StatusLt                   *int32           `json:"status_lt,omitempty"`
	StatusLte                  *int32           `json:"status_lte,omitempty"`
	StatusGt                   *int32           `json:"status_gt,omitempty"`
	StatusGte                  *int32           `json:"status_gte,omitempty"`
	Type                       *int32           `json:"type,omitempty"`
	TypeNot                    *int32           `json:"type_not,omitempty"`
	TypeIn                     []int32          `json:"type_in,omitempty"`
	TypeNotIn                  []int32          `json:"type_not_in,omitempty"`
	TypeLt                     *int32           `json:"type_lt,omitempty"`
	TypeLte                    *int32           `json:"type_lte,omitempty"`
	TypeGt                     *int32           `json:"type_gt,omitempty"`
	TypeGte                    *int32           `json:"type_gte,omitempty"`
	IsPublic                   *int32           `json:"isPublic,omitempty"`
	IsPublicNot                *int32           `json:"isPublic_not,omitempty"`
	IsPublicIn                 []int32          `json:"isPublic_in,omitempty"`
	IsPublicNotIn              []int32          `json:"isPublic_not_in,omitempty"`
	IsPublicLt                 *int32           `json:"isPublic_lt,omitempty"`
	IsPublicLte                *int32           `json:"isPublic_lte,omitempty"`
	IsPublicGt                 *int32           `json:"isPublic_gt,omitempty"`
	IsPublicGte                *int32           `json:"isPublic_gte,omitempty"`
	MediaCoverUrl              *string          `json:"mediaCoverUrl,omitempty"`
	MediaCoverUrlNot           *string          `json:"mediaCoverUrl_not,omitempty"`
	MediaCoverUrlIn            []string         `json:"mediaCoverUrl_in,omitempty"`
	MediaCoverUrlNotIn         []string         `json:"mediaCoverUrl_not_in,omitempty"`
	MediaCoverUrlLt            *string          `json:"mediaCoverUrl_lt,omitempty"`
	MediaCoverUrlLte           *string          `json:"mediaCoverUrl_lte,omitempty"`
	MediaCoverUrlGt            *string          `json:"mediaCoverUrl_gt,omitempty"`
	MediaCoverUrlGte           *string          `json:"mediaCoverUrl_gte,omitempty"`
	MediaCoverUrlContains      *string          `json:"mediaCoverUrl_contains,omitempty"`
	MediaCoverUrlNotContains   *string          `json:"mediaCoverUrl_not_contains,omitempty"`
	MediaCoverUrlStartsWith    *string          `json:"mediaCoverUrl_starts_with,omitempty"`
	MediaCoverUrlNotStartsWith *string          `json:"mediaCoverUrl_not_starts_with,omitempty"`
	MediaCoverUrlEndsWith      *string          `json:"mediaCoverUrl_ends_with,omitempty"`
	MediaCoverUrlNotEndsWith   *string          `json:"mediaCoverUrl_not_ends_with,omitempty"`
	MediaUrls                  *string          `json:"mediaUrls,omitempty"`
	MediaUrlsNot               *string          `json:"mediaUrls_not,omitempty"`
	MediaUrlsIn                []string         `json:"mediaUrls_in,omitempty"`
	MediaUrlsNotIn             []string         `json:"mediaUrls_not_in,omitempty"`
	MediaUrlsLt                *string          `json:"mediaUrls_lt,omitempty"`
	MediaUrlsLte               *string          `json:"mediaUrls_lte,omitempty"`
	MediaUrlsGt                *string          `json:"mediaUrls_gt,omitempty"`
	MediaUrlsGte               *string          `json:"mediaUrls_gte,omitempty"`
	MediaUrlsContains          *string          `json:"mediaUrls_contains,omitempty"`
	MediaUrlsNotContains       *string          `json:"mediaUrls_not_contains,omitempty"`
	MediaUrlsStartsWith        *string          `json:"mediaUrls_starts_with,omitempty"`
	MediaUrlsNotStartsWith     *string          `json:"mediaUrls_not_starts_with,omitempty"`
	MediaUrlsEndsWith          *string          `json:"mediaUrls_ends_with,omitempty"`
	MediaUrlsNotEndsWith       *string          `json:"mediaUrls_not_ends_with,omitempty"`
	Resume                     *string          `json:"resume,omitempty"`
	ResumeNot                  *string          `json:"resume_not,omitempty"`
	ResumeIn                   []string         `json:"resume_in,omitempty"`
	ResumeNotIn                []string         `json:"resume_not_in,omitempty"`
	ResumeLt                   *string          `json:"resume_lt,omitempty"`
	ResumeLte                  *string          `json:"resume_lte,omitempty"`
	ResumeGt                   *string          `json:"resume_gt,omitempty"`
	ResumeGte                  *string          `json:"resume_gte,omitempty"`
	ResumeContains             *string          `json:"resume_contains,omitempty"`
	ResumeNotContains          *string          `json:"resume_not_contains,omitempty"`
	ResumeStartsWith           *string          `json:"resume_starts_with,omitempty"`
	ResumeNotStartsWith        *string          `json:"resume_not_starts_with,omitempty"`
	ResumeEndsWith             *string          `json:"resume_ends_with,omitempty"`
	ResumeNotEndsWith          *string          `json:"resume_not_ends_with,omitempty"`
	Extend                     *string          `json:"extend,omitempty"`
	ExtendNot                  *string          `json:"extend_not,omitempty"`
	ExtendIn                   []string         `json:"extend_in,omitempty"`
	ExtendNotIn                []string         `json:"extend_not_in,omitempty"`
	ExtendLt                   *string          `json:"extend_lt,omitempty"`
	ExtendLte                  *string          `json:"extend_lte,omitempty"`
	ExtendGt                   *string          `json:"extend_gt,omitempty"`
	ExtendGte                  *string          `json:"extend_gte,omitempty"`
	ExtendContains             *string          `json:"extend_contains,omitempty"`
	ExtendNotContains          *string          `json:"extend_not_contains,omitempty"`
	ExtendStartsWith           *string          `json:"extend_starts_with,omitempty"`
	ExtendNotStartsWith        *string          `json:"extend_not_starts_with,omitempty"`
	ExtendEndsWith             *string          `json:"extend_ends_with,omitempty"`
	ExtendNotEndsWith          *string          `json:"extend_not_ends_with,omitempty"`
	UpdatedAt                  *string          `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string          `json:"updatedAt_gte,omitempty"`
	CreatedAt                  *string          `json:"createdAt,omitempty"`
	CreatedAtNot               *string          `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string          `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string          `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string          `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string          `json:"createdAt_gte,omitempty"`
	DeletedAt                  *int32           `json:"deletedAt,omitempty"`
	DeletedAtNot               *int32           `json:"deletedAt_not,omitempty"`
	DeletedAtIn                []int32          `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn             []int32          `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt                *int32           `json:"deletedAt_lt,omitempty"`
	DeletedAtLte               *int32           `json:"deletedAt_lte,omitempty"`
	DeletedAtGt                *int32           `json:"deletedAt_gt,omitempty"`
	DeletedAtGte               *int32           `json:"deletedAt_gte,omitempty"`
	And                        []WorkWhereInput `json:"AND,omitempty"`
	Or                         []WorkWhereInput `json:"OR,omitempty"`
	Not                        []WorkWhereInput `json:"NOT,omitempty"`
}

type WorkExtendWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type WorkExtendWhereInput struct {
	ID                  *int32                 `json:"id,omitempty"`
	IDNot               *int32                 `json:"id_not,omitempty"`
	IDIn                []int32                `json:"id_in,omitempty"`
	IDNotIn             []int32                `json:"id_not_in,omitempty"`
	IDLt                *int32                 `json:"id_lt,omitempty"`
	IDLte               *int32                 `json:"id_lte,omitempty"`
	IDGt                *int32                 `json:"id_gt,omitempty"`
	IDGte               *int32                 `json:"id_gte,omitempty"`
	WorkId              *int32                 `json:"workId,omitempty"`
	WorkIdNot           *int32                 `json:"workId_not,omitempty"`
	WorkIdIn            []int32                `json:"workId_in,omitempty"`
	WorkIdNotIn         []int32                `json:"workId_not_in,omitempty"`
	WorkIdLt            *int32                 `json:"workId_lt,omitempty"`
	WorkIdLte           *int32                 `json:"workId_lte,omitempty"`
	WorkIdGt            *int32                 `json:"workId_gt,omitempty"`
	WorkIdGte           *int32                 `json:"workId_gte,omitempty"`
	AppId               *string                `json:"appId,omitempty"`
	AppIdNot            *string                `json:"appId_not,omitempty"`
	AppIdIn             []string               `json:"appId_in,omitempty"`
	AppIdNotIn          []string               `json:"appId_not_in,omitempty"`
	AppIdLt             *string                `json:"appId_lt,omitempty"`
	AppIdLte            *string                `json:"appId_lte,omitempty"`
	AppIdGt             *string                `json:"appId_gt,omitempty"`
	AppIdGte            *string                `json:"appId_gte,omitempty"`
	AppIdContains       *string                `json:"appId_contains,omitempty"`
	AppIdNotContains    *string                `json:"appId_not_contains,omitempty"`
	AppIdStartsWith     *string                `json:"appId_starts_with,omitempty"`
	AppIdNotStartsWith  *string                `json:"appId_not_starts_with,omitempty"`
	AppIdEndsWith       *string                `json:"appId_ends_with,omitempty"`
	AppIdNotEndsWith    *string                `json:"appId_not_ends_with,omitempty"`
	FocusCount          *int32                 `json:"focusCount,omitempty"`
	FocusCountNot       *int32                 `json:"focusCount_not,omitempty"`
	FocusCountIn        []int32                `json:"focusCount_in,omitempty"`
	FocusCountNotIn     []int32                `json:"focusCount_not_in,omitempty"`
	FocusCountLt        *int32                 `json:"focusCount_lt,omitempty"`
	FocusCountLte       *int32                 `json:"focusCount_lte,omitempty"`
	FocusCountGt        *int32                 `json:"focusCount_gt,omitempty"`
	FocusCountGte       *int32                 `json:"focusCount_gte,omitempty"`
	LikeCount           *int32                 `json:"likeCount,omitempty"`
	LikeCountNot        *int32                 `json:"likeCount_not,omitempty"`
	LikeCountIn         []int32                `json:"likeCount_in,omitempty"`
	LikeCountNotIn      []int32                `json:"likeCount_not_in,omitempty"`
	LikeCountLt         *int32                 `json:"likeCount_lt,omitempty"`
	LikeCountLte        *int32                 `json:"likeCount_lte,omitempty"`
	LikeCountGt         *int32                 `json:"likeCount_gt,omitempty"`
	LikeCountGte        *int32                 `json:"likeCount_gte,omitempty"`
	ShareCount          *int32                 `json:"shareCount,omitempty"`
	ShareCountNot       *int32                 `json:"shareCount_not,omitempty"`
	ShareCountIn        []int32                `json:"shareCount_in,omitempty"`
	ShareCountNotIn     []int32                `json:"shareCount_not_in,omitempty"`
	ShareCountLt        *int32                 `json:"shareCount_lt,omitempty"`
	ShareCountLte       *int32                 `json:"shareCount_lte,omitempty"`
	ShareCountGt        *int32                 `json:"shareCount_gt,omitempty"`
	ShareCountGte       *int32                 `json:"shareCount_gte,omitempty"`
	CommentCount        *int32                 `json:"commentCount,omitempty"`
	CommentCountNot     *int32                 `json:"commentCount_not,omitempty"`
	CommentCountIn      []int32                `json:"commentCount_in,omitempty"`
	CommentCountNotIn   []int32                `json:"commentCount_not_in,omitempty"`
	CommentCountLt      *int32                 `json:"commentCount_lt,omitempty"`
	CommentCountLte     *int32                 `json:"commentCount_lte,omitempty"`
	CommentCountGt      *int32                 `json:"commentCount_gt,omitempty"`
	CommentCountGte     *int32                 `json:"commentCount_gte,omitempty"`
	Extend              *string                `json:"extend,omitempty"`
	ExtendNot           *string                `json:"extend_not,omitempty"`
	ExtendIn            []string               `json:"extend_in,omitempty"`
	ExtendNotIn         []string               `json:"extend_not_in,omitempty"`
	ExtendLt            *string                `json:"extend_lt,omitempty"`
	ExtendLte           *string                `json:"extend_lte,omitempty"`
	ExtendGt            *string                `json:"extend_gt,omitempty"`
	ExtendGte           *string                `json:"extend_gte,omitempty"`
	ExtendContains      *string                `json:"extend_contains,omitempty"`
	ExtendNotContains   *string                `json:"extend_not_contains,omitempty"`
	ExtendStartsWith    *string                `json:"extend_starts_with,omitempty"`
	ExtendNotStartsWith *string                `json:"extend_not_starts_with,omitempty"`
	ExtendEndsWith      *string                `json:"extend_ends_with,omitempty"`
	ExtendNotEndsWith   *string                `json:"extend_not_ends_with,omitempty"`
	DeletedAt           *int32                 `json:"deletedAt,omitempty"`
	DeletedAtNot        *int32                 `json:"deletedAt_not,omitempty"`
	DeletedAtIn         []int32                `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn      []int32                `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt         *int32                 `json:"deletedAt_lt,omitempty"`
	DeletedAtLte        *int32                 `json:"deletedAt_lte,omitempty"`
	DeletedAtGt         *int32                 `json:"deletedAt_gt,omitempty"`
	DeletedAtGte        *int32                 `json:"deletedAt_gte,omitempty"`
	CreatedAt           *string                `json:"createdAt,omitempty"`
	CreatedAtNot        *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                `json:"updatedAt_gte,omitempty"`
	And                 []WorkExtendWhereInput `json:"AND,omitempty"`
	Or                  []WorkExtendWhereInput `json:"OR,omitempty"`
	Not                 []WorkExtendWhereInput `json:"NOT,omitempty"`
}

type WorkProgressWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type WorkProgressWhereInput struct {
	ID                         *int32                   `json:"id,omitempty"`
	IDNot                      *int32                   `json:"id_not,omitempty"`
	IDIn                       []int32                  `json:"id_in,omitempty"`
	IDNotIn                    []int32                  `json:"id_not_in,omitempty"`
	IDLt                       *int32                   `json:"id_lt,omitempty"`
	IDLte                      *int32                   `json:"id_lte,omitempty"`
	IDGt                       *int32                   `json:"id_gt,omitempty"`
	IDGte                      *int32                   `json:"id_gte,omitempty"`
	AppId                      *string                  `json:"appId,omitempty"`
	AppIdNot                   *string                  `json:"appId_not,omitempty"`
	AppIdIn                    []string                 `json:"appId_in,omitempty"`
	AppIdNotIn                 []string                 `json:"appId_not_in,omitempty"`
	AppIdLt                    *string                  `json:"appId_lt,omitempty"`
	AppIdLte                   *string                  `json:"appId_lte,omitempty"`
	AppIdGt                    *string                  `json:"appId_gt,omitempty"`
	AppIdGte                   *string                  `json:"appId_gte,omitempty"`
	AppIdContains              *string                  `json:"appId_contains,omitempty"`
	AppIdNotContains           *string                  `json:"appId_not_contains,omitempty"`
	AppIdStartsWith            *string                  `json:"appId_starts_with,omitempty"`
	AppIdNotStartsWith         *string                  `json:"appId_not_starts_with,omitempty"`
	AppIdEndsWith              *string                  `json:"appId_ends_with,omitempty"`
	AppIdNotEndsWith           *string                  `json:"appId_not_ends_with,omitempty"`
	ParticipantId              *string                  `json:"participantId,omitempty"`
	ParticipantIdNot           *string                  `json:"participantId_not,omitempty"`
	ParticipantIdIn            []string                 `json:"participantId_in,omitempty"`
	ParticipantIdNotIn         []string                 `json:"participantId_not_in,omitempty"`
	ParticipantIdLt            *string                  `json:"participantId_lt,omitempty"`
	ParticipantIdLte           *string                  `json:"participantId_lte,omitempty"`
	ParticipantIdGt            *string                  `json:"participantId_gt,omitempty"`
	ParticipantIdGte           *string                  `json:"participantId_gte,omitempty"`
	ParticipantIdContains      *string                  `json:"participantId_contains,omitempty"`
	ParticipantIdNotContains   *string                  `json:"participantId_not_contains,omitempty"`
	ParticipantIdStartsWith    *string                  `json:"participantId_starts_with,omitempty"`
	ParticipantIdNotStartsWith *string                  `json:"participantId_not_starts_with,omitempty"`
	ParticipantIdEndsWith      *string                  `json:"participantId_ends_with,omitempty"`
	ParticipantIdNotEndsWith   *string                  `json:"participantId_not_ends_with,omitempty"`
	PublisherId                *string                  `json:"publisherId,omitempty"`
	PublisherIdNot             *string                  `json:"publisherId_not,omitempty"`
	PublisherIdIn              []string                 `json:"publisherId_in,omitempty"`
	PublisherIdNotIn           []string                 `json:"publisherId_not_in,omitempty"`
	PublisherIdLt              *string                  `json:"publisherId_lt,omitempty"`
	PublisherIdLte             *string                  `json:"publisherId_lte,omitempty"`
	PublisherIdGt              *string                  `json:"publisherId_gt,omitempty"`
	PublisherIdGte             *string                  `json:"publisherId_gte,omitempty"`
	PublisherIdContains        *string                  `json:"publisherId_contains,omitempty"`
	PublisherIdNotContains     *string                  `json:"publisherId_not_contains,omitempty"`
	PublisherIdStartsWith      *string                  `json:"publisherId_starts_with,omitempty"`
	PublisherIdNotStartsWith   *string                  `json:"publisherId_not_starts_with,omitempty"`
	PublisherIdEndsWith        *string                  `json:"publisherId_ends_with,omitempty"`
	PublisherIdNotEndsWith     *string                  `json:"publisherId_not_ends_with,omitempty"`
	WorkId                     *int32                   `json:"workId,omitempty"`
	WorkIdNot                  *int32                   `json:"workId_not,omitempty"`
	WorkIdIn                   []int32                  `json:"workId_in,omitempty"`
	WorkIdNotIn                []int32                  `json:"workId_not_in,omitempty"`
	WorkIdLt                   *int32                   `json:"workId_lt,omitempty"`
	WorkIdLte                  *int32                   `json:"workId_lte,omitempty"`
	WorkIdGt                   *int32                   `json:"workId_gt,omitempty"`
	WorkIdGte                  *int32                   `json:"workId_gte,omitempty"`
	Type                       *string                  `json:"type,omitempty"`
	TypeNot                    *string                  `json:"type_not,omitempty"`
	TypeIn                     []string                 `json:"type_in,omitempty"`
	TypeNotIn                  []string                 `json:"type_not_in,omitempty"`
	TypeLt                     *string                  `json:"type_lt,omitempty"`
	TypeLte                    *string                  `json:"type_lte,omitempty"`
	TypeGt                     *string                  `json:"type_gt,omitempty"`
	TypeGte                    *string                  `json:"type_gte,omitempty"`
	TypeContains               *string                  `json:"type_contains,omitempty"`
	TypeNotContains            *string                  `json:"type_not_contains,omitempty"`
	TypeStartsWith             *string                  `json:"type_starts_with,omitempty"`
	TypeNotStartsWith          *string                  `json:"type_not_starts_with,omitempty"`
	TypeEndsWith               *string                  `json:"type_ends_with,omitempty"`
	TypeNotEndsWith            *string                  `json:"type_not_ends_with,omitempty"`
	Extend                     *string                  `json:"extend,omitempty"`
	ExtendNot                  *string                  `json:"extend_not,omitempty"`
	ExtendIn                   []string                 `json:"extend_in,omitempty"`
	ExtendNotIn                []string                 `json:"extend_not_in,omitempty"`
	ExtendLt                   *string                  `json:"extend_lt,omitempty"`
	ExtendLte                  *string                  `json:"extend_lte,omitempty"`
	ExtendGt                   *string                  `json:"extend_gt,omitempty"`
	ExtendGte                  *string                  `json:"extend_gte,omitempty"`
	ExtendContains             *string                  `json:"extend_contains,omitempty"`
	ExtendNotContains          *string                  `json:"extend_not_contains,omitempty"`
	ExtendStartsWith           *string                  `json:"extend_starts_with,omitempty"`
	ExtendNotStartsWith        *string                  `json:"extend_not_starts_with,omitempty"`
	ExtendEndsWith             *string                  `json:"extend_ends_with,omitempty"`
	ExtendNotEndsWith          *string                  `json:"extend_not_ends_with,omitempty"`
	CreatedAt                  *string                  `json:"createdAt,omitempty"`
	CreatedAtNot               *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string                  `json:"updatedAt_gte,omitempty"`
	And                        []WorkProgressWhereInput `json:"AND,omitempty"`
	Or                         []WorkProgressWhereInput `json:"OR,omitempty"`
	Not                        []WorkProgressWhereInput `json:"NOT,omitempty"`
}

type WorkTemplateWhereUniqueInput struct {
	ID *int32 `json:"id,omitempty"`
}

type WorkTemplateWhereInput struct {
	ID                  *int32                   `json:"id,omitempty"`
	IDNot               *int32                   `json:"id_not,omitempty"`
	IDIn                []int32                  `json:"id_in,omitempty"`
	IDNotIn             []int32                  `json:"id_not_in,omitempty"`
	IDLt                *int32                   `json:"id_lt,omitempty"`
	IDLte               *int32                   `json:"id_lte,omitempty"`
	IDGt                *int32                   `json:"id_gt,omitempty"`
	IDGte               *int32                   `json:"id_gte,omitempty"`
	CompanyId           *int32                   `json:"companyId,omitempty"`
	CompanyIdNot        *int32                   `json:"companyId_not,omitempty"`
	CompanyIdIn         []int32                  `json:"companyId_in,omitempty"`
	CompanyIdNotIn      []int32                  `json:"companyId_not_in,omitempty"`
	CompanyIdLt         *int32                   `json:"companyId_lt,omitempty"`
	CompanyIdLte        *int32                   `json:"companyId_lte,omitempty"`
	CompanyIdGt         *int32                   `json:"companyId_gt,omitempty"`
	CompanyIdGte        *int32                   `json:"companyId_gte,omitempty"`
	UserId              *string                  `json:"userId,omitempty"`
	UserIdNot           *string                  `json:"userId_not,omitempty"`
	UserIdIn            []string                 `json:"userId_in,omitempty"`
	UserIdNotIn         []string                 `json:"userId_not_in,omitempty"`
	UserIdLt            *string                  `json:"userId_lt,omitempty"`
	UserIdLte           *string                  `json:"userId_lte,omitempty"`
	UserIdGt            *string                  `json:"userId_gt,omitempty"`
	UserIdGte           *string                  `json:"userId_gte,omitempty"`
	UserIdContains      *string                  `json:"userId_contains,omitempty"`
	UserIdNotContains   *string                  `json:"userId_not_contains,omitempty"`
	UserIdStartsWith    *string                  `json:"userId_starts_with,omitempty"`
	UserIdNotStartsWith *string                  `json:"userId_not_starts_with,omitempty"`
	UserIdEndsWith      *string                  `json:"userId_ends_with,omitempty"`
	UserIdNotEndsWith   *string                  `json:"userId_not_ends_with,omitempty"`
	WorkType            *int32                   `json:"workType,omitempty"`
	WorkTypeNot         *int32                   `json:"workType_not,omitempty"`
	WorkTypeIn          []int32                  `json:"workType_in,omitempty"`
	WorkTypeNotIn       []int32                  `json:"workType_not_in,omitempty"`
	WorkTypeLt          *int32                   `json:"workType_lt,omitempty"`
	WorkTypeLte         *int32                   `json:"workType_lte,omitempty"`
	WorkTypeGt          *int32                   `json:"workType_gt,omitempty"`
	WorkTypeGte         *int32                   `json:"workType_gte,omitempty"`
	Data                *string                  `json:"data,omitempty"`
	DataNot             *string                  `json:"data_not,omitempty"`
	DataIn              []string                 `json:"data_in,omitempty"`
	DataNotIn           []string                 `json:"data_not_in,omitempty"`
	DataLt              *string                  `json:"data_lt,omitempty"`
	DataLte             *string                  `json:"data_lte,omitempty"`
	DataGt              *string                  `json:"data_gt,omitempty"`
	DataGte             *string                  `json:"data_gte,omitempty"`
	DataContains        *string                  `json:"data_contains,omitempty"`
	DataNotContains     *string                  `json:"data_not_contains,omitempty"`
	DataStartsWith      *string                  `json:"data_starts_with,omitempty"`
	DataNotStartsWith   *string                  `json:"data_not_starts_with,omitempty"`
	DataEndsWith        *string                  `json:"data_ends_with,omitempty"`
	DataNotEndsWith     *string                  `json:"data_not_ends_with,omitempty"`
	CreatedAt           *string                  `json:"createdAt,omitempty"`
	CreatedAtNot        *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                  `json:"updatedAt_gte,omitempty"`
	DeletedAt           *int32                   `json:"deletedAt,omitempty"`
	DeletedAtNot        *int32                   `json:"deletedAt_not,omitempty"`
	DeletedAtIn         []int32                  `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn      []int32                  `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt         *int32                   `json:"deletedAt_lt,omitempty"`
	DeletedAtLte        *int32                   `json:"deletedAt_lte,omitempty"`
	DeletedAtGt         *int32                   `json:"deletedAt_gt,omitempty"`
	DeletedAtGte        *int32                   `json:"deletedAt_gte,omitempty"`
	And                 []WorkTemplateWhereInput `json:"AND,omitempty"`
	Or                  []WorkTemplateWhereInput `json:"OR,omitempty"`
	Not                 []WorkTemplateWhereInput `json:"NOT,omitempty"`
}

type CommonlyUsedPersonnelCreateInput struct {
	ID          *int32  `json:"id,omitempty"`
	CompanyId   int32   `json:"companyId"`
	AppId       string  `json:"appId"`
	UserId      string  `json:"userId"`
	Name        string  `json:"name"`
	Avatar      *string `json:"avatar,omitempty"`
	CardNo      string  `json:"cardNo"`
	Mobile      string  `json:"mobile"`
	BankNo      string  `json:"bankNo"`
	Education   *string `json:"education,omitempty"`
	Address     *string `json:"address,omitempty"`
	Remark      *string `json:"remark,omitempty"`
	SigningTime *int32  `json:"signingTime,omitempty"`
	DeletedAt   *int32  `json:"deletedAt,omitempty"`
}

type CommonlyUsedPersonnelUpdateInput struct {
	CompanyId   *int32  `json:"companyId,omitempty"`
	AppId       *string `json:"appId,omitempty"`
	UserId      *string `json:"userId,omitempty"`
	Name        *string `json:"name,omitempty"`
	Avatar      *string `json:"avatar,omitempty"`
	CardNo      *string `json:"cardNo,omitempty"`
	Mobile      *string `json:"mobile,omitempty"`
	BankNo      *string `json:"bankNo,omitempty"`
	Education   *string `json:"education,omitempty"`
	Address     *string `json:"address,omitempty"`
	Remark      *string `json:"remark,omitempty"`
	SigningTime *int32  `json:"signingTime,omitempty"`
	DeletedAt   *int32  `json:"deletedAt,omitempty"`
}

type CommonlyUsedPersonnelUpdateManyMutationInput struct {
	CompanyId   *int32  `json:"companyId,omitempty"`
	AppId       *string `json:"appId,omitempty"`
	UserId      *string `json:"userId,omitempty"`
	Name        *string `json:"name,omitempty"`
	Avatar      *string `json:"avatar,omitempty"`
	CardNo      *string `json:"cardNo,omitempty"`
	Mobile      *string `json:"mobile,omitempty"`
	BankNo      *string `json:"bankNo,omitempty"`
	Education   *string `json:"education,omitempty"`
	Address     *string `json:"address,omitempty"`
	Remark      *string `json:"remark,omitempty"`
	SigningTime *int32  `json:"signingTime,omitempty"`
	DeletedAt   *int32  `json:"deletedAt,omitempty"`
}

type CompanyUserBlacklistCreateInput struct {
	ID            *int32 `json:"id,omitempty"`
	CompanyId     int32  `json:"companyId"`
	ParticipantId string `json:"participantId"`
	PublisherId   string `json:"publisherId"`
	WorkId        *int32 `json:"workId,omitempty"`
	Type          *int32 `json:"type,omitempty"`
	DeletedAt     *int32 `json:"deletedAt,omitempty"`
}

type CompanyUserBlacklistUpdateInput struct {
	CompanyId     *int32  `json:"companyId,omitempty"`
	ParticipantId *string `json:"participantId,omitempty"`
	PublisherId   *string `json:"publisherId,omitempty"`
	WorkId        *int32  `json:"workId,omitempty"`
	Type          *int32  `json:"type,omitempty"`
	DeletedAt     *int32  `json:"deletedAt,omitempty"`
}

type CompanyUserBlacklistUpdateManyMutationInput struct {
	CompanyId     *int32  `json:"companyId,omitempty"`
	ParticipantId *string `json:"participantId,omitempty"`
	PublisherId   *string `json:"publisherId,omitempty"`
	WorkId        *int32  `json:"workId,omitempty"`
	Type          *int32  `json:"type,omitempty"`
	DeletedAt     *int32  `json:"deletedAt,omitempty"`
}

type CompanyUserKpiCreateInput struct {
	ID             *int32   `json:"id,omitempty"`
	WorkId         int32    `json:"workId"`
	Amount         *float64 `json:"amount,omitempty"`
	CompanyId      int32    `json:"companyId"`
	ParticipantId  string   `json:"participantId"`
	PayAt          *int32   `json:"payAt,omitempty"`
	PublisherId    string   `json:"publisherId"`
	IsPaid         *int32   `json:"isPaid,omitempty"`
	KpiCoefficient *float64 `json:"kpiCoefficient,omitempty"`
	Extend         *string  `json:"extend,omitempty"`
}

type CompanyUserKpiUpdateInput struct {
	WorkId         *int32   `json:"workId,omitempty"`
	Amount         *float64 `json:"amount,omitempty"`
	CompanyId      *int32   `json:"companyId,omitempty"`
	ParticipantId  *string  `json:"participantId,omitempty"`
	PayAt          *int32   `json:"payAt,omitempty"`
	PublisherId    *string  `json:"publisherId,omitempty"`
	IsPaid         *int32   `json:"isPaid,omitempty"`
	KpiCoefficient *float64 `json:"kpiCoefficient,omitempty"`
	Extend         *string  `json:"extend,omitempty"`
}

type CompanyUserKpiUpdateManyMutationInput struct {
	WorkId         *int32   `json:"workId,omitempty"`
	Amount         *float64 `json:"amount,omitempty"`
	CompanyId      *int32   `json:"companyId,omitempty"`
	ParticipantId  *string  `json:"participantId,omitempty"`
	PayAt          *int32   `json:"payAt,omitempty"`
	PublisherId    *string  `json:"publisherId,omitempty"`
	IsPaid         *int32   `json:"isPaid,omitempty"`
	KpiCoefficient *float64 `json:"kpiCoefficient,omitempty"`
	Extend         *string  `json:"extend,omitempty"`
}

type ImportLogsCreateInput struct {
	ID         *int32  `json:"id,omitempty"`
	FileHash   *string `json:"fileHash,omitempty"`
	Name       *string `json:"name,omitempty"`
	Mobile     *string `json:"mobile,omitempty"`
	CardNo     *string `json:"cardNo,omitempty"`
	Status     *int32  `json:"status,omitempty"`
	LogContent *string `json:"logContent,omitempty"`
}

type ImportLogsUpdateInput struct {
	FileHash   *string `json:"fileHash,omitempty"`
	Name       *string `json:"name,omitempty"`
	Mobile     *string `json:"mobile,omitempty"`
	CardNo     *string `json:"cardNo,omitempty"`
	Status     *int32  `json:"status,omitempty"`
	LogContent *string `json:"logContent,omitempty"`
}

type ImportLogsUpdateManyMutationInput struct {
	FileHash   *string `json:"fileHash,omitempty"`
	Name       *string `json:"name,omitempty"`
	Mobile     *string `json:"mobile,omitempty"`
	CardNo     *string `json:"cardNo,omitempty"`
	Status     *int32  `json:"status,omitempty"`
	LogContent *string `json:"logContent,omitempty"`
}

type JobCreateInput struct {
	ID               *int32   `json:"id,omitempty"`
	WorkId           int32    `json:"workId"`
	Category         int32    `json:"category"`
	SettlementRule   string   `json:"settlementRule"`
	PayStatus        *int32   `json:"payStatus,omitempty"`
	Progress         *int32   `json:"progress,omitempty"`
	Quota            *int32   `json:"quota,omitempty"`
	SingleRewardMax  *float64 `json:"singleRewardMax,omitempty"`
	SingleRewardMin  *float64 `json:"singleRewardMin,omitempty"`
	IsCanComment     *int32   `json:"isCanComment,omitempty"`
	IsNeedProof      *int32   `json:"isNeedProof,omitempty"`
	ProofDescription *string  `json:"proofDescription,omitempty"`
	ProofType        *int32   `json:"proofType,omitempty"`
	Remark           *string  `json:"remark,omitempty"`
	TemplateId       int32    `json:"templateId"`
	Extend           *string  `json:"extend,omitempty"`
	DeletedAt        *int32   `json:"deletedAt,omitempty"`
}

type JobUpdateInput struct {
	WorkId           *int32   `json:"workId,omitempty"`
	Category         *int32   `json:"category,omitempty"`
	SettlementRule   *string  `json:"settlementRule,omitempty"`
	PayStatus        *int32   `json:"payStatus,omitempty"`
	Progress         *int32   `json:"progress,omitempty"`
	Quota            *int32   `json:"quota,omitempty"`
	SingleRewardMax  *float64 `json:"singleRewardMax,omitempty"`
	SingleRewardMin  *float64 `json:"singleRewardMin,omitempty"`
	IsCanComment     *int32   `json:"isCanComment,omitempty"`
	IsNeedProof      *int32   `json:"isNeedProof,omitempty"`
	ProofDescription *string  `json:"proofDescription,omitempty"`
	ProofType        *int32   `json:"proofType,omitempty"`
	Remark           *string  `json:"remark,omitempty"`
	TemplateId       *int32   `json:"templateId,omitempty"`
	Extend           *string  `json:"extend,omitempty"`
	DeletedAt        *int32   `json:"deletedAt,omitempty"`
}

type JobUpdateManyMutationInput struct {
	WorkId           *int32   `json:"workId,omitempty"`
	Category         *int32   `json:"category,omitempty"`
	SettlementRule   *string  `json:"settlementRule,omitempty"`
	PayStatus        *int32   `json:"payStatus,omitempty"`
	Progress         *int32   `json:"progress,omitempty"`
	Quota            *int32   `json:"quota,omitempty"`
	SingleRewardMax  *float64 `json:"singleRewardMax,omitempty"`
	SingleRewardMin  *float64 `json:"singleRewardMin,omitempty"`
	IsCanComment     *int32   `json:"isCanComment,omitempty"`
	IsNeedProof      *int32   `json:"isNeedProof,omitempty"`
	ProofDescription *string  `json:"proofDescription,omitempty"`
	ProofType        *int32   `json:"proofType,omitempty"`
	Remark           *string  `json:"remark,omitempty"`
	TemplateId       *int32   `json:"templateId,omitempty"`
	Extend           *string  `json:"extend,omitempty"`
	DeletedAt        *int32   `json:"deletedAt,omitempty"`
}

type JobAchievementCreateInput struct {
	ID        *int32  `json:"id,omitempty"`
	JobId     int32   `json:"jobId"`
	UserId    string  `json:"userId"`
	Extend    *string `json:"extend,omitempty"`
	DeletedAt *int32  `json:"deletedAt,omitempty"`
}

type JobAchievementUpdateInput struct {
	JobId     *int32  `json:"jobId,omitempty"`
	UserId    *string `json:"userId,omitempty"`
	Extend    *string `json:"extend,omitempty"`
	DeletedAt *int32  `json:"deletedAt,omitempty"`
}

type JobAchievementUpdateManyMutationInput struct {
	JobId     *int32  `json:"jobId,omitempty"`
	UserId    *string `json:"userId,omitempty"`
	Extend    *string `json:"extend,omitempty"`
	DeletedAt *int32  `json:"deletedAt,omitempty"`
}

type JobContractJournalCreateInput struct {
	ID               *int32  `json:"id,omitempty"`
	ContractNo       *string `json:"contractNo,omitempty"`
	CompanyId        int32   `json:"companyId"`
	ServiceCompanyId int32   `json:"serviceCompanyId"`
	BeginTimestamp   int32   `json:"beginTimestamp"`
	EndTimestamp     int32   `json:"endTimestamp"`
	ActiveTimestamp  int32   `json:"activeTimestamp"`
	IsHandled        int32   `json:"isHandled"`
	Extend           *string `json:"extend,omitempty"`
	Remark           *string `json:"remark,omitempty"`
	DeletedAt        *int32  `json:"deletedAt,omitempty"`
}

type JobContractJournalUpdateInput struct {
	ContractNo       *string `json:"contractNo,omitempty"`
	CompanyId        *int32  `json:"companyId,omitempty"`
	ServiceCompanyId *int32  `json:"serviceCompanyId,omitempty"`
	BeginTimestamp   *int32  `json:"beginTimestamp,omitempty"`
	EndTimestamp     *int32  `json:"endTimestamp,omitempty"`
	ActiveTimestamp  *int32  `json:"activeTimestamp,omitempty"`
	IsHandled        *int32  `json:"isHandled,omitempty"`
	Extend           *string `json:"extend,omitempty"`
	Remark           *string `json:"remark,omitempty"`
	DeletedAt        *int32  `json:"deletedAt,omitempty"`
}

type JobContractJournalUpdateManyMutationInput struct {
	ContractNo       *string `json:"contractNo,omitempty"`
	CompanyId        *int32  `json:"companyId,omitempty"`
	ServiceCompanyId *int32  `json:"serviceCompanyId,omitempty"`
	BeginTimestamp   *int32  `json:"beginTimestamp,omitempty"`
	EndTimestamp     *int32  `json:"endTimestamp,omitempty"`
	ActiveTimestamp  *int32  `json:"activeTimestamp,omitempty"`
	IsHandled        *int32  `json:"isHandled,omitempty"`
	Extend           *string `json:"extend,omitempty"`
	Remark           *string `json:"remark,omitempty"`
	DeletedAt        *int32  `json:"deletedAt,omitempty"`
}

type JobMemberCreateInput struct {
	ID            *int32   `json:"id,omitempty"`
	WorkId        int32    `json:"workId"`
	CompanyId     int32    `json:"companyId"`
	PublisherId   string   `json:"publisherId"`
	ParticipantId *string  `json:"participantId,omitempty"`
	Source        *int32   `json:"source,omitempty"`
	Progress      *int32   `json:"progress,omitempty"`
	ProofFileUrl  *string  `json:"proofFileUrl,omitempty"`
	Reward        *float64 `json:"reward,omitempty"`
	ParticipateAt *int32   `json:"participateAt,omitempty"`
	FinishAt      *int32   `json:"finishAt,omitempty"`
	Remark        *string  `json:"remark,omitempty"`
	Extend        *string  `json:"extend,omitempty"`
	DeletedAt     *int32   `json:"deletedAt,omitempty"`
}

type JobMemberUpdateInput struct {
	WorkId        *int32   `json:"workId,omitempty"`
	CompanyId     *int32   `json:"companyId,omitempty"`
	PublisherId   *string  `json:"publisherId,omitempty"`
	ParticipantId *string  `json:"participantId,omitempty"`
	Source        *int32   `json:"source,omitempty"`
	Progress      *int32   `json:"progress,omitempty"`
	ProofFileUrl  *string  `json:"proofFileUrl,omitempty"`
	Reward        *float64 `json:"reward,omitempty"`
	ParticipateAt *int32   `json:"participateAt,omitempty"`
	FinishAt      *int32   `json:"finishAt,omitempty"`
	Remark        *string  `json:"remark,omitempty"`
	Extend        *string  `json:"extend,omitempty"`
	DeletedAt     *int32   `json:"deletedAt,omitempty"`
}

type JobMemberUpdateManyMutationInput struct {
	WorkId        *int32   `json:"workId,omitempty"`
	CompanyId     *int32   `json:"companyId,omitempty"`
	PublisherId   *string  `json:"publisherId,omitempty"`
	ParticipantId *string  `json:"participantId,omitempty"`
	Source        *int32   `json:"source,omitempty"`
	Progress      *int32   `json:"progress,omitempty"`
	ProofFileUrl  *string  `json:"proofFileUrl,omitempty"`
	Reward        *float64 `json:"reward,omitempty"`
	ParticipateAt *int32   `json:"participateAt,omitempty"`
	FinishAt      *int32   `json:"finishAt,omitempty"`
	Remark        *string  `json:"remark,omitempty"`
	Extend        *string  `json:"extend,omitempty"`
	DeletedAt     *int32   `json:"deletedAt,omitempty"`
}

type JobTemplateCreateInput struct {
	ID                 *int32  `json:"id,omitempty"`
	AppId              *string `json:"appId,omitempty"`
	PlatformAppid      *string `json:"platformAppid,omitempty"`
	CompanyId          *int32  `json:"companyId,omitempty"`
	CompanyName        *string `json:"companyName,omitempty"`
	ServiceCompanyId   *int32  `json:"serviceCompanyId,omitempty"`
	ServiceCompanyName *string `json:"serviceCompanyName,omitempty"`
	UserId             *string `json:"userId,omitempty"`
	WorkType           int32   `json:"workType"`
	SignTemplateId     *int32  `json:"signTemplateId,omitempty"`
	ServiceTypeId      int32   `json:"serviceTypeId"`
	ServiceTypeName    *string `json:"serviceTypeName,omitempty"`
	Name               string  `json:"name"`
	Requirement        string  `json:"requirement"`
	SettlementRule     string  `json:"settlementRule"`
	KpiTemplateUrl     *string `json:"kpiTemplateUrl,omitempty"`
	DownloadCode       *string `json:"downloadCode,omitempty"`
	DisplayName        *string `json:"displayName,omitempty"`
	IsEnable           int32   `json:"isEnable"`
	Source             int32   `json:"source"`
	Extend             *string `json:"extend,omitempty"`
	BizContent         *string `json:"bizContent,omitempty"`
	Remark             *string `json:"remark,omitempty"`
	ContractNo         *string `json:"contractNo,omitempty"`
	DeletedAt          *int32  `json:"deletedAt,omitempty"`
}

type JobTemplateUpdateInput struct {
	AppId              *string `json:"appId,omitempty"`
	PlatformAppid      *string `json:"platformAppid,omitempty"`
	CompanyId          *int32  `json:"companyId,omitempty"`
	CompanyName        *string `json:"companyName,omitempty"`
	ServiceCompanyId   *int32  `json:"serviceCompanyId,omitempty"`
	ServiceCompanyName *string `json:"serviceCompanyName,omitempty"`
	UserId             *string `json:"userId,omitempty"`
	WorkType           *int32  `json:"workType,omitempty"`
	SignTemplateId     *int32  `json:"signTemplateId,omitempty"`
	ServiceTypeId      *int32  `json:"serviceTypeId,omitempty"`
	ServiceTypeName    *string `json:"serviceTypeName,omitempty"`
	Name               *string `json:"name,omitempty"`
	Requirement        *string `json:"requirement,omitempty"`
	SettlementRule     *string `json:"settlementRule,omitempty"`
	KpiTemplateUrl     *string `json:"kpiTemplateUrl,omitempty"`
	DownloadCode       *string `json:"downloadCode,omitempty"`
	DisplayName        *string `json:"displayName,omitempty"`
	IsEnable           *int32  `json:"isEnable,omitempty"`
	Source             *int32  `json:"source,omitempty"`
	Extend             *string `json:"extend,omitempty"`
	BizContent         *string `json:"bizContent,omitempty"`
	Remark             *string `json:"remark,omitempty"`
	ContractNo         *string `json:"contractNo,omitempty"`
	DeletedAt          *int32  `json:"deletedAt,omitempty"`
}

type JobTemplateUpdateManyMutationInput struct {
	AppId              *string `json:"appId,omitempty"`
	PlatformAppid      *string `json:"platformAppid,omitempty"`
	CompanyId          *int32  `json:"companyId,omitempty"`
	CompanyName        *string `json:"companyName,omitempty"`
	ServiceCompanyId   *int32  `json:"serviceCompanyId,omitempty"`
	ServiceCompanyName *string `json:"serviceCompanyName,omitempty"`
	UserId             *string `json:"userId,omitempty"`
	WorkType           *int32  `json:"workType,omitempty"`
	SignTemplateId     *int32  `json:"signTemplateId,omitempty"`
	ServiceTypeId      *int32  `json:"serviceTypeId,omitempty"`
	ServiceTypeName    *string `json:"serviceTypeName,omitempty"`
	Name               *string `json:"name,omitempty"`
	Requirement        *string `json:"requirement,omitempty"`
	SettlementRule     *string `json:"settlementRule,omitempty"`
	KpiTemplateUrl     *string `json:"kpiTemplateUrl,omitempty"`
	DownloadCode       *string `json:"downloadCode,omitempty"`
	DisplayName        *string `json:"displayName,omitempty"`
	IsEnable           *int32  `json:"isEnable,omitempty"`
	Source             *int32  `json:"source,omitempty"`
	Extend             *string `json:"extend,omitempty"`
	BizContent         *string `json:"bizContent,omitempty"`
	Remark             *string `json:"remark,omitempty"`
	ContractNo         *string `json:"contractNo,omitempty"`
	DeletedAt          *int32  `json:"deletedAt,omitempty"`
}

type JobTemplateDelayCreateInput struct {
	ID                 *int32  `json:"id,omitempty"`
	ContractNo         *string `json:"contractNo,omitempty"`
	CompanyId          *int32  `json:"companyId,omitempty"`
	ServiceCompanyId   *int32  `json:"serviceCompanyId,omitempty"`
	BeginTimestamp     *int32  `json:"beginTimestamp,omitempty"`
	EndTimestamp       *int32  `json:"endTimestamp,omitempty"`
	IsNeedProcessBegin *int32  `json:"isNeedProcessBegin,omitempty"`
	IsNeedProcessEnd   *int32  `json:"isNeedProcessEnd,omitempty"`
	Extend             *string `json:"extend,omitempty"`
	BizContent         *string `json:"bizContent,omitempty"`
	Remark             *string `json:"remark,omitempty"`
	DeletedAt          *int32  `json:"deletedAt,omitempty"`
}

type JobTemplateDelayUpdateInput struct {
	ContractNo         *string `json:"contractNo,omitempty"`
	CompanyId          *int32  `json:"companyId,omitempty"`
	ServiceCompanyId   *int32  `json:"serviceCompanyId,omitempty"`
	BeginTimestamp     *int32  `json:"beginTimestamp,omitempty"`
	EndTimestamp       *int32  `json:"endTimestamp,omitempty"`
	IsNeedProcessBegin *int32  `json:"isNeedProcessBegin,omitempty"`
	IsNeedProcessEnd   *int32  `json:"isNeedProcessEnd,omitempty"`
	Extend             *string `json:"extend,omitempty"`
	BizContent         *string `json:"bizContent,omitempty"`
	Remark             *string `json:"remark,omitempty"`
	DeletedAt          *int32  `json:"deletedAt,omitempty"`
}

type JobTemplateDelayUpdateManyMutationInput struct {
	ContractNo         *string `json:"contractNo,omitempty"`
	CompanyId          *int32  `json:"companyId,omitempty"`
	ServiceCompanyId   *int32  `json:"serviceCompanyId,omitempty"`
	BeginTimestamp     *int32  `json:"beginTimestamp,omitempty"`
	EndTimestamp       *int32  `json:"endTimestamp,omitempty"`
	IsNeedProcessBegin *int32  `json:"isNeedProcessBegin,omitempty"`
	IsNeedProcessEnd   *int32  `json:"isNeedProcessEnd,omitempty"`
	Extend             *string `json:"extend,omitempty"`
	BizContent         *string `json:"bizContent,omitempty"`
	Remark             *string `json:"remark,omitempty"`
	DeletedAt          *int32  `json:"deletedAt,omitempty"`
}

type KpiUploadLogCreateInput struct {
	ID        *int32  `json:"id,omitempty"`
	CompanyId int32   `json:"companyId"`
	FileName  *string `json:"fileName,omitempty"`
	FileUrl   *string `json:"fileUrl,omitempty"`
	Hash      string  `json:"hash"`
}

type KpiUploadLogUpdateInput struct {
	CompanyId *int32  `json:"companyId,omitempty"`
	FileName  *string `json:"fileName,omitempty"`
	FileUrl   *string `json:"fileUrl,omitempty"`
	Hash      *string `json:"hash,omitempty"`
}

type KpiUploadLogUpdateManyMutationInput struct {
	CompanyId *int32  `json:"companyId,omitempty"`
	FileName  *string `json:"fileName,omitempty"`
	FileUrl   *string `json:"fileUrl,omitempty"`
	Hash      *string `json:"hash,omitempty"`
}

type UserWeChatAuthorizeCreateInput struct {
	ID        *int32 `json:"id,omitempty"`
	UserId    string `json:"userId"`
	Mobile    string `json:"mobile"`
	DeletedAt *int32 `json:"deletedAt,omitempty"`
}

type UserWeChatAuthorizeUpdateInput struct {
	UserId    *string `json:"userId,omitempty"`
	Mobile    *string `json:"mobile,omitempty"`
	DeletedAt *int32  `json:"deletedAt,omitempty"`
}

type UserWeChatAuthorizeUpdateManyMutationInput struct {
	UserId    *string `json:"userId,omitempty"`
	Mobile    *string `json:"mobile,omitempty"`
	DeletedAt *int32  `json:"deletedAt,omitempty"`
}

type WorkCreateInput struct {
	ID            *int32  `json:"id,omitempty"`
	AppId         string  `json:"appId"`
	CompanyId     int32   `json:"companyId"`
	UserId        string  `json:"userId"`
	ServiceTypeId int32   `json:"serviceTypeId"`
	WorkType      int32   `json:"workType"`
	Name          string  `json:"name"`
	Requirement   string  `json:"requirement"`
	PayType       *int32  `json:"payType,omitempty"`
	Duration      *int32  `json:"duration,omitempty"`
	EndAt         *int32  `json:"endAt,omitempty"`
	Source        *int32  `json:"source,omitempty"`
	Status        *int32  `json:"status,omitempty"`
	Type          *int32  `json:"type,omitempty"`
	IsPublic      *int32  `json:"isPublic,omitempty"`
	MediaCoverUrl *string `json:"mediaCoverUrl,omitempty"`
	MediaUrls     *string `json:"mediaUrls,omitempty"`
	Resume        *string `json:"resume,omitempty"`
	Extend        *string `json:"extend,omitempty"`
	DeletedAt     *int32  `json:"deletedAt,omitempty"`
}

type WorkUpdateInput struct {
	AppId         *string `json:"appId,omitempty"`
	CompanyId     *int32  `json:"companyId,omitempty"`
	UserId        *string `json:"userId,omitempty"`
	ServiceTypeId *int32  `json:"serviceTypeId,omitempty"`
	WorkType      *int32  `json:"workType,omitempty"`
	Name          *string `json:"name,omitempty"`
	Requirement   *string `json:"requirement,omitempty"`
	PayType       *int32  `json:"payType,omitempty"`
	Duration      *int32  `json:"duration,omitempty"`
	EndAt         *int32  `json:"endAt,omitempty"`
	Source        *int32  `json:"source,omitempty"`
	Status        *int32  `json:"status,omitempty"`
	Type          *int32  `json:"type,omitempty"`
	IsPublic      *int32  `json:"isPublic,omitempty"`
	MediaCoverUrl *string `json:"mediaCoverUrl,omitempty"`
	MediaUrls     *string `json:"mediaUrls,omitempty"`
	Resume        *string `json:"resume,omitempty"`
	Extend        *string `json:"extend,omitempty"`
	DeletedAt     *int32  `json:"deletedAt,omitempty"`
}

type WorkUpdateManyMutationInput struct {
	AppId         *string `json:"appId,omitempty"`
	CompanyId     *int32  `json:"companyId,omitempty"`
	UserId        *string `json:"userId,omitempty"`
	ServiceTypeId *int32  `json:"serviceTypeId,omitempty"`
	WorkType      *int32  `json:"workType,omitempty"`
	Name          *string `json:"name,omitempty"`
	Requirement   *string `json:"requirement,omitempty"`
	PayType       *int32  `json:"payType,omitempty"`
	Duration      *int32  `json:"duration,omitempty"`
	EndAt         *int32  `json:"endAt,omitempty"`
	Source        *int32  `json:"source,omitempty"`
	Status        *int32  `json:"status,omitempty"`
	Type          *int32  `json:"type,omitempty"`
	IsPublic      *int32  `json:"isPublic,omitempty"`
	MediaCoverUrl *string `json:"mediaCoverUrl,omitempty"`
	MediaUrls     *string `json:"mediaUrls,omitempty"`
	Resume        *string `json:"resume,omitempty"`
	Extend        *string `json:"extend,omitempty"`
	DeletedAt     *int32  `json:"deletedAt,omitempty"`
}

type WorkExtendCreateInput struct {
	ID           *int32  `json:"id,omitempty"`
	WorkId       int32   `json:"workId"`
	AppId        string  `json:"appId"`
	FocusCount   *int32  `json:"focusCount,omitempty"`
	LikeCount    *int32  `json:"likeCount,omitempty"`
	ShareCount   *int32  `json:"shareCount,omitempty"`
	CommentCount *int32  `json:"commentCount,omitempty"`
	Extend       *string `json:"extend,omitempty"`
	DeletedAt    *int32  `json:"deletedAt,omitempty"`
}

type WorkExtendUpdateInput struct {
	WorkId       *int32  `json:"workId,omitempty"`
	AppId        *string `json:"appId,omitempty"`
	FocusCount   *int32  `json:"focusCount,omitempty"`
	LikeCount    *int32  `json:"likeCount,omitempty"`
	ShareCount   *int32  `json:"shareCount,omitempty"`
	CommentCount *int32  `json:"commentCount,omitempty"`
	Extend       *string `json:"extend,omitempty"`
	DeletedAt    *int32  `json:"deletedAt,omitempty"`
}

type WorkExtendUpdateManyMutationInput struct {
	WorkId       *int32  `json:"workId,omitempty"`
	AppId        *string `json:"appId,omitempty"`
	FocusCount   *int32  `json:"focusCount,omitempty"`
	LikeCount    *int32  `json:"likeCount,omitempty"`
	ShareCount   *int32  `json:"shareCount,omitempty"`
	CommentCount *int32  `json:"commentCount,omitempty"`
	Extend       *string `json:"extend,omitempty"`
	DeletedAt    *int32  `json:"deletedAt,omitempty"`
}

type WorkProgressCreateInput struct {
	ID            *int32  `json:"id,omitempty"`
	AppId         string  `json:"appId"`
	ParticipantId *string `json:"participantId,omitempty"`
	PublisherId   string  `json:"publisherId"`
	WorkId        int32   `json:"workId"`
	Type          string  `json:"type"`
	Extend        *string `json:"extend,omitempty"`
}

type WorkProgressUpdateInput struct {
	AppId         *string `json:"appId,omitempty"`
	ParticipantId *string `json:"participantId,omitempty"`
	PublisherId   *string `json:"publisherId,omitempty"`
	WorkId        *int32  `json:"workId,omitempty"`
	Type          *string `json:"type,omitempty"`
	Extend        *string `json:"extend,omitempty"`
}

type WorkProgressUpdateManyMutationInput struct {
	AppId         *string `json:"appId,omitempty"`
	ParticipantId *string `json:"participantId,omitempty"`
	PublisherId   *string `json:"publisherId,omitempty"`
	WorkId        *int32  `json:"workId,omitempty"`
	Type          *string `json:"type,omitempty"`
	Extend        *string `json:"extend,omitempty"`
}

type WorkTemplateCreateInput struct {
	ID        *int32 `json:"id,omitempty"`
	CompanyId int32  `json:"companyId"`
	UserId    string `json:"userId"`
	WorkType  int32  `json:"workType"`
	Data      string `json:"data"`
	DeletedAt *int32 `json:"deletedAt,omitempty"`
}

type WorkTemplateUpdateInput struct {
	CompanyId *int32  `json:"companyId,omitempty"`
	UserId    *string `json:"userId,omitempty"`
	WorkType  *int32  `json:"workType,omitempty"`
	Data      *string `json:"data,omitempty"`
	DeletedAt *int32  `json:"deletedAt,omitempty"`
}

type WorkTemplateUpdateManyMutationInput struct {
	CompanyId *int32  `json:"companyId,omitempty"`
	UserId    *string `json:"userId,omitempty"`
	WorkType  *int32  `json:"workType,omitempty"`
	Data      *string `json:"data,omitempty"`
	DeletedAt *int32  `json:"deletedAt,omitempty"`
}

type CommonlyUsedPersonnelSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *CommonlyUsedPersonnelWhereInput              `json:"node,omitempty"`
	And                        []CommonlyUsedPersonnelSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CommonlyUsedPersonnelSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CommonlyUsedPersonnelSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CompanyUserBlacklistSubscriptionWhereInput struct {
	MutationIn                 []MutationType                               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *CompanyUserBlacklistWhereInput              `json:"node,omitempty"`
	And                        []CompanyUserBlacklistSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CompanyUserBlacklistSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CompanyUserBlacklistSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CompanyUserKpiSubscriptionWhereInput struct {
	MutationIn                 []MutationType                         `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                               `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                               `json:"updatedFields_contains_some,omitempty"`
	Node                       *CompanyUserKpiWhereInput              `json:"node,omitempty"`
	And                        []CompanyUserKpiSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CompanyUserKpiSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CompanyUserKpiSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ImportLogsSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *ImportLogsWhereInput              `json:"node,omitempty"`
	And                        []ImportLogsSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ImportLogsSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ImportLogsSubscriptionWhereInput `json:"NOT,omitempty"`
}

type JobSubscriptionWhereInput struct {
	MutationIn                 []MutationType              `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                    `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                    `json:"updatedFields_contains_some,omitempty"`
	Node                       *JobWhereInput              `json:"node,omitempty"`
	And                        []JobSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []JobSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []JobSubscriptionWhereInput `json:"NOT,omitempty"`
}

type JobAchievementSubscriptionWhereInput struct {
	MutationIn                 []MutationType                         `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                               `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                               `json:"updatedFields_contains_some,omitempty"`
	Node                       *JobAchievementWhereInput              `json:"node,omitempty"`
	And                        []JobAchievementSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []JobAchievementSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []JobAchievementSubscriptionWhereInput `json:"NOT,omitempty"`
}

type JobContractJournalSubscriptionWhereInput struct {
	MutationIn                 []MutationType                             `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                    `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                   `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                   `json:"updatedFields_contains_some,omitempty"`
	Node                       *JobContractJournalWhereInput              `json:"node,omitempty"`
	And                        []JobContractJournalSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []JobContractJournalSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []JobContractJournalSubscriptionWhereInput `json:"NOT,omitempty"`
}

type JobMemberSubscriptionWhereInput struct {
	MutationIn                 []MutationType                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *JobMemberWhereInput              `json:"node,omitempty"`
	And                        []JobMemberSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []JobMemberSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []JobMemberSubscriptionWhereInput `json:"NOT,omitempty"`
}

type JobTemplateSubscriptionWhereInput struct {
	MutationIn                 []MutationType                      `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                             `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                            `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                            `json:"updatedFields_contains_some,omitempty"`
	Node                       *JobTemplateWhereInput              `json:"node,omitempty"`
	And                        []JobTemplateSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []JobTemplateSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []JobTemplateSubscriptionWhereInput `json:"NOT,omitempty"`
}

type JobTemplateDelaySubscriptionWhereInput struct {
	MutationIn                 []MutationType                           `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                  `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                 `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                 `json:"updatedFields_contains_some,omitempty"`
	Node                       *JobTemplateDelayWhereInput              `json:"node,omitempty"`
	And                        []JobTemplateDelaySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []JobTemplateDelaySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []JobTemplateDelaySubscriptionWhereInput `json:"NOT,omitempty"`
}

type KpiUploadLogSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *KpiUploadLogWhereInput              `json:"node,omitempty"`
	And                        []KpiUploadLogSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []KpiUploadLogSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []KpiUploadLogSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserWeChatAuthorizeSubscriptionWhereInput struct {
	MutationIn                 []MutationType                              `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                    `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                    `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWeChatAuthorizeWhereInput              `json:"node,omitempty"`
	And                        []UserWeChatAuthorizeSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserWeChatAuthorizeSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserWeChatAuthorizeSubscriptionWhereInput `json:"NOT,omitempty"`
}

type WorkSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *WorkWhereInput              `json:"node,omitempty"`
	And                        []WorkSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []WorkSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []WorkSubscriptionWhereInput `json:"NOT,omitempty"`
}

type WorkExtendSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *WorkExtendWhereInput              `json:"node,omitempty"`
	And                        []WorkExtendSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []WorkExtendSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []WorkExtendSubscriptionWhereInput `json:"NOT,omitempty"`
}

type WorkProgressSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *WorkProgressWhereInput              `json:"node,omitempty"`
	And                        []WorkProgressSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []WorkProgressSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []WorkProgressSubscriptionWhereInput `json:"NOT,omitempty"`
}

type WorkTemplateSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *WorkTemplateWhereInput              `json:"node,omitempty"`
	And                        []WorkTemplateSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []WorkTemplateSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []WorkTemplateSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CommonlyUsedPersonnelExec struct {
	exec *prisma.Exec
}

func (instance CommonlyUsedPersonnelExec) Exec(ctx context.Context) (*CommonlyUsedPersonnel, error) {
	var v CommonlyUsedPersonnel
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommonlyUsedPersonnelExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommonlyUsedPersonnelExecArray struct {
	exec *prisma.Exec
}

func (instance CommonlyUsedPersonnelExecArray) Exec(ctx context.Context) ([]CommonlyUsedPersonnel, error) {
	var v []CommonlyUsedPersonnel
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CommonlyUsedPersonnel struct {
	ID          int32   `json:"id"`
	CompanyId   int32   `json:"companyId"`
	AppId       string  `json:"appId"`
	UserId      string  `json:"userId"`
	Name        string  `json:"name"`
	Avatar      *string `json:"avatar,omitempty"`
	CardNo      string  `json:"cardNo"`
	Mobile      string  `json:"mobile"`
	BankNo      string  `json:"bankNo"`
	Education   *string `json:"education,omitempty"`
	Address     *string `json:"address,omitempty"`
	Remark      *string `json:"remark,omitempty"`
	SigningTime *int32  `json:"signingTime,omitempty"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
	DeletedAt   *int32  `json:"deletedAt,omitempty"`
}

type CommonlyUsedPersonnelConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CommonlyUsedPersonnelConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CommonlyUsedPersonnelConnectionExec) Edges() *CommonlyUsedPersonnelEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CommonlyUsedPersonnelWhereInput", "CommonlyUsedPersonnelOrderByInput", "CommonlyUsedPersonnelEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "CommonlyUsedPersonnel"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &CommonlyUsedPersonnelEdgeExecArray{nodes}
}

func (instance *CommonlyUsedPersonnelConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCommonlyUsedPersonnel"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CommonlyUsedPersonnelConnectionExec) Exec(ctx context.Context) (*CommonlyUsedPersonnelConnection, error) {
	var v CommonlyUsedPersonnelConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommonlyUsedPersonnelConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommonlyUsedPersonnelConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CommonlyUsedPersonnelConnectionExecArray) Exec(ctx context.Context) ([]CommonlyUsedPersonnelConnection, error) {
	var v []CommonlyUsedPersonnelConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CommonlyUsedPersonnelConnection struct {
	PageInfo PageInfo                    `json:"pageInfo"`
	Edges    []CommonlyUsedPersonnelEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type CommonlyUsedPersonnelEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CommonlyUsedPersonnelEdgeExec) Node() *CommonlyUsedPersonnelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CommonlyUsedPersonnel"},
		"node",
		[]string{"id", "companyId", "appId", "userId", "name", "avatar", "cardNo", "mobile", "bankNo", "education", "address", "remark", "signingTime", "createdAt", "updatedAt", "deletedAt"})

	return &CommonlyUsedPersonnelExec{ret}
}

func (instance CommonlyUsedPersonnelEdgeExec) Exec(ctx context.Context) (*CommonlyUsedPersonnelEdge, error) {
	var v CommonlyUsedPersonnelEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommonlyUsedPersonnelEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommonlyUsedPersonnelEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CommonlyUsedPersonnelEdgeExecArray) Exec(ctx context.Context) ([]CommonlyUsedPersonnelEdge, error) {
	var v []CommonlyUsedPersonnelEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CommonlyUsedPersonnelEdge struct {
	Node   CommonlyUsedPersonnel `json:"node"`
	Cursor string                `json:"cursor"`
}

type CompanyUserBlacklistExec struct {
	exec *prisma.Exec
}

func (instance CompanyUserBlacklistExec) Exec(ctx context.Context) (*CompanyUserBlacklist, error) {
	var v CompanyUserBlacklist
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyUserBlacklistExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyUserBlacklistExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyUserBlacklistExecArray) Exec(ctx context.Context) ([]CompanyUserBlacklist, error) {
	var v []CompanyUserBlacklist
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyUserBlacklist struct {
	ID            int32  `json:"id"`
	CompanyId     int32  `json:"companyId"`
	ParticipantId string `json:"participantId"`
	PublisherId   string `json:"publisherId"`
	WorkId        *int32 `json:"workId,omitempty"`
	Type          *int32 `json:"type,omitempty"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
	DeletedAt     *int32 `json:"deletedAt,omitempty"`
}

type CompanyUserBlacklistConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CompanyUserBlacklistConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CompanyUserBlacklistConnectionExec) Edges() *CompanyUserBlacklistEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CompanyUserBlacklistWhereInput", "CompanyUserBlacklistOrderByInput", "CompanyUserBlacklistEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "CompanyUserBlacklist"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &CompanyUserBlacklistEdgeExecArray{nodes}
}

func (instance *CompanyUserBlacklistConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCompanyUserBlacklist"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CompanyUserBlacklistConnectionExec) Exec(ctx context.Context) (*CompanyUserBlacklistConnection, error) {
	var v CompanyUserBlacklistConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyUserBlacklistConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyUserBlacklistConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyUserBlacklistConnectionExecArray) Exec(ctx context.Context) ([]CompanyUserBlacklistConnection, error) {
	var v []CompanyUserBlacklistConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyUserBlacklistConnection struct {
	PageInfo PageInfo                   `json:"pageInfo"`
	Edges    []CompanyUserBlacklistEdge `json:"edges"`
}

type CompanyUserBlacklistEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CompanyUserBlacklistEdgeExec) Node() *CompanyUserBlacklistExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CompanyUserBlacklist"},
		"node",
		[]string{"id", "companyId", "participantId", "publisherId", "workId", "type", "createdAt", "updatedAt", "deletedAt"})

	return &CompanyUserBlacklistExec{ret}
}

func (instance CompanyUserBlacklistEdgeExec) Exec(ctx context.Context) (*CompanyUserBlacklistEdge, error) {
	var v CompanyUserBlacklistEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyUserBlacklistEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyUserBlacklistEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyUserBlacklistEdgeExecArray) Exec(ctx context.Context) ([]CompanyUserBlacklistEdge, error) {
	var v []CompanyUserBlacklistEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyUserBlacklistEdge struct {
	Node   CompanyUserBlacklist `json:"node"`
	Cursor string               `json:"cursor"`
}

type CompanyUserKpiExec struct {
	exec *prisma.Exec
}

func (instance CompanyUserKpiExec) Exec(ctx context.Context) (*CompanyUserKpi, error) {
	var v CompanyUserKpi
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyUserKpiExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyUserKpiExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyUserKpiExecArray) Exec(ctx context.Context) ([]CompanyUserKpi, error) {
	var v []CompanyUserKpi
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyUserKpi struct {
	ID             int32    `json:"id"`
	WorkId         int32    `json:"workId"`
	Amount         *float64 `json:"amount,omitempty"`
	CompanyId      int32    `json:"companyId"`
	ParticipantId  string   `json:"participantId"`
	PayAt          *int32   `json:"payAt,omitempty"`
	PublisherId    string   `json:"publisherId"`
	IsPaid         int32    `json:"isPaid"`
	KpiCoefficient *float64 `json:"kpiCoefficient,omitempty"`
	Extend         *string  `json:"extend,omitempty"`
	CreatedAt      string   `json:"createdAt"`
	UpdatedAt      string   `json:"updatedAt"`
}

type CompanyUserKpiConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CompanyUserKpiConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CompanyUserKpiConnectionExec) Edges() *CompanyUserKpiEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CompanyUserKpiWhereInput", "CompanyUserKpiOrderByInput", "CompanyUserKpiEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "CompanyUserKpi"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &CompanyUserKpiEdgeExecArray{nodes}
}

func (instance *CompanyUserKpiConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCompanyUserKpi"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CompanyUserKpiConnectionExec) Exec(ctx context.Context) (*CompanyUserKpiConnection, error) {
	var v CompanyUserKpiConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyUserKpiConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyUserKpiConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyUserKpiConnectionExecArray) Exec(ctx context.Context) ([]CompanyUserKpiConnection, error) {
	var v []CompanyUserKpiConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyUserKpiConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []CompanyUserKpiEdge `json:"edges"`
}

type CompanyUserKpiEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CompanyUserKpiEdgeExec) Node() *CompanyUserKpiExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CompanyUserKpi"},
		"node",
		[]string{"id", "workId", "amount", "companyId", "participantId", "payAt", "publisherId", "isPaid", "kpiCoefficient", "extend", "createdAt", "updatedAt"})

	return &CompanyUserKpiExec{ret}
}

func (instance CompanyUserKpiEdgeExec) Exec(ctx context.Context) (*CompanyUserKpiEdge, error) {
	var v CompanyUserKpiEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyUserKpiEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyUserKpiEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyUserKpiEdgeExecArray) Exec(ctx context.Context) ([]CompanyUserKpiEdge, error) {
	var v []CompanyUserKpiEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyUserKpiEdge struct {
	Node   CompanyUserKpi `json:"node"`
	Cursor string         `json:"cursor"`
}

type ImportLogsExec struct {
	exec *prisma.Exec
}

func (instance ImportLogsExec) Exec(ctx context.Context) (*ImportLogs, error) {
	var v ImportLogs
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImportLogsExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImportLogsExecArray struct {
	exec *prisma.Exec
}

func (instance ImportLogsExecArray) Exec(ctx context.Context) ([]ImportLogs, error) {
	var v []ImportLogs
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImportLogs struct {
	ID         int32   `json:"id"`
	FileHash   *string `json:"fileHash,omitempty"`
	Name       *string `json:"name,omitempty"`
	Mobile     *string `json:"mobile,omitempty"`
	CardNo     *string `json:"cardNo,omitempty"`
	Status     *int32  `json:"status,omitempty"`
	LogContent *string `json:"logContent,omitempty"`
	CreatedAt  string  `json:"createdAt"`
	UpdatedAt  string  `json:"updatedAt"`
}

type ImportLogsConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ImportLogsConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ImportLogsConnectionExec) Edges() *ImportLogsEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ImportLogsWhereInput", "ImportLogsOrderByInput", "ImportLogsEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "ImportLogs"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &ImportLogsEdgeExecArray{nodes}
}

func (instance *ImportLogsConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateImportLogs"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ImportLogsConnectionExec) Exec(ctx context.Context) (*ImportLogsConnection, error) {
	var v ImportLogsConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImportLogsConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImportLogsConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ImportLogsConnectionExecArray) Exec(ctx context.Context) ([]ImportLogsConnection, error) {
	var v []ImportLogsConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImportLogsConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []ImportLogsEdge `json:"edges"`
}

type ImportLogsEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ImportLogsEdgeExec) Node() *ImportLogsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ImportLogs"},
		"node",
		[]string{"id", "fileHash", "name", "mobile", "cardNo", "status", "logContent", "createdAt", "updatedAt"})

	return &ImportLogsExec{ret}
}

func (instance ImportLogsEdgeExec) Exec(ctx context.Context) (*ImportLogsEdge, error) {
	var v ImportLogsEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImportLogsEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImportLogsEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ImportLogsEdgeExecArray) Exec(ctx context.Context) ([]ImportLogsEdge, error) {
	var v []ImportLogsEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImportLogsEdge struct {
	Node   ImportLogs `json:"node"`
	Cursor string     `json:"cursor"`
}

type JobExec struct {
	exec *prisma.Exec
}

func (instance JobExec) Exec(ctx context.Context) (*Job, error) {
	var v Job
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobExecArray struct {
	exec *prisma.Exec
}

func (instance JobExecArray) Exec(ctx context.Context) ([]Job, error) {
	var v []Job
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Job struct {
	ID               int32    `json:"id"`
	WorkId           int32    `json:"workId"`
	Category         int32    `json:"category"`
	SettlementRule   string   `json:"settlementRule"`
	PayStatus        *int32   `json:"payStatus,omitempty"`
	Progress         int32    `json:"progress"`
	Quota            int32    `json:"quota"`
	SingleRewardMax  *float64 `json:"singleRewardMax,omitempty"`
	SingleRewardMin  *float64 `json:"singleRewardMin,omitempty"`
	IsCanComment     int32    `json:"isCanComment"`
	IsNeedProof      int32    `json:"isNeedProof"`
	ProofDescription *string  `json:"proofDescription,omitempty"`
	ProofType        *int32   `json:"proofType,omitempty"`
	Remark           *string  `json:"remark,omitempty"`
	TemplateId       int32    `json:"templateId"`
	Extend           *string  `json:"extend,omitempty"`
	CreatedAt        string   `json:"createdAt"`
	UpdatedAt        string   `json:"updatedAt"`
	DeletedAt        *int32   `json:"deletedAt,omitempty"`
}

type JobConnectionExec struct {
	exec *prisma.Exec
}

func (instance *JobConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *JobConnectionExec) Edges() *JobEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"JobWhereInput", "JobOrderByInput", "JobEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Job"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &JobEdgeExecArray{nodes}
}

func (instance *JobConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateJob"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance JobConnectionExec) Exec(ctx context.Context) (*JobConnection, error) {
	var v JobConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance JobConnectionExecArray) Exec(ctx context.Context) ([]JobConnection, error) {
	var v []JobConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobConnection struct {
	PageInfo PageInfo  `json:"pageInfo"`
	Edges    []JobEdge `json:"edges"`
}

type JobEdgeExec struct {
	exec *prisma.Exec
}

func (instance *JobEdgeExec) Node() *JobExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Job"},
		"node",
		[]string{"id", "workId", "category", "settlementRule", "payStatus", "progress", "quota", "singleRewardMax", "singleRewardMin", "isCanComment", "isNeedProof", "proofDescription", "proofType", "remark", "templateId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobExec{ret}
}

func (instance JobEdgeExec) Exec(ctx context.Context) (*JobEdge, error) {
	var v JobEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance JobEdgeExecArray) Exec(ctx context.Context) ([]JobEdge, error) {
	var v []JobEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobEdge struct {
	Node   Job    `json:"node"`
	Cursor string `json:"cursor"`
}

type JobAchievementExec struct {
	exec *prisma.Exec
}

func (instance JobAchievementExec) Exec(ctx context.Context) (*JobAchievement, error) {
	var v JobAchievement
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobAchievementExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobAchievementExecArray struct {
	exec *prisma.Exec
}

func (instance JobAchievementExecArray) Exec(ctx context.Context) ([]JobAchievement, error) {
	var v []JobAchievement
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobAchievement struct {
	ID        int32   `json:"id"`
	JobId     int32   `json:"jobId"`
	UserId    string  `json:"userId"`
	Extend    *string `json:"extend,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	DeletedAt *int32  `json:"deletedAt,omitempty"`
}

type JobAchievementConnectionExec struct {
	exec *prisma.Exec
}

func (instance *JobAchievementConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *JobAchievementConnectionExec) Edges() *JobAchievementEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"JobAchievementWhereInput", "JobAchievementOrderByInput", "JobAchievementEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "JobAchievement"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &JobAchievementEdgeExecArray{nodes}
}

func (instance *JobAchievementConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateJobAchievement"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance JobAchievementConnectionExec) Exec(ctx context.Context) (*JobAchievementConnection, error) {
	var v JobAchievementConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobAchievementConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobAchievementConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance JobAchievementConnectionExecArray) Exec(ctx context.Context) ([]JobAchievementConnection, error) {
	var v []JobAchievementConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobAchievementConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []JobAchievementEdge `json:"edges"`
}

type JobAchievementEdgeExec struct {
	exec *prisma.Exec
}

func (instance *JobAchievementEdgeExec) Node() *JobAchievementExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobAchievement"},
		"node",
		[]string{"id", "jobId", "userId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobAchievementExec{ret}
}

func (instance JobAchievementEdgeExec) Exec(ctx context.Context) (*JobAchievementEdge, error) {
	var v JobAchievementEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobAchievementEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobAchievementEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance JobAchievementEdgeExecArray) Exec(ctx context.Context) ([]JobAchievementEdge, error) {
	var v []JobAchievementEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobAchievementEdge struct {
	Node   JobAchievement `json:"node"`
	Cursor string         `json:"cursor"`
}

type JobContractJournalExec struct {
	exec *prisma.Exec
}

func (instance JobContractJournalExec) Exec(ctx context.Context) (*JobContractJournal, error) {
	var v JobContractJournal
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobContractJournalExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobContractJournalExecArray struct {
	exec *prisma.Exec
}

func (instance JobContractJournalExecArray) Exec(ctx context.Context) ([]JobContractJournal, error) {
	var v []JobContractJournal
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobContractJournal struct {
	ID               int32   `json:"id"`
	ContractNo       *string `json:"contractNo,omitempty"`
	CompanyId        int32   `json:"companyId"`
	ServiceCompanyId int32   `json:"serviceCompanyId"`
	BeginTimestamp   int32   `json:"beginTimestamp"`
	EndTimestamp     int32   `json:"endTimestamp"`
	ActiveTimestamp  int32   `json:"activeTimestamp"`
	IsHandled        int32   `json:"isHandled"`
	Extend           *string `json:"extend,omitempty"`
	Remark           *string `json:"remark,omitempty"`
	CreatedAt        string  `json:"createdAt"`
	UpdatedAt        string  `json:"updatedAt"`
	DeletedAt        *int32  `json:"deletedAt,omitempty"`
}

type JobContractJournalConnectionExec struct {
	exec *prisma.Exec
}

func (instance *JobContractJournalConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *JobContractJournalConnectionExec) Edges() *JobContractJournalEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"JobContractJournalWhereInput", "JobContractJournalOrderByInput", "JobContractJournalEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "JobContractJournal"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &JobContractJournalEdgeExecArray{nodes}
}

func (instance *JobContractJournalConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateJobContractJournal"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance JobContractJournalConnectionExec) Exec(ctx context.Context) (*JobContractJournalConnection, error) {
	var v JobContractJournalConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobContractJournalConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobContractJournalConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance JobContractJournalConnectionExecArray) Exec(ctx context.Context) ([]JobContractJournalConnection, error) {
	var v []JobContractJournalConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobContractJournalConnection struct {
	PageInfo PageInfo                 `json:"pageInfo"`
	Edges    []JobContractJournalEdge `json:"edges"`
}

type JobContractJournalEdgeExec struct {
	exec *prisma.Exec
}

func (instance *JobContractJournalEdgeExec) Node() *JobContractJournalExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobContractJournal"},
		"node",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "activeTimestamp", "isHandled", "extend", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobContractJournalExec{ret}
}

func (instance JobContractJournalEdgeExec) Exec(ctx context.Context) (*JobContractJournalEdge, error) {
	var v JobContractJournalEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobContractJournalEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobContractJournalEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance JobContractJournalEdgeExecArray) Exec(ctx context.Context) ([]JobContractJournalEdge, error) {
	var v []JobContractJournalEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobContractJournalEdge struct {
	Node   JobContractJournal `json:"node"`
	Cursor string             `json:"cursor"`
}

type JobMemberExec struct {
	exec *prisma.Exec
}

func (instance JobMemberExec) Exec(ctx context.Context) (*JobMember, error) {
	var v JobMember
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobMemberExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobMemberExecArray struct {
	exec *prisma.Exec
}

func (instance JobMemberExecArray) Exec(ctx context.Context) ([]JobMember, error) {
	var v []JobMember
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobMember struct {
	ID            int32    `json:"id"`
	WorkId        int32    `json:"workId"`
	CompanyId     int32    `json:"companyId"`
	PublisherId   string   `json:"publisherId"`
	ParticipantId *string  `json:"participantId,omitempty"`
	Source        int32    `json:"source"`
	Progress      int32    `json:"progress"`
	ProofFileUrl  *string  `json:"proofFileUrl,omitempty"`
	Reward        *float64 `json:"reward,omitempty"`
	ParticipateAt *int32   `json:"participateAt,omitempty"`
	FinishAt      *int32   `json:"finishAt,omitempty"`
	Remark        *string  `json:"remark,omitempty"`
	Extend        *string  `json:"extend,omitempty"`
	CreatedAt     string   `json:"createdAt"`
	UpdatedAt     string   `json:"updatedAt"`
	DeletedAt     *int32   `json:"deletedAt,omitempty"`
}

type JobMemberConnectionExec struct {
	exec *prisma.Exec
}

func (instance *JobMemberConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *JobMemberConnectionExec) Edges() *JobMemberEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"JobMemberWhereInput", "JobMemberOrderByInput", "JobMemberEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "JobMember"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &JobMemberEdgeExecArray{nodes}
}

func (instance *JobMemberConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateJobMember"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance JobMemberConnectionExec) Exec(ctx context.Context) (*JobMemberConnection, error) {
	var v JobMemberConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobMemberConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobMemberConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance JobMemberConnectionExecArray) Exec(ctx context.Context) ([]JobMemberConnection, error) {
	var v []JobMemberConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobMemberConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []JobMemberEdge `json:"edges"`
}

type JobMemberEdgeExec struct {
	exec *prisma.Exec
}

func (instance *JobMemberEdgeExec) Node() *JobMemberExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobMember"},
		"node",
		[]string{"id", "workId", "companyId", "publisherId", "participantId", "source", "progress", "proofFileUrl", "reward", "participateAt", "finishAt", "remark", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobMemberExec{ret}
}

func (instance JobMemberEdgeExec) Exec(ctx context.Context) (*JobMemberEdge, error) {
	var v JobMemberEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobMemberEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobMemberEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance JobMemberEdgeExecArray) Exec(ctx context.Context) ([]JobMemberEdge, error) {
	var v []JobMemberEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobMemberEdge struct {
	Node   JobMember `json:"node"`
	Cursor string    `json:"cursor"`
}

type JobTemplateExec struct {
	exec *prisma.Exec
}

func (instance JobTemplateExec) Exec(ctx context.Context) (*JobTemplate, error) {
	var v JobTemplate
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobTemplateExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobTemplateExecArray struct {
	exec *prisma.Exec
}

func (instance JobTemplateExecArray) Exec(ctx context.Context) ([]JobTemplate, error) {
	var v []JobTemplate
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobTemplate struct {
	ID                 int32   `json:"id"`
	AppId              *string `json:"appId,omitempty"`
	PlatformAppid      *string `json:"platformAppid,omitempty"`
	CompanyId          *int32  `json:"companyId,omitempty"`
	CompanyName        *string `json:"companyName,omitempty"`
	ServiceCompanyId   *int32  `json:"serviceCompanyId,omitempty"`
	ServiceCompanyName *string `json:"serviceCompanyName,omitempty"`
	UserId             *string `json:"userId,omitempty"`
	WorkType           int32   `json:"workType"`
	SignTemplateId     *int32  `json:"signTemplateId,omitempty"`
	ServiceTypeId      int32   `json:"serviceTypeId"`
	ServiceTypeName    *string `json:"serviceTypeName,omitempty"`
	Name               string  `json:"name"`
	Requirement        string  `json:"requirement"`
	SettlementRule     string  `json:"settlementRule"`
	KpiTemplateUrl     *string `json:"kpiTemplateUrl,omitempty"`
	DownloadCode       *string `json:"downloadCode,omitempty"`
	DisplayName        *string `json:"displayName,omitempty"`
	IsEnable           int32   `json:"isEnable"`
	Source             int32   `json:"source"`
	Extend             *string `json:"extend,omitempty"`
	BizContent         *string `json:"bizContent,omitempty"`
	Remark             *string `json:"remark,omitempty"`
	ContractNo         *string `json:"contractNo,omitempty"`
	CreatedAt          string  `json:"createdAt"`
	UpdatedAt          string  `json:"updatedAt"`
	DeletedAt          *int32  `json:"deletedAt,omitempty"`
}

type JobTemplateConnectionExec struct {
	exec *prisma.Exec
}

func (instance *JobTemplateConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *JobTemplateConnectionExec) Edges() *JobTemplateEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"JobTemplateWhereInput", "JobTemplateOrderByInput", "JobTemplateEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "JobTemplate"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &JobTemplateEdgeExecArray{nodes}
}

func (instance *JobTemplateConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateJobTemplate"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance JobTemplateConnectionExec) Exec(ctx context.Context) (*JobTemplateConnection, error) {
	var v JobTemplateConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobTemplateConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobTemplateConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance JobTemplateConnectionExecArray) Exec(ctx context.Context) ([]JobTemplateConnection, error) {
	var v []JobTemplateConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobTemplateConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []JobTemplateEdge `json:"edges"`
}

type JobTemplateEdgeExec struct {
	exec *prisma.Exec
}

func (instance *JobTemplateEdgeExec) Node() *JobTemplateExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobTemplate"},
		"node",
		[]string{"id", "appId", "platformAppid", "companyId", "companyName", "serviceCompanyId", "serviceCompanyName", "userId", "workType", "signTemplateId", "serviceTypeId", "serviceTypeName", "name", "requirement", "settlementRule", "kpiTemplateUrl", "downloadCode", "displayName", "isEnable", "source", "extend", "bizContent", "remark", "contractNo", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateExec{ret}
}

func (instance JobTemplateEdgeExec) Exec(ctx context.Context) (*JobTemplateEdge, error) {
	var v JobTemplateEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobTemplateEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobTemplateEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance JobTemplateEdgeExecArray) Exec(ctx context.Context) ([]JobTemplateEdge, error) {
	var v []JobTemplateEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobTemplateEdge struct {
	Node   JobTemplate `json:"node"`
	Cursor string      `json:"cursor"`
}

type JobTemplateDelayExec struct {
	exec *prisma.Exec
}

func (instance JobTemplateDelayExec) Exec(ctx context.Context) (*JobTemplateDelay, error) {
	var v JobTemplateDelay
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobTemplateDelayExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobTemplateDelayExecArray struct {
	exec *prisma.Exec
}

func (instance JobTemplateDelayExecArray) Exec(ctx context.Context) ([]JobTemplateDelay, error) {
	var v []JobTemplateDelay
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobTemplateDelay struct {
	ID                 int32   `json:"id"`
	ContractNo         *string `json:"contractNo,omitempty"`
	CompanyId          *int32  `json:"companyId,omitempty"`
	ServiceCompanyId   *int32  `json:"serviceCompanyId,omitempty"`
	BeginTimestamp     *int32  `json:"beginTimestamp,omitempty"`
	EndTimestamp       *int32  `json:"endTimestamp,omitempty"`
	IsNeedProcessBegin *int32  `json:"isNeedProcessBegin,omitempty"`
	IsNeedProcessEnd   *int32  `json:"isNeedProcessEnd,omitempty"`
	Extend             *string `json:"extend,omitempty"`
	BizContent         *string `json:"bizContent,omitempty"`
	Remark             *string `json:"remark,omitempty"`
	CreatedAt          string  `json:"createdAt"`
	UpdatedAt          string  `json:"updatedAt"`
	DeletedAt          *int32  `json:"deletedAt,omitempty"`
}

type JobTemplateDelayConnectionExec struct {
	exec *prisma.Exec
}

func (instance *JobTemplateDelayConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *JobTemplateDelayConnectionExec) Edges() *JobTemplateDelayEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"JobTemplateDelayWhereInput", "JobTemplateDelayOrderByInput", "JobTemplateDelayEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "JobTemplateDelay"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &JobTemplateDelayEdgeExecArray{nodes}
}

func (instance *JobTemplateDelayConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateJobTemplateDelay"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance JobTemplateDelayConnectionExec) Exec(ctx context.Context) (*JobTemplateDelayConnection, error) {
	var v JobTemplateDelayConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobTemplateDelayConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobTemplateDelayConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance JobTemplateDelayConnectionExecArray) Exec(ctx context.Context) ([]JobTemplateDelayConnection, error) {
	var v []JobTemplateDelayConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobTemplateDelayConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []JobTemplateDelayEdge `json:"edges"`
}

type JobTemplateDelayEdgeExec struct {
	exec *prisma.Exec
}

func (instance *JobTemplateDelayEdgeExec) Node() *JobTemplateDelayExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobTemplateDelay"},
		"node",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "isNeedProcessBegin", "isNeedProcessEnd", "extend", "bizContent", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateDelayExec{ret}
}

func (instance JobTemplateDelayEdgeExec) Exec(ctx context.Context) (*JobTemplateDelayEdge, error) {
	var v JobTemplateDelayEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobTemplateDelayEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobTemplateDelayEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance JobTemplateDelayEdgeExecArray) Exec(ctx context.Context) ([]JobTemplateDelayEdge, error) {
	var v []JobTemplateDelayEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobTemplateDelayEdge struct {
	Node   JobTemplateDelay `json:"node"`
	Cursor string           `json:"cursor"`
}

type KpiUploadLogExec struct {
	exec *prisma.Exec
}

func (instance KpiUploadLogExec) Exec(ctx context.Context) (*KpiUploadLog, error) {
	var v KpiUploadLog
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance KpiUploadLogExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type KpiUploadLogExecArray struct {
	exec *prisma.Exec
}

func (instance KpiUploadLogExecArray) Exec(ctx context.Context) ([]KpiUploadLog, error) {
	var v []KpiUploadLog
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type KpiUploadLog struct {
	ID        int32  `json:"id"`
	CompanyId int32  `json:"companyId"`
	FileName  string `json:"fileName"`
	FileUrl   string `json:"fileUrl"`
	Hash      string `json:"hash"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type KpiUploadLogConnectionExec struct {
	exec *prisma.Exec
}

func (instance *KpiUploadLogConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *KpiUploadLogConnectionExec) Edges() *KpiUploadLogEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"KpiUploadLogWhereInput", "KpiUploadLogOrderByInput", "KpiUploadLogEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "KpiUploadLog"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &KpiUploadLogEdgeExecArray{nodes}
}

func (instance *KpiUploadLogConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateKpiUploadLog"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance KpiUploadLogConnectionExec) Exec(ctx context.Context) (*KpiUploadLogConnection, error) {
	var v KpiUploadLogConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance KpiUploadLogConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type KpiUploadLogConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance KpiUploadLogConnectionExecArray) Exec(ctx context.Context) ([]KpiUploadLogConnection, error) {
	var v []KpiUploadLogConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type KpiUploadLogConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []KpiUploadLogEdge `json:"edges"`
}

type KpiUploadLogEdgeExec struct {
	exec *prisma.Exec
}

func (instance *KpiUploadLogEdgeExec) Node() *KpiUploadLogExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "KpiUploadLog"},
		"node",
		[]string{"id", "companyId", "fileName", "fileUrl", "hash", "createdAt", "updatedAt"})

	return &KpiUploadLogExec{ret}
}

func (instance KpiUploadLogEdgeExec) Exec(ctx context.Context) (*KpiUploadLogEdge, error) {
	var v KpiUploadLogEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance KpiUploadLogEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type KpiUploadLogEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance KpiUploadLogEdgeExecArray) Exec(ctx context.Context) ([]KpiUploadLogEdge, error) {
	var v []KpiUploadLogEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type KpiUploadLogEdge struct {
	Node   KpiUploadLog `json:"node"`
	Cursor string       `json:"cursor"`
}

type UserWeChatAuthorizeExec struct {
	exec *prisma.Exec
}

func (instance UserWeChatAuthorizeExec) Exec(ctx context.Context) (*UserWeChatAuthorize, error) {
	var v UserWeChatAuthorize
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserWeChatAuthorizeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserWeChatAuthorizeExecArray struct {
	exec *prisma.Exec
}

func (instance UserWeChatAuthorizeExecArray) Exec(ctx context.Context) ([]UserWeChatAuthorize, error) {
	var v []UserWeChatAuthorize
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserWeChatAuthorize struct {
	ID        int32  `json:"id"`
	UserId    string `json:"userId"`
	Mobile    string `json:"mobile"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	DeletedAt *int32 `json:"deletedAt,omitempty"`
}

type UserWeChatAuthorizeConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserWeChatAuthorizeConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserWeChatAuthorizeConnectionExec) Edges() *UserWeChatAuthorizeEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWeChatAuthorizeWhereInput", "UserWeChatAuthorizeOrderByInput", "UserWeChatAuthorizeEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "UserWeChatAuthorize"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &UserWeChatAuthorizeEdgeExecArray{nodes}
}

func (instance *UserWeChatAuthorizeConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUserWeChatAuthorize"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserWeChatAuthorizeConnectionExec) Exec(ctx context.Context) (*UserWeChatAuthorizeConnection, error) {
	var v UserWeChatAuthorizeConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserWeChatAuthorizeConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserWeChatAuthorizeConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserWeChatAuthorizeConnectionExecArray) Exec(ctx context.Context) ([]UserWeChatAuthorizeConnection, error) {
	var v []UserWeChatAuthorizeConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserWeChatAuthorizeConnection struct {
	PageInfo PageInfo                  `json:"pageInfo"`
	Edges    []UserWeChatAuthorizeEdge `json:"edges"`
}

type UserWeChatAuthorizeEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserWeChatAuthorizeEdgeExec) Node() *UserWeChatAuthorizeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserWeChatAuthorize"},
		"node",
		[]string{"id", "userId", "mobile", "createdAt", "updatedAt", "deletedAt"})

	return &UserWeChatAuthorizeExec{ret}
}

func (instance UserWeChatAuthorizeEdgeExec) Exec(ctx context.Context) (*UserWeChatAuthorizeEdge, error) {
	var v UserWeChatAuthorizeEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserWeChatAuthorizeEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserWeChatAuthorizeEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserWeChatAuthorizeEdgeExecArray) Exec(ctx context.Context) ([]UserWeChatAuthorizeEdge, error) {
	var v []UserWeChatAuthorizeEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserWeChatAuthorizeEdge struct {
	Node   UserWeChatAuthorize `json:"node"`
	Cursor string              `json:"cursor"`
}

type WorkExec struct {
	exec *prisma.Exec
}

func (instance WorkExec) Exec(ctx context.Context) (*Work, error) {
	var v Work
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkExecArray struct {
	exec *prisma.Exec
}

func (instance WorkExecArray) Exec(ctx context.Context) ([]Work, error) {
	var v []Work
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Work struct {
	ID            int32   `json:"id"`
	AppId         string  `json:"appId"`
	CompanyId     int32   `json:"companyId"`
	UserId        string  `json:"userId"`
	ServiceTypeId int32   `json:"serviceTypeId"`
	WorkType      int32   `json:"workType"`
	Name          string  `json:"name"`
	Requirement   string  `json:"requirement"`
	PayType       int32   `json:"payType"`
	Duration      *int32  `json:"duration,omitempty"`
	EndAt         *int32  `json:"endAt,omitempty"`
	Source        int32   `json:"source"`
	Status        *int32  `json:"status,omitempty"`
	Type          int32   `json:"type"`
	IsPublic      int32   `json:"isPublic"`
	MediaCoverUrl *string `json:"mediaCoverUrl,omitempty"`
	MediaUrls     *string `json:"mediaUrls,omitempty"`
	Resume        *string `json:"resume,omitempty"`
	Extend        *string `json:"extend,omitempty"`
	UpdatedAt     string  `json:"updatedAt"`
	CreatedAt     string  `json:"createdAt"`
	DeletedAt     *int32  `json:"deletedAt,omitempty"`
}

type WorkConnectionExec struct {
	exec *prisma.Exec
}

func (instance *WorkConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *WorkConnectionExec) Edges() *WorkEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"WorkWhereInput", "WorkOrderByInput", "WorkEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Work"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &WorkEdgeExecArray{nodes}
}

func (instance *WorkConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateWork"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance WorkConnectionExec) Exec(ctx context.Context) (*WorkConnection, error) {
	var v WorkConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance WorkConnectionExecArray) Exec(ctx context.Context) ([]WorkConnection, error) {
	var v []WorkConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []WorkEdge `json:"edges"`
}

type WorkEdgeExec struct {
	exec *prisma.Exec
}

func (instance *WorkEdgeExec) Node() *WorkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Work"},
		"node",
		[]string{"id", "appId", "companyId", "userId", "serviceTypeId", "workType", "name", "requirement", "payType", "duration", "endAt", "source", "status", "type", "isPublic", "mediaCoverUrl", "mediaUrls", "resume", "extend", "updatedAt", "createdAt", "deletedAt"})

	return &WorkExec{ret}
}

func (instance WorkEdgeExec) Exec(ctx context.Context) (*WorkEdge, error) {
	var v WorkEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance WorkEdgeExecArray) Exec(ctx context.Context) ([]WorkEdge, error) {
	var v []WorkEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkEdge struct {
	Node   Work   `json:"node"`
	Cursor string `json:"cursor"`
}

type WorkExtendExec struct {
	exec *prisma.Exec
}

func (instance WorkExtendExec) Exec(ctx context.Context) (*WorkExtend, error) {
	var v WorkExtend
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkExtendExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkExtendExecArray struct {
	exec *prisma.Exec
}

func (instance WorkExtendExecArray) Exec(ctx context.Context) ([]WorkExtend, error) {
	var v []WorkExtend
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkExtend struct {
	ID           int32   `json:"id"`
	WorkId       int32   `json:"workId"`
	AppId        string  `json:"appId"`
	FocusCount   int32   `json:"focusCount"`
	LikeCount    int32   `json:"likeCount"`
	ShareCount   int32   `json:"shareCount"`
	CommentCount int32   `json:"commentCount"`
	Extend       *string `json:"extend,omitempty"`
	DeletedAt    *int32  `json:"deletedAt,omitempty"`
	CreatedAt    string  `json:"createdAt"`
	UpdatedAt    string  `json:"updatedAt"`
}

type WorkExtendConnectionExec struct {
	exec *prisma.Exec
}

func (instance *WorkExtendConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *WorkExtendConnectionExec) Edges() *WorkExtendEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"WorkExtendWhereInput", "WorkExtendOrderByInput", "WorkExtendEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "WorkExtend"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &WorkExtendEdgeExecArray{nodes}
}

func (instance *WorkExtendConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateWorkExtend"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance WorkExtendConnectionExec) Exec(ctx context.Context) (*WorkExtendConnection, error) {
	var v WorkExtendConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkExtendConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkExtendConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance WorkExtendConnectionExecArray) Exec(ctx context.Context) ([]WorkExtendConnection, error) {
	var v []WorkExtendConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkExtendConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []WorkExtendEdge `json:"edges"`
}

type WorkExtendEdgeExec struct {
	exec *prisma.Exec
}

func (instance *WorkExtendEdgeExec) Node() *WorkExtendExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkExtend"},
		"node",
		[]string{"id", "workId", "appId", "focusCount", "likeCount", "shareCount", "commentCount", "extend", "deletedAt", "createdAt", "updatedAt"})

	return &WorkExtendExec{ret}
}

func (instance WorkExtendEdgeExec) Exec(ctx context.Context) (*WorkExtendEdge, error) {
	var v WorkExtendEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkExtendEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkExtendEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance WorkExtendEdgeExecArray) Exec(ctx context.Context) ([]WorkExtendEdge, error) {
	var v []WorkExtendEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkExtendEdge struct {
	Node   WorkExtend `json:"node"`
	Cursor string     `json:"cursor"`
}

type WorkProgressExec struct {
	exec *prisma.Exec
}

func (instance WorkProgressExec) Exec(ctx context.Context) (*WorkProgress, error) {
	var v WorkProgress
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkProgressExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkProgressExecArray struct {
	exec *prisma.Exec
}

func (instance WorkProgressExecArray) Exec(ctx context.Context) ([]WorkProgress, error) {
	var v []WorkProgress
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkProgress struct {
	ID            int32   `json:"id"`
	AppId         string  `json:"appId"`
	ParticipantId *string `json:"participantId,omitempty"`
	PublisherId   string  `json:"publisherId"`
	WorkId        int32   `json:"workId"`
	Type          string  `json:"type"`
	Extend        *string `json:"extend,omitempty"`
	CreatedAt     string  `json:"createdAt"`
	UpdatedAt     string  `json:"updatedAt"`
}

type WorkProgressConnectionExec struct {
	exec *prisma.Exec
}

func (instance *WorkProgressConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *WorkProgressConnectionExec) Edges() *WorkProgressEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"WorkProgressWhereInput", "WorkProgressOrderByInput", "WorkProgressEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "WorkProgress"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &WorkProgressEdgeExecArray{nodes}
}

func (instance *WorkProgressConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateWorkProgress"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance WorkProgressConnectionExec) Exec(ctx context.Context) (*WorkProgressConnection, error) {
	var v WorkProgressConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkProgressConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkProgressConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance WorkProgressConnectionExecArray) Exec(ctx context.Context) ([]WorkProgressConnection, error) {
	var v []WorkProgressConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkProgressConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []WorkProgressEdge `json:"edges"`
}

type WorkProgressEdgeExec struct {
	exec *prisma.Exec
}

func (instance *WorkProgressEdgeExec) Node() *WorkProgressExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkProgress"},
		"node",
		[]string{"id", "appId", "participantId", "publisherId", "workId", "type", "extend", "createdAt", "updatedAt"})

	return &WorkProgressExec{ret}
}

func (instance WorkProgressEdgeExec) Exec(ctx context.Context) (*WorkProgressEdge, error) {
	var v WorkProgressEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkProgressEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkProgressEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance WorkProgressEdgeExecArray) Exec(ctx context.Context) ([]WorkProgressEdge, error) {
	var v []WorkProgressEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkProgressEdge struct {
	Node   WorkProgress `json:"node"`
	Cursor string       `json:"cursor"`
}

type WorkTemplateExec struct {
	exec *prisma.Exec
}

func (instance WorkTemplateExec) Exec(ctx context.Context) (*WorkTemplate, error) {
	var v WorkTemplate
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkTemplateExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkTemplateExecArray struct {
	exec *prisma.Exec
}

func (instance WorkTemplateExecArray) Exec(ctx context.Context) ([]WorkTemplate, error) {
	var v []WorkTemplate
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkTemplate struct {
	ID        int32  `json:"id"`
	CompanyId int32  `json:"companyId"`
	UserId    string `json:"userId"`
	WorkType  int32  `json:"workType"`
	Data      string `json:"data"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	DeletedAt *int32 `json:"deletedAt,omitempty"`
}

type WorkTemplateConnectionExec struct {
	exec *prisma.Exec
}

func (instance *WorkTemplateConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *WorkTemplateConnectionExec) Edges() *WorkTemplateEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"WorkTemplateWhereInput", "WorkTemplateOrderByInput", "WorkTemplateEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "WorkTemplate"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &WorkTemplateEdgeExecArray{nodes}
}

func (instance *WorkTemplateConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateWorkTemplate"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance WorkTemplateConnectionExec) Exec(ctx context.Context) (*WorkTemplateConnection, error) {
	var v WorkTemplateConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkTemplateConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkTemplateConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance WorkTemplateConnectionExecArray) Exec(ctx context.Context) ([]WorkTemplateConnection, error) {
	var v []WorkTemplateConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkTemplateConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []WorkTemplateEdge `json:"edges"`
}

type WorkTemplateEdgeExec struct {
	exec *prisma.Exec
}

func (instance *WorkTemplateEdgeExec) Node() *WorkTemplateExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkTemplate"},
		"node",
		[]string{"id", "companyId", "userId", "workType", "data", "createdAt", "updatedAt", "deletedAt"})

	return &WorkTemplateExec{ret}
}

func (instance WorkTemplateEdgeExec) Exec(ctx context.Context) (*WorkTemplateEdge, error) {
	var v WorkTemplateEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkTemplateEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkTemplateEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance WorkTemplateEdgeExecArray) Exec(ctx context.Context) ([]WorkTemplateEdge, error) {
	var v []WorkTemplateEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkTemplateEdge struct {
	Node   WorkTemplate `json:"node"`
	Cursor string       `json:"cursor"`
}

type CommonlyUsedPersonnelSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CommonlyUsedPersonnelSubscriptionPayloadExec) Node() *CommonlyUsedPersonnelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CommonlyUsedPersonnel"},
		"node",
		[]string{"id", "companyId", "appId", "userId", "name", "avatar", "cardNo", "mobile", "bankNo", "education", "address", "remark", "signingTime", "createdAt", "updatedAt", "deletedAt"})

	return &CommonlyUsedPersonnelExec{ret}
}

func (instance *CommonlyUsedPersonnelSubscriptionPayloadExec) PreviousValues() *CommonlyUsedPersonnelPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CommonlyUsedPersonnelPreviousValues"},
		"previousValues",
		[]string{"id", "companyId", "appId", "userId", "name", "avatar", "cardNo", "mobile", "bankNo", "education", "address", "remark", "signingTime", "createdAt", "updatedAt", "deletedAt"})

	return &CommonlyUsedPersonnelPreviousValuesExec{ret}
}

func (instance CommonlyUsedPersonnelSubscriptionPayloadExec) Exec(ctx context.Context) (*CommonlyUsedPersonnelSubscriptionPayload, error) {
	var v CommonlyUsedPersonnelSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommonlyUsedPersonnelSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommonlyUsedPersonnelSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CommonlyUsedPersonnelSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CommonlyUsedPersonnelSubscriptionPayload, error) {
	var v []CommonlyUsedPersonnelSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CommonlyUsedPersonnelSubscriptionPayload struct {
	Mutation      MutationType           `json:"mutation"`
	Node          *CommonlyUsedPersonnel `json:"node,omitempty"`
	UpdatedFields []string               `json:"updatedFields,omitempty"`
}

type CommonlyUsedPersonnelPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CommonlyUsedPersonnelPreviousValuesExec) Exec(ctx context.Context) (*CommonlyUsedPersonnelPreviousValues, error) {
	var v CommonlyUsedPersonnelPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommonlyUsedPersonnelPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommonlyUsedPersonnelPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CommonlyUsedPersonnelPreviousValuesExecArray) Exec(ctx context.Context) ([]CommonlyUsedPersonnelPreviousValues, error) {
	var v []CommonlyUsedPersonnelPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CommonlyUsedPersonnelPreviousValues struct {
	ID          int32   `json:"id"`
	CompanyId   int32   `json:"companyId"`
	AppId       string  `json:"appId"`
	UserId      string  `json:"userId"`
	Name        string  `json:"name"`
	Avatar      *string `json:"avatar,omitempty"`
	CardNo      string  `json:"cardNo"`
	Mobile      string  `json:"mobile"`
	BankNo      string  `json:"bankNo"`
	Education   *string `json:"education,omitempty"`
	Address     *string `json:"address,omitempty"`
	Remark      *string `json:"remark,omitempty"`
	SigningTime *int32  `json:"signingTime,omitempty"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
	DeletedAt   *int32  `json:"deletedAt,omitempty"`
}

type CompanyUserBlacklistSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CompanyUserBlacklistSubscriptionPayloadExec) Node() *CompanyUserBlacklistExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CompanyUserBlacklist"},
		"node",
		[]string{"id", "companyId", "participantId", "publisherId", "workId", "type", "createdAt", "updatedAt", "deletedAt"})

	return &CompanyUserBlacklistExec{ret}
}

func (instance *CompanyUserBlacklistSubscriptionPayloadExec) PreviousValues() *CompanyUserBlacklistPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CompanyUserBlacklistPreviousValues"},
		"previousValues",
		[]string{"id", "companyId", "participantId", "publisherId", "workId", "type", "createdAt", "updatedAt", "deletedAt"})

	return &CompanyUserBlacklistPreviousValuesExec{ret}
}

func (instance CompanyUserBlacklistSubscriptionPayloadExec) Exec(ctx context.Context) (*CompanyUserBlacklistSubscriptionPayload, error) {
	var v CompanyUserBlacklistSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyUserBlacklistSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyUserBlacklistSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyUserBlacklistSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CompanyUserBlacklistSubscriptionPayload, error) {
	var v []CompanyUserBlacklistSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyUserBlacklistSubscriptionPayload struct {
	Mutation      MutationType          `json:"mutation"`
	Node          *CompanyUserBlacklist `json:"node,omitempty"`
	UpdatedFields []string              `json:"updatedFields,omitempty"`
}

type CompanyUserBlacklistPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CompanyUserBlacklistPreviousValuesExec) Exec(ctx context.Context) (*CompanyUserBlacklistPreviousValues, error) {
	var v CompanyUserBlacklistPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyUserBlacklistPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyUserBlacklistPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyUserBlacklistPreviousValuesExecArray) Exec(ctx context.Context) ([]CompanyUserBlacklistPreviousValues, error) {
	var v []CompanyUserBlacklistPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyUserBlacklistPreviousValues struct {
	ID            int32  `json:"id"`
	CompanyId     int32  `json:"companyId"`
	ParticipantId string `json:"participantId"`
	PublisherId   string `json:"publisherId"`
	WorkId        *int32 `json:"workId,omitempty"`
	Type          *int32 `json:"type,omitempty"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
	DeletedAt     *int32 `json:"deletedAt,omitempty"`
}

type CompanyUserKpiSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CompanyUserKpiSubscriptionPayloadExec) Node() *CompanyUserKpiExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CompanyUserKpi"},
		"node",
		[]string{"id", "workId", "amount", "companyId", "participantId", "payAt", "publisherId", "isPaid", "kpiCoefficient", "extend", "createdAt", "updatedAt"})

	return &CompanyUserKpiExec{ret}
}

func (instance *CompanyUserKpiSubscriptionPayloadExec) PreviousValues() *CompanyUserKpiPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CompanyUserKpiPreviousValues"},
		"previousValues",
		[]string{"id", "workId", "amount", "companyId", "participantId", "payAt", "publisherId", "isPaid", "kpiCoefficient", "extend", "createdAt", "updatedAt"})

	return &CompanyUserKpiPreviousValuesExec{ret}
}

func (instance CompanyUserKpiSubscriptionPayloadExec) Exec(ctx context.Context) (*CompanyUserKpiSubscriptionPayload, error) {
	var v CompanyUserKpiSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyUserKpiSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyUserKpiSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyUserKpiSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CompanyUserKpiSubscriptionPayload, error) {
	var v []CompanyUserKpiSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyUserKpiSubscriptionPayload struct {
	Mutation      MutationType    `json:"mutation"`
	Node          *CompanyUserKpi `json:"node,omitempty"`
	UpdatedFields []string        `json:"updatedFields,omitempty"`
}

type CompanyUserKpiPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CompanyUserKpiPreviousValuesExec) Exec(ctx context.Context) (*CompanyUserKpiPreviousValues, error) {
	var v CompanyUserKpiPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyUserKpiPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyUserKpiPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyUserKpiPreviousValuesExecArray) Exec(ctx context.Context) ([]CompanyUserKpiPreviousValues, error) {
	var v []CompanyUserKpiPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyUserKpiPreviousValues struct {
	ID             int32    `json:"id"`
	WorkId         int32    `json:"workId"`
	Amount         *float64 `json:"amount,omitempty"`
	CompanyId      int32    `json:"companyId"`
	ParticipantId  string   `json:"participantId"`
	PayAt          *int32   `json:"payAt,omitempty"`
	PublisherId    string   `json:"publisherId"`
	IsPaid         int32    `json:"isPaid"`
	KpiCoefficient *float64 `json:"kpiCoefficient,omitempty"`
	Extend         *string  `json:"extend,omitempty"`
	CreatedAt      string   `json:"createdAt"`
	UpdatedAt      string   `json:"updatedAt"`
}

type ImportLogsSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ImportLogsSubscriptionPayloadExec) Node() *ImportLogsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ImportLogs"},
		"node",
		[]string{"id", "fileHash", "name", "mobile", "cardNo", "status", "logContent", "createdAt", "updatedAt"})

	return &ImportLogsExec{ret}
}

func (instance *ImportLogsSubscriptionPayloadExec) PreviousValues() *ImportLogsPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ImportLogsPreviousValues"},
		"previousValues",
		[]string{"id", "fileHash", "name", "mobile", "cardNo", "status", "logContent", "createdAt", "updatedAt"})

	return &ImportLogsPreviousValuesExec{ret}
}

func (instance ImportLogsSubscriptionPayloadExec) Exec(ctx context.Context) (*ImportLogsSubscriptionPayload, error) {
	var v ImportLogsSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImportLogsSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImportLogsSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ImportLogsSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ImportLogsSubscriptionPayload, error) {
	var v []ImportLogsSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImportLogsSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *ImportLogs  `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ImportLogsPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ImportLogsPreviousValuesExec) Exec(ctx context.Context) (*ImportLogsPreviousValues, error) {
	var v ImportLogsPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImportLogsPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImportLogsPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ImportLogsPreviousValuesExecArray) Exec(ctx context.Context) ([]ImportLogsPreviousValues, error) {
	var v []ImportLogsPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImportLogsPreviousValues struct {
	ID         int32   `json:"id"`
	FileHash   *string `json:"fileHash,omitempty"`
	Name       *string `json:"name,omitempty"`
	Mobile     *string `json:"mobile,omitempty"`
	CardNo     *string `json:"cardNo,omitempty"`
	Status     *int32  `json:"status,omitempty"`
	LogContent *string `json:"logContent,omitempty"`
	CreatedAt  string  `json:"createdAt"`
	UpdatedAt  string  `json:"updatedAt"`
}

type JobSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *JobSubscriptionPayloadExec) Node() *JobExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Job"},
		"node",
		[]string{"id", "workId", "category", "settlementRule", "payStatus", "progress", "quota", "singleRewardMax", "singleRewardMin", "isCanComment", "isNeedProof", "proofDescription", "proofType", "remark", "templateId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobExec{ret}
}

func (instance *JobSubscriptionPayloadExec) PreviousValues() *JobPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobPreviousValues"},
		"previousValues",
		[]string{"id", "workId", "category", "settlementRule", "payStatus", "progress", "quota", "singleRewardMax", "singleRewardMin", "isCanComment", "isNeedProof", "proofDescription", "proofType", "remark", "templateId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobPreviousValuesExec{ret}
}

func (instance JobSubscriptionPayloadExec) Exec(ctx context.Context) (*JobSubscriptionPayload, error) {
	var v JobSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance JobSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]JobSubscriptionPayload, error) {
	var v []JobSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Job         `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type JobPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance JobPreviousValuesExec) Exec(ctx context.Context) (*JobPreviousValues, error) {
	var v JobPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance JobPreviousValuesExecArray) Exec(ctx context.Context) ([]JobPreviousValues, error) {
	var v []JobPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobPreviousValues struct {
	ID               int32    `json:"id"`
	WorkId           int32    `json:"workId"`
	Category         int32    `json:"category"`
	SettlementRule   string   `json:"settlementRule"`
	PayStatus        *int32   `json:"payStatus,omitempty"`
	Progress         int32    `json:"progress"`
	Quota            int32    `json:"quota"`
	SingleRewardMax  *float64 `json:"singleRewardMax,omitempty"`
	SingleRewardMin  *float64 `json:"singleRewardMin,omitempty"`
	IsCanComment     int32    `json:"isCanComment"`
	IsNeedProof      int32    `json:"isNeedProof"`
	ProofDescription *string  `json:"proofDescription,omitempty"`
	ProofType        *int32   `json:"proofType,omitempty"`
	Remark           *string  `json:"remark,omitempty"`
	TemplateId       int32    `json:"templateId"`
	Extend           *string  `json:"extend,omitempty"`
	CreatedAt        string   `json:"createdAt"`
	UpdatedAt        string   `json:"updatedAt"`
	DeletedAt        *int32   `json:"deletedAt,omitempty"`
}

type JobAchievementSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *JobAchievementSubscriptionPayloadExec) Node() *JobAchievementExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobAchievement"},
		"node",
		[]string{"id", "jobId", "userId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobAchievementExec{ret}
}

func (instance *JobAchievementSubscriptionPayloadExec) PreviousValues() *JobAchievementPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobAchievementPreviousValues"},
		"previousValues",
		[]string{"id", "jobId", "userId", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobAchievementPreviousValuesExec{ret}
}

func (instance JobAchievementSubscriptionPayloadExec) Exec(ctx context.Context) (*JobAchievementSubscriptionPayload, error) {
	var v JobAchievementSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobAchievementSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobAchievementSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance JobAchievementSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]JobAchievementSubscriptionPayload, error) {
	var v []JobAchievementSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobAchievementSubscriptionPayload struct {
	Mutation      MutationType    `json:"mutation"`
	Node          *JobAchievement `json:"node,omitempty"`
	UpdatedFields []string        `json:"updatedFields,omitempty"`
}

type JobAchievementPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance JobAchievementPreviousValuesExec) Exec(ctx context.Context) (*JobAchievementPreviousValues, error) {
	var v JobAchievementPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobAchievementPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobAchievementPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance JobAchievementPreviousValuesExecArray) Exec(ctx context.Context) ([]JobAchievementPreviousValues, error) {
	var v []JobAchievementPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobAchievementPreviousValues struct {
	ID        int32   `json:"id"`
	JobId     int32   `json:"jobId"`
	UserId    string  `json:"userId"`
	Extend    *string `json:"extend,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	DeletedAt *int32  `json:"deletedAt,omitempty"`
}

type JobContractJournalSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *JobContractJournalSubscriptionPayloadExec) Node() *JobContractJournalExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobContractJournal"},
		"node",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "activeTimestamp", "isHandled", "extend", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobContractJournalExec{ret}
}

func (instance *JobContractJournalSubscriptionPayloadExec) PreviousValues() *JobContractJournalPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobContractJournalPreviousValues"},
		"previousValues",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "activeTimestamp", "isHandled", "extend", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobContractJournalPreviousValuesExec{ret}
}

func (instance JobContractJournalSubscriptionPayloadExec) Exec(ctx context.Context) (*JobContractJournalSubscriptionPayload, error) {
	var v JobContractJournalSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobContractJournalSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobContractJournalSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance JobContractJournalSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]JobContractJournalSubscriptionPayload, error) {
	var v []JobContractJournalSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobContractJournalSubscriptionPayload struct {
	Mutation      MutationType        `json:"mutation"`
	Node          *JobContractJournal `json:"node,omitempty"`
	UpdatedFields []string            `json:"updatedFields,omitempty"`
}

type JobContractJournalPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance JobContractJournalPreviousValuesExec) Exec(ctx context.Context) (*JobContractJournalPreviousValues, error) {
	var v JobContractJournalPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobContractJournalPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobContractJournalPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance JobContractJournalPreviousValuesExecArray) Exec(ctx context.Context) ([]JobContractJournalPreviousValues, error) {
	var v []JobContractJournalPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobContractJournalPreviousValues struct {
	ID               int32   `json:"id"`
	ContractNo       *string `json:"contractNo,omitempty"`
	CompanyId        int32   `json:"companyId"`
	ServiceCompanyId int32   `json:"serviceCompanyId"`
	BeginTimestamp   int32   `json:"beginTimestamp"`
	EndTimestamp     int32   `json:"endTimestamp"`
	ActiveTimestamp  int32   `json:"activeTimestamp"`
	IsHandled        int32   `json:"isHandled"`
	Extend           *string `json:"extend,omitempty"`
	Remark           *string `json:"remark,omitempty"`
	CreatedAt        string  `json:"createdAt"`
	UpdatedAt        string  `json:"updatedAt"`
	DeletedAt        *int32  `json:"deletedAt,omitempty"`
}

type JobMemberSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *JobMemberSubscriptionPayloadExec) Node() *JobMemberExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobMember"},
		"node",
		[]string{"id", "workId", "companyId", "publisherId", "participantId", "source", "progress", "proofFileUrl", "reward", "participateAt", "finishAt", "remark", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobMemberExec{ret}
}

func (instance *JobMemberSubscriptionPayloadExec) PreviousValues() *JobMemberPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobMemberPreviousValues"},
		"previousValues",
		[]string{"id", "workId", "companyId", "publisherId", "participantId", "source", "progress", "proofFileUrl", "reward", "participateAt", "finishAt", "remark", "extend", "createdAt", "updatedAt", "deletedAt"})

	return &JobMemberPreviousValuesExec{ret}
}

func (instance JobMemberSubscriptionPayloadExec) Exec(ctx context.Context) (*JobMemberSubscriptionPayload, error) {
	var v JobMemberSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobMemberSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobMemberSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance JobMemberSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]JobMemberSubscriptionPayload, error) {
	var v []JobMemberSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobMemberSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *JobMember   `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type JobMemberPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance JobMemberPreviousValuesExec) Exec(ctx context.Context) (*JobMemberPreviousValues, error) {
	var v JobMemberPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobMemberPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobMemberPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance JobMemberPreviousValuesExecArray) Exec(ctx context.Context) ([]JobMemberPreviousValues, error) {
	var v []JobMemberPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobMemberPreviousValues struct {
	ID            int32    `json:"id"`
	WorkId        int32    `json:"workId"`
	CompanyId     int32    `json:"companyId"`
	PublisherId   string   `json:"publisherId"`
	ParticipantId *string  `json:"participantId,omitempty"`
	Source        int32    `json:"source"`
	Progress      int32    `json:"progress"`
	ProofFileUrl  *string  `json:"proofFileUrl,omitempty"`
	Reward        *float64 `json:"reward,omitempty"`
	ParticipateAt *int32   `json:"participateAt,omitempty"`
	FinishAt      *int32   `json:"finishAt,omitempty"`
	Remark        *string  `json:"remark,omitempty"`
	Extend        *string  `json:"extend,omitempty"`
	CreatedAt     string   `json:"createdAt"`
	UpdatedAt     string   `json:"updatedAt"`
	DeletedAt     *int32   `json:"deletedAt,omitempty"`
}

type JobTemplateSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *JobTemplateSubscriptionPayloadExec) Node() *JobTemplateExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobTemplate"},
		"node",
		[]string{"id", "appId", "platformAppid", "companyId", "companyName", "serviceCompanyId", "serviceCompanyName", "userId", "workType", "signTemplateId", "serviceTypeId", "serviceTypeName", "name", "requirement", "settlementRule", "kpiTemplateUrl", "downloadCode", "displayName", "isEnable", "source", "extend", "bizContent", "remark", "contractNo", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateExec{ret}
}

func (instance *JobTemplateSubscriptionPayloadExec) PreviousValues() *JobTemplatePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobTemplatePreviousValues"},
		"previousValues",
		[]string{"id", "appId", "platformAppid", "companyId", "companyName", "serviceCompanyId", "serviceCompanyName", "userId", "workType", "signTemplateId", "serviceTypeId", "serviceTypeName", "name", "requirement", "settlementRule", "kpiTemplateUrl", "downloadCode", "displayName", "isEnable", "source", "extend", "bizContent", "remark", "contractNo", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplatePreviousValuesExec{ret}
}

func (instance JobTemplateSubscriptionPayloadExec) Exec(ctx context.Context) (*JobTemplateSubscriptionPayload, error) {
	var v JobTemplateSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobTemplateSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobTemplateSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance JobTemplateSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]JobTemplateSubscriptionPayload, error) {
	var v []JobTemplateSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobTemplateSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *JobTemplate `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type JobTemplatePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance JobTemplatePreviousValuesExec) Exec(ctx context.Context) (*JobTemplatePreviousValues, error) {
	var v JobTemplatePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobTemplatePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobTemplatePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance JobTemplatePreviousValuesExecArray) Exec(ctx context.Context) ([]JobTemplatePreviousValues, error) {
	var v []JobTemplatePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobTemplatePreviousValues struct {
	ID                 int32   `json:"id"`
	AppId              *string `json:"appId,omitempty"`
	PlatformAppid      *string `json:"platformAppid,omitempty"`
	CompanyId          *int32  `json:"companyId,omitempty"`
	CompanyName        *string `json:"companyName,omitempty"`
	ServiceCompanyId   *int32  `json:"serviceCompanyId,omitempty"`
	ServiceCompanyName *string `json:"serviceCompanyName,omitempty"`
	UserId             *string `json:"userId,omitempty"`
	WorkType           int32   `json:"workType"`
	SignTemplateId     *int32  `json:"signTemplateId,omitempty"`
	ServiceTypeId      int32   `json:"serviceTypeId"`
	ServiceTypeName    *string `json:"serviceTypeName,omitempty"`
	Name               string  `json:"name"`
	Requirement        string  `json:"requirement"`
	SettlementRule     string  `json:"settlementRule"`
	KpiTemplateUrl     *string `json:"kpiTemplateUrl,omitempty"`
	DownloadCode       *string `json:"downloadCode,omitempty"`
	DisplayName        *string `json:"displayName,omitempty"`
	IsEnable           int32   `json:"isEnable"`
	Source             int32   `json:"source"`
	Extend             *string `json:"extend,omitempty"`
	BizContent         *string `json:"bizContent,omitempty"`
	Remark             *string `json:"remark,omitempty"`
	ContractNo         *string `json:"contractNo,omitempty"`
	CreatedAt          string  `json:"createdAt"`
	UpdatedAt          string  `json:"updatedAt"`
	DeletedAt          *int32  `json:"deletedAt,omitempty"`
}

type JobTemplateDelaySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *JobTemplateDelaySubscriptionPayloadExec) Node() *JobTemplateDelayExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobTemplateDelay"},
		"node",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "isNeedProcessBegin", "isNeedProcessEnd", "extend", "bizContent", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateDelayExec{ret}
}

func (instance *JobTemplateDelaySubscriptionPayloadExec) PreviousValues() *JobTemplateDelayPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "JobTemplateDelayPreviousValues"},
		"previousValues",
		[]string{"id", "contractNo", "companyId", "serviceCompanyId", "beginTimestamp", "endTimestamp", "isNeedProcessBegin", "isNeedProcessEnd", "extend", "bizContent", "remark", "createdAt", "updatedAt", "deletedAt"})

	return &JobTemplateDelayPreviousValuesExec{ret}
}

func (instance JobTemplateDelaySubscriptionPayloadExec) Exec(ctx context.Context) (*JobTemplateDelaySubscriptionPayload, error) {
	var v JobTemplateDelaySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobTemplateDelaySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobTemplateDelaySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance JobTemplateDelaySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]JobTemplateDelaySubscriptionPayload, error) {
	var v []JobTemplateDelaySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobTemplateDelaySubscriptionPayload struct {
	Mutation      MutationType      `json:"mutation"`
	Node          *JobTemplateDelay `json:"node,omitempty"`
	UpdatedFields []string          `json:"updatedFields,omitempty"`
}

type JobTemplateDelayPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance JobTemplateDelayPreviousValuesExec) Exec(ctx context.Context) (*JobTemplateDelayPreviousValues, error) {
	var v JobTemplateDelayPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance JobTemplateDelayPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type JobTemplateDelayPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance JobTemplateDelayPreviousValuesExecArray) Exec(ctx context.Context) ([]JobTemplateDelayPreviousValues, error) {
	var v []JobTemplateDelayPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type JobTemplateDelayPreviousValues struct {
	ID                 int32   `json:"id"`
	ContractNo         *string `json:"contractNo,omitempty"`
	CompanyId          *int32  `json:"companyId,omitempty"`
	ServiceCompanyId   *int32  `json:"serviceCompanyId,omitempty"`
	BeginTimestamp     *int32  `json:"beginTimestamp,omitempty"`
	EndTimestamp       *int32  `json:"endTimestamp,omitempty"`
	IsNeedProcessBegin *int32  `json:"isNeedProcessBegin,omitempty"`
	IsNeedProcessEnd   *int32  `json:"isNeedProcessEnd,omitempty"`
	Extend             *string `json:"extend,omitempty"`
	BizContent         *string `json:"bizContent,omitempty"`
	Remark             *string `json:"remark,omitempty"`
	CreatedAt          string  `json:"createdAt"`
	UpdatedAt          string  `json:"updatedAt"`
	DeletedAt          *int32  `json:"deletedAt,omitempty"`
}

type KpiUploadLogSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *KpiUploadLogSubscriptionPayloadExec) Node() *KpiUploadLogExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "KpiUploadLog"},
		"node",
		[]string{"id", "companyId", "fileName", "fileUrl", "hash", "createdAt", "updatedAt"})

	return &KpiUploadLogExec{ret}
}

func (instance *KpiUploadLogSubscriptionPayloadExec) PreviousValues() *KpiUploadLogPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "KpiUploadLogPreviousValues"},
		"previousValues",
		[]string{"id", "companyId", "fileName", "fileUrl", "hash", "createdAt", "updatedAt"})

	return &KpiUploadLogPreviousValuesExec{ret}
}

func (instance KpiUploadLogSubscriptionPayloadExec) Exec(ctx context.Context) (*KpiUploadLogSubscriptionPayload, error) {
	var v KpiUploadLogSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance KpiUploadLogSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type KpiUploadLogSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance KpiUploadLogSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]KpiUploadLogSubscriptionPayload, error) {
	var v []KpiUploadLogSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type KpiUploadLogSubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *KpiUploadLog `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type KpiUploadLogPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance KpiUploadLogPreviousValuesExec) Exec(ctx context.Context) (*KpiUploadLogPreviousValues, error) {
	var v KpiUploadLogPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance KpiUploadLogPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type KpiUploadLogPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance KpiUploadLogPreviousValuesExecArray) Exec(ctx context.Context) ([]KpiUploadLogPreviousValues, error) {
	var v []KpiUploadLogPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type KpiUploadLogPreviousValues struct {
	ID        int32  `json:"id"`
	CompanyId int32  `json:"companyId"`
	FileName  string `json:"fileName"`
	FileUrl   string `json:"fileUrl"`
	Hash      string `json:"hash"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type UserWeChatAuthorizeSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserWeChatAuthorizeSubscriptionPayloadExec) Node() *UserWeChatAuthorizeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserWeChatAuthorize"},
		"node",
		[]string{"id", "userId", "mobile", "createdAt", "updatedAt", "deletedAt"})

	return &UserWeChatAuthorizeExec{ret}
}

func (instance *UserWeChatAuthorizeSubscriptionPayloadExec) PreviousValues() *UserWeChatAuthorizePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserWeChatAuthorizePreviousValues"},
		"previousValues",
		[]string{"id", "userId", "mobile", "createdAt", "updatedAt", "deletedAt"})

	return &UserWeChatAuthorizePreviousValuesExec{ret}
}

func (instance UserWeChatAuthorizeSubscriptionPayloadExec) Exec(ctx context.Context) (*UserWeChatAuthorizeSubscriptionPayload, error) {
	var v UserWeChatAuthorizeSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserWeChatAuthorizeSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserWeChatAuthorizeSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserWeChatAuthorizeSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserWeChatAuthorizeSubscriptionPayload, error) {
	var v []UserWeChatAuthorizeSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserWeChatAuthorizeSubscriptionPayload struct {
	Mutation      MutationType         `json:"mutation"`
	Node          *UserWeChatAuthorize `json:"node,omitempty"`
	UpdatedFields []string             `json:"updatedFields,omitempty"`
}

type UserWeChatAuthorizePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserWeChatAuthorizePreviousValuesExec) Exec(ctx context.Context) (*UserWeChatAuthorizePreviousValues, error) {
	var v UserWeChatAuthorizePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserWeChatAuthorizePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserWeChatAuthorizePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserWeChatAuthorizePreviousValuesExecArray) Exec(ctx context.Context) ([]UserWeChatAuthorizePreviousValues, error) {
	var v []UserWeChatAuthorizePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserWeChatAuthorizePreviousValues struct {
	ID        int32  `json:"id"`
	UserId    string `json:"userId"`
	Mobile    string `json:"mobile"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	DeletedAt *int32 `json:"deletedAt,omitempty"`
}

type WorkSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *WorkSubscriptionPayloadExec) Node() *WorkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Work"},
		"node",
		[]string{"id", "appId", "companyId", "userId", "serviceTypeId", "workType", "name", "requirement", "payType", "duration", "endAt", "source", "status", "type", "isPublic", "mediaCoverUrl", "mediaUrls", "resume", "extend", "updatedAt", "createdAt", "deletedAt"})

	return &WorkExec{ret}
}

func (instance *WorkSubscriptionPayloadExec) PreviousValues() *WorkPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkPreviousValues"},
		"previousValues",
		[]string{"id", "appId", "companyId", "userId", "serviceTypeId", "workType", "name", "requirement", "payType", "duration", "endAt", "source", "status", "type", "isPublic", "mediaCoverUrl", "mediaUrls", "resume", "extend", "updatedAt", "createdAt", "deletedAt"})

	return &WorkPreviousValuesExec{ret}
}

func (instance WorkSubscriptionPayloadExec) Exec(ctx context.Context) (*WorkSubscriptionPayload, error) {
	var v WorkSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance WorkSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WorkSubscriptionPayload, error) {
	var v []WorkSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Work        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type WorkPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance WorkPreviousValuesExec) Exec(ctx context.Context) (*WorkPreviousValues, error) {
	var v WorkPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance WorkPreviousValuesExecArray) Exec(ctx context.Context) ([]WorkPreviousValues, error) {
	var v []WorkPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkPreviousValues struct {
	ID            int32   `json:"id"`
	AppId         string  `json:"appId"`
	CompanyId     int32   `json:"companyId"`
	UserId        string  `json:"userId"`
	ServiceTypeId int32   `json:"serviceTypeId"`
	WorkType      int32   `json:"workType"`
	Name          string  `json:"name"`
	Requirement   string  `json:"requirement"`
	PayType       int32   `json:"payType"`
	Duration      *int32  `json:"duration,omitempty"`
	EndAt         *int32  `json:"endAt,omitempty"`
	Source        int32   `json:"source"`
	Status        *int32  `json:"status,omitempty"`
	Type          int32   `json:"type"`
	IsPublic      int32   `json:"isPublic"`
	MediaCoverUrl *string `json:"mediaCoverUrl,omitempty"`
	MediaUrls     *string `json:"mediaUrls,omitempty"`
	Resume        *string `json:"resume,omitempty"`
	Extend        *string `json:"extend,omitempty"`
	UpdatedAt     string  `json:"updatedAt"`
	CreatedAt     string  `json:"createdAt"`
	DeletedAt     *int32  `json:"deletedAt,omitempty"`
}

type WorkExtendSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *WorkExtendSubscriptionPayloadExec) Node() *WorkExtendExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkExtend"},
		"node",
		[]string{"id", "workId", "appId", "focusCount", "likeCount", "shareCount", "commentCount", "extend", "deletedAt", "createdAt", "updatedAt"})

	return &WorkExtendExec{ret}
}

func (instance *WorkExtendSubscriptionPayloadExec) PreviousValues() *WorkExtendPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkExtendPreviousValues"},
		"previousValues",
		[]string{"id", "workId", "appId", "focusCount", "likeCount", "shareCount", "commentCount", "extend", "deletedAt", "createdAt", "updatedAt"})

	return &WorkExtendPreviousValuesExec{ret}
}

func (instance WorkExtendSubscriptionPayloadExec) Exec(ctx context.Context) (*WorkExtendSubscriptionPayload, error) {
	var v WorkExtendSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkExtendSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkExtendSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance WorkExtendSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WorkExtendSubscriptionPayload, error) {
	var v []WorkExtendSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkExtendSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *WorkExtend  `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type WorkExtendPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance WorkExtendPreviousValuesExec) Exec(ctx context.Context) (*WorkExtendPreviousValues, error) {
	var v WorkExtendPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkExtendPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkExtendPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance WorkExtendPreviousValuesExecArray) Exec(ctx context.Context) ([]WorkExtendPreviousValues, error) {
	var v []WorkExtendPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkExtendPreviousValues struct {
	ID           int32   `json:"id"`
	WorkId       int32   `json:"workId"`
	AppId        string  `json:"appId"`
	FocusCount   int32   `json:"focusCount"`
	LikeCount    int32   `json:"likeCount"`
	ShareCount   int32   `json:"shareCount"`
	CommentCount int32   `json:"commentCount"`
	Extend       *string `json:"extend,omitempty"`
	DeletedAt    *int32  `json:"deletedAt,omitempty"`
	CreatedAt    string  `json:"createdAt"`
	UpdatedAt    string  `json:"updatedAt"`
}

type WorkProgressSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *WorkProgressSubscriptionPayloadExec) Node() *WorkProgressExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkProgress"},
		"node",
		[]string{"id", "appId", "participantId", "publisherId", "workId", "type", "extend", "createdAt", "updatedAt"})

	return &WorkProgressExec{ret}
}

func (instance *WorkProgressSubscriptionPayloadExec) PreviousValues() *WorkProgressPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkProgressPreviousValues"},
		"previousValues",
		[]string{"id", "appId", "participantId", "publisherId", "workId", "type", "extend", "createdAt", "updatedAt"})

	return &WorkProgressPreviousValuesExec{ret}
}

func (instance WorkProgressSubscriptionPayloadExec) Exec(ctx context.Context) (*WorkProgressSubscriptionPayload, error) {
	var v WorkProgressSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkProgressSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkProgressSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance WorkProgressSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WorkProgressSubscriptionPayload, error) {
	var v []WorkProgressSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkProgressSubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *WorkProgress `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type WorkProgressPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance WorkProgressPreviousValuesExec) Exec(ctx context.Context) (*WorkProgressPreviousValues, error) {
	var v WorkProgressPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkProgressPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkProgressPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance WorkProgressPreviousValuesExecArray) Exec(ctx context.Context) ([]WorkProgressPreviousValues, error) {
	var v []WorkProgressPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkProgressPreviousValues struct {
	ID            int32   `json:"id"`
	AppId         string  `json:"appId"`
	ParticipantId *string `json:"participantId,omitempty"`
	PublisherId   string  `json:"publisherId"`
	WorkId        int32   `json:"workId"`
	Type          string  `json:"type"`
	Extend        *string `json:"extend,omitempty"`
	CreatedAt     string  `json:"createdAt"`
	UpdatedAt     string  `json:"updatedAt"`
}

type WorkTemplateSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *WorkTemplateSubscriptionPayloadExec) Node() *WorkTemplateExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkTemplate"},
		"node",
		[]string{"id", "companyId", "userId", "workType", "data", "createdAt", "updatedAt", "deletedAt"})

	return &WorkTemplateExec{ret}
}

func (instance *WorkTemplateSubscriptionPayloadExec) PreviousValues() *WorkTemplatePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkTemplatePreviousValues"},
		"previousValues",
		[]string{"id", "companyId", "userId", "workType", "data", "createdAt", "updatedAt", "deletedAt"})

	return &WorkTemplatePreviousValuesExec{ret}
}

func (instance WorkTemplateSubscriptionPayloadExec) Exec(ctx context.Context) (*WorkTemplateSubscriptionPayload, error) {
	var v WorkTemplateSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkTemplateSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkTemplateSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance WorkTemplateSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WorkTemplateSubscriptionPayload, error) {
	var v []WorkTemplateSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkTemplateSubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *WorkTemplate `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type WorkTemplatePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance WorkTemplatePreviousValuesExec) Exec(ctx context.Context) (*WorkTemplatePreviousValues, error) {
	var v WorkTemplatePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkTemplatePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkTemplatePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance WorkTemplatePreviousValuesExecArray) Exec(ctx context.Context) ([]WorkTemplatePreviousValues, error) {
	var v []WorkTemplatePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WorkTemplatePreviousValues struct {
	ID        int32  `json:"id"`
	CompanyId int32  `json:"companyId"`
	UserId    string `json:"userId"`
	WorkType  int32  `json:"workType"`
	Data      string `json:"data"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	DeletedAt *int32 `json:"deletedAt,omitempty"`
}
